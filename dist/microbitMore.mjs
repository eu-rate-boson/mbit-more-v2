var img$4 = "data:image/png;base64,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";

var img$3 = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDIwMDEwOTA0Ly9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy1TVkctMjAwMTA5MDQvRFREL3N2ZzEwLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4wIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiB3aWR0aD0iMjA2My4wMDAwMDBwdCIgaGVpZ2h0PSI4NTMuMDAwMDAwcHQiIHZpZXdCb3g9IjAgMCAyMDYzLjAwMDAwMCA4NTMuMDAwMDAwIgogcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCI+Cgo8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjAwMDAwMCw4NTMuMDAwMDAwKSBzY2FsZSgwLjEwMDAwMCwtMC4xMDAwMDApIgpmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiPgo8cGF0aCBkPSJNMTE1NjUgODE0MyBjLTQ2IC0yNCAtNjYgLTQ1IC04NiAtODggLTQ3IC0xMDMgMTEgLTIyNSAxMjIgLTI1NSAyMwotNiA1MyAtOSA2NyAtNiAyNiA2IDMzIC01IDI4NSAtNDcyIDE0MSAtMjYzIDI1NyAtNDgxIDI1NyAtNDg0IDAgLTMgLTIxIC0xOQotNDcgLTM0IC0yODUgLTE2NSAtNDc4IC00NjggLTUxMyAtODA1IC02IC02NiAtMTAgLTc5MCAtMTAgLTIxMDUgbDAgLTIwMDQKMTIwOSAwIDEyMDggMCAxMiA3MyBjOSA1NSAxMSA1NTcgOSAyMDk3IGwtNCAyMDI1IC0yMSA3NSBjLTYzIDIxNCAtMTUzIDM2MwotMzA4IDUwOCAtNDIgMzkgLTExMCA5MiAtMTUxIDExOCAtNDEgMjUgLTc0IDQ4IC03NCA1MSAwIDMgMTE2IDIyMSAyNTggNDg0CjI1MiA0NzAgMjU4IDQ3OSAyODQgNDc0IDQ0IC0xMCAxMDkgMTQgMTQ5IDU0IDEyMyAxMjMgMjggMzIzIC0xNDYgMzA5IC0xNDgKLTEyIC0yMTMgLTE3NyAtMTIxIC0zMDMgMTQgLTE5IC00IC01NSAtMjQ0IC01MDAgLTE0OCAtMjc1IC0yNjUgLTQ3OSAtMjcyCi00NzkgLTcgMSAtNTMgMTQgLTEwMyAyOCAtMTMzIDM5IC0yNTYgNDkgLTUzNSA0MyAtMjUxIC02IC0zMTEgLTE0IC00MzQgLTU3Ci0zMyAtMTEgLTYzIC0xNyAtNjYgLTEzIC03IDcgLTQ2NiA4NTUgLTUwNCA5MzAgLTE1IDMxIC0xNSAzMyA5IDY5IDYyIDkxIDM1CjIwNyAtNjAgMjYxIC00OCAyNyAtMTI1IDMwIC0xNzAgNnogbTEyNSAtNzggYzM3IC0xOSA1MCAtNDMgNTAgLTkzIDAgLTgwIC05NQotMTIwIC0xNTggLTY3IC01MyA0NCAtNDcgMTIwIDEyIDE1NiAzOCAyMyA1OCAyNCA5NiA0eiBtMjQ0MCAwIGM4OSAtNDYgNTQKLTE4NSAtNDcgLTE4NSAtOTAgMSAtMTM1IDEwOCAtNzAgMTY3IDM5IDM2IDczIDQxIDExNyAxOHogbS05OTAgLTE2NTUgYzE3MgotMzMgMzI1IC0xNjcgMzg5IC0zNDMgbDI2IC03MiAzIC01MTcgYzIgLTI4NSAyIC01MTggMCAtNTE4IC0yIDAgLTMwIDE0IC02MgozMCAtMTY4IDg1IC0zNDUgLTE2IC00MzIgLTI0NyAtMTMzIC0zNTAgLTMgLTgwNiAyNTAgLTg3NCA1OCAtMTYgMTM5IC01IDE5MwoyNSAyNSAxNCA0NyAyNiA0OSAyNiAyIDAgNCAtNDI3IDQgLTk1MCBsMCAtOTUwIC02OTUgMCAtNjk1IDAgMCA5NTUgMCA5NTQgMzYKLTI0IGMxMDYgLTcyIDIyNyAtNTcgMzMzIDQxIDY4IDYzIDExMCAxMzYgMTQ3IDI1OSAyMyA3OSAyNyAxMDggMjcgMjMwIDEgMTU4Ci0xMyAyMzIgLTY4IDM1MiAtMzggODIgLTExOCAxNzQgLTE4MCAyMDUgLTIyIDEyIC02NyAyMyAtMTAxIDI2IC02MSA0IC03NyAwCi0xODYgLTU2IC0xMiAtNiAtMTAgOTc3IDIgMTAzOSAzNiAxODggMTkxIDM1MiAzODIgNDAzIDY0IDE4IDQ5NSAyMiA1NzggNnoKbS03MzIgLTE1MzQgYzEwOSAtNTcgMTc2IC0yMjMgMTc2IC00MzYgMCAtMTc1IC0zNiAtMjk0IC0xMTUgLTM4NSAtMTI2IC0xNDMKLTI4OSAtMzYgLTM0NCAyMjYgLTcwIDMzMiAxMDEgNjkwIDI4MyA1OTV6IG0xMDMwIDAgYzE3MiAtOTEgMjM3IC00NzcgMTIyCi03MjUgLTY3IC0xNDIgLTE2MSAtMTk0IC0yNTIgLTEzOCAtMTY2IDEwMCAtMjIyIDQ4MiAtMTA3IDcyNSAzMSA2NCA4NSAxMjcKMTIzIDE0MiAzMyAxMyA4NCAxMiAxMTQgLTR6Ii8+CjxwYXRoIGQ9Ik0xMjQwMCAzMjQ1IGwtNDUgLTQ1IDIzOCAtMjM4IDIzNyAtMjM3IDIzMCAyMzAgMjMwIDIzMCAtMzYgNTQgLTM2CjU0IC0xOTQgLTE5NCAtMTk0IC0xOTQgLTE5MyAxOTMgLTE5MyAxOTIgLTQ0IC00NXoiLz4KPHBhdGggZD0iTTU2MiA0NDQzIGwzIC0yNDM4IDEwNTQgLTMgYzU4MCAtMSAxMDU5IDIgMTA2MyA2IDcgNyAxMDggNDg5IDEwOAo1MTQgMCA0IC0zODIgOCAtODUwIDggbC04NTAgMCAwIDgyMCAwIDgyMCA3MjQgMCBjNDQ4IDAgNzI3IDQgNzMxIDEwIDUgOCAxMDUKNDk0IDEwNSA1MTIgMCA0IC0zNTEgOCAtNzgwIDggbC03ODAgMCAwIDgyNSAwIDgyNSA3NjQgMCA3NjMgMCA1MiAyNTggYzI4CjE0MSA1MSAyNjAgNTEgMjY1IDAgNCAtNDg2IDcgLTEwODAgNyBsLTEwODAgMCAyIC0yNDM3eiIvPgo8cGF0aCBkPSJNMzQ1NCA2ODY3IGMtMiAtNyAtMyAtOTE1IC0xIC0yMDE3IDMgLTIyMzQgLTMgLTIwNDQgNzEgLTIyNDIgNTQKLTE0NCAxMTcgLTIzOSAyNDEgLTM2MyAxNTcgLTE1NyAzMTQgLTI0NCA1MjUgLTI5MCA5OCAtMjEgNDk0IC0zMiA2NDAgLTE3CjE5MCAyMCAzNTAgNzUgNDkzIDE2OCA4NiA1NyAyMzkgMjA3IDI4OSAyODUgODIgMTI1IDE0NiAyODUgMTY4IDQyMSA2IDQxIDEwCjc1MiAxMCAyMDY2IGwwIDIwMDIgLTI2MCAwIC0yNjAgMCAtMiAtMjAwMiAtMyAtMjAwMyAtMjMgLTU5IGMtNjcgLTE3NyAtMjAyCi0zMDAgLTM3MyAtMzQxIC05MSAtMjEgLTQ5NyAtMjEgLTU4OCAwIC0xODggNDUgLTM0MSAxOTggLTM4NiAzODcgLTEzIDU0IC0xNQozMzIgLTE1IDIwNDEgbDAgMTk3NyAtMjYwIDAgYy0yMDQgMCAtMjYyIC0zIC0yNjYgLTEzeiIvPgo8cGF0aCBkPSJNODU0NSA2ODY4IGMtMyAtNyAtNCAtMTEwNCAtMyAtMjQzOCBsMyAtMjQyNSAyNjAgMCAyNjAgMCAzIDEwMzMgMgoxMDMyIDQ2NSAwIGMzMDYgMCA0ODIgLTQgNTE3IC0xMSAxNzAgLTM2IDMxMiAtMTY2IDM3NyAtMzQzIGwyNiAtNzEgMyAtODIyIDMKLTgyMyAyNjAgMCAyNjAgMCAtMyA4NTMgYy0zIDg1MCAtMyA4NTIgLTI2IDkzMiAtNTAgMTc3IC0xNjYgMzY0IC0zMDUgNDg5CmwtNzEgNjUgMjkgMjIgYzUzIDM5IDE2MyAxNTcgMjA1IDIxOCA3OSAxMTcgMTM3IDI1NiAxNTkgMzg1IDcgMzYgMTEgMjQyIDExCjUxNyAwIDM2NiAtMyA0NzMgLTE1IDUzNiAtNDMgMjI3IC0xNDkgNDIwIC0zMTUgNTc3IC0xMzIgMTI0IC0yNzMgMjAxIC00NjkKMjU0IGwtOTYgMjYgLTc2OCA0IGMtNjIzIDIgLTc2OCAxIC03NzIgLTEweiBtMTUyMCAtNTMzIGMxNDYgLTM4IDI2NiAtMTM4CjMzNCAtMjc2IDU5IC0xMjEgNjMgLTE2NCA1OSAtNjMxIC00IC0zNTUgLTYgLTQxMCAtMjIgLTQ1OCAtNDkgLTE0OSAtMTQwCi0yNTYgLTI3NCAtMzIzIGwtODUgLTQyIC01MDQgLTMgLTUwMyAtMyAwIDg3NiAwIDg3NSA0NjggMCBjMzg4IDAgNDc4IC0zIDUyNwotMTV6Ii8+CjxwYXRoIGQ9Ik0xNDc1MCA2NjE1IGwwIC0yNjUgNDY1IDAgNDY1IDAgMiAtMjE3MiAzIC0yMTczIDI2MyAtMyAyNjIgLTIgMAoyMTc1IDAgMjE3NSA0MzUgMCBjMjM5IDAgNDM1IDEgNDM1IDMgMCAyIDIzIDExNSA1MCAyNTIgMjggMTM3IDUwIDI1NSA1MCAyNjIKMCAxMSAtMjIyIDEzIC0xMjE1IDEzIGwtMTIxNSAwIDAgLTI2NXoiLz4KPHBhdGggZD0iTTE3ODUwIDQ0NDAgbDAgLTI0NDAgMTA2MCAwIDEwNjAgMCA1IDIzIGMzIDEyIDI3IDEzMSA1NCAyNjQgbDQ4CjI0MyAtODUzIDAgLTg1NCAwIDAgODIwIDAgODIwIDczMCAwIDczMCAwIDUgMjMgYzMgMTIgMjcgMTMxIDU0IDI2NSBsNDggMjQyCi03ODMgMCAtNzg0IDAgMCA4MjUgMCA4MjUgNzY1IDAgNzY1IDAgNSAyMyBjMTYgNjggOTUgNDc0IDk1IDQ4OSAwIDE3IC00NCAxOAotMTA3NSAxOCBsLTEwNzUgMCAwIC0yNDQweiIvPgo8cGF0aCBkPSJNNjU2MCAzOTE1IGwwIC0yNjUgNjYwIDAgNjYwIDAgMCAyNjUgMCAyNjUgLTY2MCAwIC02NjAgMCAwIC0yNjV6Ii8+CjxwYXRoIGQ9Ik0xMTg4MCAxNjQwIGwwIC03MCA5NjUgMCA5NjUgMCA5IDIzIGM1IDEzIDEyIDQ1IDE2IDcwIGw3IDQ3IC05ODEgMAotOTgxIDAgMCAtNzB6Ii8+CjxwYXRoIGQ9Ik0xMjE2NyAxMzkzIGMtNCAtMyAtNyAtMzUgLTcgLTcwIGwwIC02MyA2ODUgMCA2ODQgMCAxMCAzOCBjNSAyMCAxMgo1MiAxNiA3MCBsNyAzMiAtNjk1IDAgYy0zODEgMCAtNjk3IC0zIC03MDAgLTd6Ii8+CjxwYXRoIGQ9Ik01NjAgODIwIGwwIC0yNjAgOTY4MCAwIDk2ODAgMCA1IDIzIGMxMyA1NSA5NSA0NzIgOTUgNDg0IDAgMTEKLTE3MDQgMTMgLTk3MzAgMTMgbC05NzMwIDAgMCAtMjYweiIvPgo8L2c+Cjwvc3ZnPgo=";

var img$2 = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDIwMDEwOTA0Ly9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy1TVkctMjAwMTA5MDQvRFREL3N2ZzEwLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4wIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiB3aWR0aD0iMjA2My4wMDAwMDBwdCIgaGVpZ2h0PSI4NTMuMDAwMDAwcHQiIHZpZXdCb3g9IjAgMCAyMDYzLjAwMDAwMCA4NTMuMDAwMDAwIgogcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCI+Cgo8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjAwMDAwMCw4NTMuMDAwMDAwKSBzY2FsZSgwLjEwMDAwMCwtMC4xMDAwMDApIgpmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiPgo8cGF0aCBkPSJNMTE1NjUgODE0MyBjLTQ2IC0yNCAtNjYgLTQ1IC04NiAtODggLTQ3IC0xMDMgMTEgLTIyNSAxMjIgLTI1NSAyMwotNiA1MyAtOSA2NyAtNiAyNiA2IDMzIC01IDI4NSAtNDcyIDE0MSAtMjYzIDI1NyAtNDgxIDI1NyAtNDg0IDAgLTMgLTIxIC0xOQotNDcgLTM0IC0yODUgLTE2NSAtNDc4IC00NjggLTUxMyAtODA1IC02IC02NiAtMTAgLTc5MCAtMTAgLTIxMDUgbDAgLTIwMDQKMTIwOSAwIDEyMDggMCAxMiA3MyBjOSA1NSAxMSA1NTcgOSAyMDk3IGwtNCAyMDI1IC0yMSA3NSBjLTYzIDIxNCAtMTUzIDM2MwotMzA4IDUwOCAtNDIgMzkgLTExMCA5MiAtMTUxIDExOCAtNDEgMjUgLTc0IDQ4IC03NCA1MSAwIDMgMTE2IDIyMSAyNTggNDg0CjI1MiA0NzAgMjU4IDQ3OSAyODQgNDc0IDQ0IC0xMCAxMDkgMTQgMTQ5IDU0IDEyMyAxMjMgMjggMzIzIC0xNDYgMzA5IC0xNDgKLTEyIC0yMTMgLTE3NyAtMTIxIC0zMDMgMTQgLTE5IC00IC01NSAtMjQ0IC01MDAgLTE0OCAtMjc1IC0yNjUgLTQ3OSAtMjcyCi00NzkgLTcgMSAtNTMgMTQgLTEwMyAyOCAtMTMzIDM5IC0yNTYgNDkgLTUzNSA0MyAtMjUxIC02IC0zMTEgLTE0IC00MzQgLTU3Ci0zMyAtMTEgLTYzIC0xNyAtNjYgLTEzIC03IDcgLTQ2NiA4NTUgLTUwNCA5MzAgLTE1IDMxIC0xNSAzMyA5IDY5IDYyIDkxIDM1CjIwNyAtNjAgMjYxIC00OCAyNyAtMTI1IDMwIC0xNzAgNnogbTEyNSAtNzggYzM3IC0xOSA1MCAtNDMgNTAgLTkzIDAgLTgwIC05NQotMTIwIC0xNTggLTY3IC01MyA0NCAtNDcgMTIwIDEyIDE1NiAzOCAyMyA1OCAyNCA5NiA0eiBtMjQ0MCAwIGM4OSAtNDYgNTQKLTE4NSAtNDcgLTE4NSAtOTAgMSAtMTM1IDEwOCAtNzAgMTY3IDM5IDM2IDczIDQxIDExNyAxOHogbS05OTAgLTE2NTUgYzE3MgotMzMgMzI1IC0xNjcgMzg5IC0zNDMgbDI2IC03MiAzIC01MTcgYzIgLTI4NSAyIC01MTggMCAtNTE4IC0yIDAgLTMwIDE0IC02MgozMCAtMTY4IDg1IC0zNDUgLTE2IC00MzIgLTI0NyAtMTMzIC0zNTAgLTMgLTgwNiAyNTAgLTg3NCA1OCAtMTYgMTM5IC01IDE5MwoyNSAyNSAxNCA0NyAyNiA0OSAyNiAyIDAgNCAtNDI3IDQgLTk1MCBsMCAtOTUwIC02OTUgMCAtNjk1IDAgMCA5NTUgMCA5NTQgMzYKLTI0IGMxMDYgLTcyIDIyNyAtNTcgMzMzIDQxIDY4IDYzIDExMCAxMzYgMTQ3IDI1OSAyMyA3OSAyNyAxMDggMjcgMjMwIDEgMTU4Ci0xMyAyMzIgLTY4IDM1MiAtMzggODIgLTExOCAxNzQgLTE4MCAyMDUgLTIyIDEyIC02NyAyMyAtMTAxIDI2IC02MSA0IC03NyAwCi0xODYgLTU2IC0xMiAtNiAtMTAgOTc3IDIgMTAzOSAzNiAxODggMTkxIDM1MiAzODIgNDAzIDY0IDE4IDQ5NSAyMiA1NzggNnoKbS03MzIgLTE1MzQgYzEwOSAtNTcgMTc2IC0yMjMgMTc2IC00MzYgMCAtMTc1IC0zNiAtMjk0IC0xMTUgLTM4NSAtMTI2IC0xNDMKLTI4OSAtMzYgLTM0NCAyMjYgLTcwIDMzMiAxMDEgNjkwIDI4MyA1OTV6IG0xMDMwIDAgYzE3MiAtOTEgMjM3IC00NzcgMTIyCi03MjUgLTY3IC0xNDIgLTE2MSAtMTk0IC0yNTIgLTEzOCAtMTY2IDEwMCAtMjIyIDQ4MiAtMTA3IDcyNSAzMSA2NCA4NSAxMjcKMTIzIDE0MiAzMyAxMyA4NCAxMiAxMTQgLTR6Ii8+CjxwYXRoIGQ9Ik0xMjQwMCAzMjQ1IGwtNDUgLTQ1IDIzOCAtMjM4IDIzNyAtMjM3IDIzMCAyMzAgMjMwIDIzMCAtMzYgNTQgLTM2CjU0IC0xOTQgLTE5NCAtMTk0IC0xOTQgLTE5MyAxOTMgLTE5MyAxOTIgLTQ0IC00NXoiLz4KPHBhdGggZD0iTTU2MiA0NDQzIGwzIC0yNDM4IDEwNTQgLTMgYzU4MCAtMSAxMDU5IDIgMTA2MyA2IDcgNyAxMDggNDg5IDEwOAo1MTQgMCA0IC0zODIgOCAtODUwIDggbC04NTAgMCAwIDgyMCAwIDgyMCA3MjQgMCBjNDQ4IDAgNzI3IDQgNzMxIDEwIDUgOCAxMDUKNDk0IDEwNSA1MTIgMCA0IC0zNTEgOCAtNzgwIDggbC03ODAgMCAwIDgyNSAwIDgyNSA3NjQgMCA3NjMgMCA1MiAyNTggYzI4CjE0MSA1MSAyNjAgNTEgMjY1IDAgNCAtNDg2IDcgLTEwODAgNyBsLTEwODAgMCAyIC0yNDM3eiIvPgo8cGF0aCBkPSJNMzQ1NCA2ODY3IGMtMiAtNyAtMyAtOTE1IC0xIC0yMDE3IDMgLTIyMzQgLTMgLTIwNDQgNzEgLTIyNDIgNTQKLTE0NCAxMTcgLTIzOSAyNDEgLTM2MyAxNTcgLTE1NyAzMTQgLTI0NCA1MjUgLTI5MCA5OCAtMjEgNDk0IC0zMiA2NDAgLTE3CjE5MCAyMCAzNTAgNzUgNDkzIDE2OCA4NiA1NyAyMzkgMjA3IDI4OSAyODUgODIgMTI1IDE0NiAyODUgMTY4IDQyMSA2IDQxIDEwCjc1MiAxMCAyMDY2IGwwIDIwMDIgLTI2MCAwIC0yNjAgMCAtMiAtMjAwMiAtMyAtMjAwMyAtMjMgLTU5IGMtNjcgLTE3NyAtMjAyCi0zMDAgLTM3MyAtMzQxIC05MSAtMjEgLTQ5NyAtMjEgLTU4OCAwIC0xODggNDUgLTM0MSAxOTggLTM4NiAzODcgLTEzIDU0IC0xNQozMzIgLTE1IDIwNDEgbDAgMTk3NyAtMjYwIDAgYy0yMDQgMCAtMjYyIC0zIC0yNjYgLTEzeiIvPgo8cGF0aCBkPSJNODU0NSA2ODY4IGMtMyAtNyAtNCAtMTEwNCAtMyAtMjQzOCBsMyAtMjQyNSAyNjAgMCAyNjAgMCAzIDEwMzMgMgoxMDMyIDQ2NSAwIGMzMDYgMCA0ODIgLTQgNTE3IC0xMSAxNzAgLTM2IDMxMiAtMTY2IDM3NyAtMzQzIGwyNiAtNzEgMyAtODIyIDMKLTgyMyAyNjAgMCAyNjAgMCAtMyA4NTMgYy0zIDg1MCAtMyA4NTIgLTI2IDkzMiAtNTAgMTc3IC0xNjYgMzY0IC0zMDUgNDg5CmwtNzEgNjUgMjkgMjIgYzUzIDM5IDE2MyAxNTcgMjA1IDIxOCA3OSAxMTcgMTM3IDI1NiAxNTkgMzg1IDcgMzYgMTEgMjQyIDExCjUxNyAwIDM2NiAtMyA0NzMgLTE1IDUzNiAtNDMgMjI3IC0xNDkgNDIwIC0zMTUgNTc3IC0xMzIgMTI0IC0yNzMgMjAxIC00NjkKMjU0IGwtOTYgMjYgLTc2OCA0IGMtNjIzIDIgLTc2OCAxIC03NzIgLTEweiBtMTUyMCAtNTMzIGMxNDYgLTM4IDI2NiAtMTM4CjMzNCAtMjc2IDU5IC0xMjEgNjMgLTE2NCA1OSAtNjMxIC00IC0zNTUgLTYgLTQxMCAtMjIgLTQ1OCAtNDkgLTE0OSAtMTQwCi0yNTYgLTI3NCAtMzIzIGwtODUgLTQyIC01MDQgLTMgLTUwMyAtMyAwIDg3NiAwIDg3NSA0NjggMCBjMzg4IDAgNDc4IC0zIDUyNwotMTV6Ii8+CjxwYXRoIGQ9Ik0xNDc1MCA2NjE1IGwwIC0yNjUgNDY1IDAgNDY1IDAgMiAtMjE3MiAzIC0yMTczIDI2MyAtMyAyNjIgLTIgMAoyMTc1IDAgMjE3NSA0MzUgMCBjMjM5IDAgNDM1IDEgNDM1IDMgMCAyIDIzIDExNSA1MCAyNTIgMjggMTM3IDUwIDI1NSA1MCAyNjIKMCAxMSAtMjIyIDEzIC0xMjE1IDEzIGwtMTIxNSAwIDAgLTI2NXoiLz4KPHBhdGggZD0iTTE3ODUwIDQ0NDAgbDAgLTI0NDAgMTA2MCAwIDEwNjAgMCA1IDIzIGMzIDEyIDI3IDEzMSA1NCAyNjQgbDQ4CjI0MyAtODUzIDAgLTg1NCAwIDAgODIwIDAgODIwIDczMCAwIDczMCAwIDUgMjMgYzMgMTIgMjcgMTMxIDU0IDI2NSBsNDggMjQyCi03ODMgMCAtNzg0IDAgMCA4MjUgMCA4MjUgNzY1IDAgNzY1IDAgNSAyMyBjMTYgNjggOTUgNDc0IDk1IDQ4OSAwIDE3IC00NCAxOAotMTA3NSAxOCBsLTEwNzUgMCAwIC0yNDQweiIvPgo8cGF0aCBkPSJNNjU2MCAzOTE1IGwwIC0yNjUgNjYwIDAgNjYwIDAgMCAyNjUgMCAyNjUgLTY2MCAwIC02NjAgMCAwIC0yNjV6Ii8+CjxwYXRoIGQ9Ik0xMTg4MCAxNjQwIGwwIC03MCA5NjUgMCA5NjUgMCA5IDIzIGM1IDEzIDEyIDQ1IDE2IDcwIGw3IDQ3IC05ODEgMAotOTgxIDAgMCAtNzB6Ii8+CjxwYXRoIGQ9Ik0xMjE2NyAxMzkzIGMtNCAtMyAtNyAtMzUgLTcgLTcwIGwwIC02MyA2ODUgMCA2ODQgMCAxMCAzOCBjNSAyMCAxMgo1MiAxNiA3MCBsNyAzMiAtNjk1IDAgYy0zODEgMCAtNjk3IC0zIC03MDAgLTd6Ii8+CjxwYXRoIGQ9Ik01NjAgODIwIGwwIC0yNjAgOTY4MCAwIDk2ODAgMCA1IDIzIGMxMyA1NSA5NSA0NzIgOTUgNDg0IDAgMTEKLTE3MDQgMTMgLTk3MzAgMTMgbC05NzMwIDAgMCAtMjYweiIvPgo8L2c+Cjwvc3ZnPgo=";

var img$1 = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDIwMDEwOTA0Ly9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy1TVkctMjAwMTA5MDQvRFREL3N2ZzEwLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4wIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiB3aWR0aD0iMjQyLjAwMDAwMHB0IiBoZWlnaHQ9IjEwMC4wMDAwMDBwdCIgdmlld0JveD0iMCAwIDI0Mi4wMDAwMDAgMTAwLjAwMDAwMCIKIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIG1lZXQiPgoKPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsMTAwLjAwMDAwMCkgc2NhbGUoMC4xMDAwMDAsLTAuMTAwMDAwKSIKZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIj4KPHBhdGggZD0iTTEzNTEgOTQ2IGMtOSAtMTEgLTggLTE3IDcgLTI4IDEwIC03IDMwIC0zNSA0NSAtNjIgbDI3IC00OCAtMzAgLTM1Ci0zMCAtMzQgMCAtMjU5IDAgLTI2MCAxNDAgMCAxNDAgMCAwIDI1MSBjMCAyNTcgLTIgMjcxIC00MiAzMTUgLTE5IDIyIC0xOSAyMgoxIDYzIDEyIDIyIDMxIDQ5IDQyIDYwIDEzIDEyIDE5IDI2IDE1IDM2IC04IDIyIC0zMSAxNCAtMzIgLTExIDAgLTEwIC0xMyAtNDMKLTI3IC03MSBsLTI3IC01MyAtNzAgMCAtNjkgMCAtMjcgNDYgYy0xNSAyNiAtMjkgNTYgLTMwIDY4IC0xIDEyIC0zIDI0IC0zIDI5Ci0yIDEyIC0xOCA4IC0zMCAtN3ogbTIzIC0xNyBjLTMgLTUgLTEwIC03IC0xNSAtMyAtNSAzIC03IDEwIC0zIDE1IDMgNSAxMCA3CjE1IDMgNSAtMyA3IC0xMCAzIC0xNXogbTI4NiA1IGMwIC04IC01IC0xMiAtMTAgLTkgLTYgNCAtOCAxMSAtNSAxNiA5IDE0IDE1CjExIDE1IC03eiBtLTg4IC0yMDEgYzI1IC0yMyAyNyAtMTU2IDIgLTE0NiAtMjQgOSAtNDQgLTIzIC00NCAtNjggMCAtNDAgMjQKLTc0IDQ2IC02NSAxMSA0IDE0IC0xNiAxNCAtMTA0IGwwIC0xMTAgLTgwIDAgLTgwIDAgMCAxMTEgYzAgNzUgMyAxMDggMTEgMTA0CjUgLTQgMTkgMSAzMCAxMSAzNiAzMiAxNiAxMjQgLTI4IDEyNCAtMjAgMCAtMTggMTE4IDQgMTQyIDIxIDI0IDk5IDI1IDEyNSAxegptLTEwMCAtMTg4IGMxMyAtMzAgLTMgLTc1IC0yNyAtNzUgLTE4IDAgLTI5IDQxIC0yMSA3NSA0IDE0IDEzIDI1IDIxIDI1IDkgMAoyMSAtMTEgMjcgLTI1eiBtMTIwIDAgYzEzIC0zMCAtMyAtNzUgLTI3IC03NSAtMTggMCAtMjkgNDEgLTIxIDc1IDQgMTQgMTMgMjUKMjEgMjUgOSAwIDIxIC0xMSAyNyAtMjV6Ii8+CjxwYXRoIGQ9Ik0xNDc1IDM1MCBsMjkgLTMwIDI4IDI3IGMxNSAxNCAyNiAyOSAyMyAzMSAtMyAzIC0xNiAtNCAtMjggLTE2CmwtMjQgLTIyIC0xOCAyMCBjLTEwIDExIC0yMyAyMCAtMjggMjAgLTYgMCAyIC0xNCAxOCAtMzB6Ii8+CjxwYXRoIGQ9Ik03MCA1MjAgbDAgLTI5MCAxMjAgMCBjMTI1IDAgMTI1IDAgMTMyIDQ1IDMgMTkgLTMgMjAgLTk0IDIzIGwtOTggMwowIDk0IDAgOTUgODQgMCBjNzggMCA4NCAxIDkwIDIzIDMgMTIgNiAyNSA2IDMwIDAgNCAtNDAgNyAtOTAgNyBsLTkwIDAgMCA5NQowIDk1IDg1IDAgYzgzIDAgODYgMSA5NSAyNiA2IDE0IDEwIDMwIDEwIDM1IDAgNSAtNTQgOSAtMTI1IDkgbC0xMjUgMCAwIC0yOTB6Ii8+CjxwYXRoIGQ9Ik00MTAgNTU1IGwwIC0yNTcgMzQgLTM0IGMzMSAtMzEgMzkgLTM0IDk1IC0zNCAzNiAwIDc0IDYgOTEgMTUgNTYKMjkgNjAgNDkgNjAgMzIwIGwwIDI0NSAtMzAgMCAtMzAgMCAwIC0yMzggYzAgLTI3OSAtMSAtMjgyIC03OSAtMjgyIC04MCAwCi04MCAtMSAtODMgMjc2IGwtMyAyMzkgLTI3IDMgLTI4IDMgMCAtMjU2eiIvPgo8cGF0aCBkPSJNMTAwMiA1MjMgbDMgLTI4OCAyNyAtMyAyNyAtMyAzIDEyMyAzIDEyMyA1NyAzIGM1MSAzIDYxIDAgODMgLTIyCjIzIC0yMyAyNSAtMzIgMjUgLTEyNiBsMCAtMTAxIDI4IDMgMjcgMyAwIDExMSBjMCA5NiAtMyAxMTUgLTE5IDEzMyAtMTkgMjEKLTE5IDIyIDMgNjIgMjAgMzQgMjMgNTIgMTkgMTE0IC02IDEyNCAtNDQgMTUzIC0yMDEgMTU0IGwtODcgMSAyIC0yODd6IG0yMDkKMjAwIGM5IC0xMCAxNCAtNDEgMTQgLTg1IDAgLTg3IC0xMiAtOTggLTEwMiAtOTggbC02MyAwIDAgMTAwIDAgMTAwIDY5IDAgYzUyCjAgNzIgLTQgODIgLTE3eiIvPgo8cGF0aCBkPSJNMTczMCA3NzUgbDAgLTM1IDU1IDAgNTUgMCAyIC0yNTIgMyAtMjUzIDI4IC0zIDI3IC0zIDAgMjU1IDAgMjU1CjUzIDMgYzUxIDMgNTIgNCA1NSAzNiBsMyAzMiAtMTQwIDAgLTE0MSAwIDAgLTM1eiIvPgo8cGF0aCBkPSJNMjA5NSA3OTcgYy0zIC03IC00IC0xMzYgLTMgLTI4NyBsMyAtMjc1IDExOSAtMyBjMTI3IC0zIDEzNiAwIDEzNgo0NiAwIDIxIC0zIDIyIC05NSAyMiBsLTk1IDAgMCA5NSAwIDk1IDg1IDAgYzY3IDAgODUgMyA4NSAxNCAwIDggMyAyMSA2IDMwIDUKMTQgLTYgMTYgLTg1IDE2IGwtOTEgMCAwIDk1IDAgOTQgODggMyA4NyAzIDMgMzMgMyAzMiAtMTIxIDAgYy04OCAwIC0xMjIgLTMKLTEyNSAtMTN6Ii8+CjxwYXRoIGQ9Ik03NzAgNDYwIGwwIC0zMCA3NSAwIDc1IDAgMCAzMCAwIDMwIC03NSAwIC03NSAwIDAgLTMweiIvPgo8cGF0aCBkPSJNMTM5NSAxOTAgYzQgLTYgNTMgLTEwIDExNiAtMTAgNjYgMCAxMDkgNCAxMDkgMTAgMCA2IC00NSAxMCAtMTE2CjEwIC03NCAwIC0xMTMgLTQgLTEwOSAtMTB6Ii8+CjxwYXRoIGQ9Ik0xNDY4IDE1MyBjMjMgLTIgNjEgLTIgODUgMCAyMyAyIDQgNCAtNDMgNCAtNDcgMCAtNjYgLTIgLTQyIC00eiIvPgo8cGF0aCBkPSJNNzAgMTAwIGwwIC0zMCAxMTM1IDAgYzk3MyAwIDExMzUgMiAxMTM1IDE0IDAgOCAzIDIxIDYgMzAgNiAxNSAtOTkKMTYgLTExMzUgMTYgbC0xMTQxIDAgMCAtMzB6Ii8+CjwvZz4KPC9zdmc+Cg==";

var en = {
	"mbitMore.entry.name": "Boson",
	"mbitMore.entry.description": "Play with all functions of micro:bit."
};
var ja$1 = {
	"mbitMore.entry.name": "Boson",
	"mbitMore.entry.description": "micro:bit"
};
var translations$1 = {
	en: en,
	ja: ja$1,
	"ja-Hira": {
	"mbitMore.entry.name": "Boson",
	"mbitMore.entry.description": ""
}
};

var formatMessage$1 = function formatMessage(messageData) {
  return messageData.defaultMessage;
};
var version = 'v2-0.2.5';
var entry = {
  get name() {
    return "".concat(formatMessage$1({
      defaultMessage: 'Boson',
      description: 'Name of this extension',
      id: 'mbitMore.entry.name'
    }), " (").concat(version, ")");
  },

  extensionId: 'microbitMore',
  extensionURL: 'https://eu-rate-boson.github.io/dist/microbitMore.mjs',
  collaborator: 'Scuola di Robotica',
  iconURL: img$4,
  insetIconURL: img$3,

  get description() {
    return formatMessage$1({
      defaultMessage: 'Play with all functions of micro:bit.',
      description: "Description for the 'Boson' extension",
      id: 'mbitMore.entry.description'
    });
  },

  featured: true,
  disabled: false,
  bluetoothRequired: true,
  internetConnectionRequired: false,
  launchPeripheralConnectionFlow: true,
  useAutoScan: false,
  connectionIconURL: img$2,
  connectionSmallIconURL: img$1,

  get connectingMessage() {
    return formatMessage$1({
      defaultMessage: 'Connecting',
      description: 'Message to help people connect to their micro:bit.',
      id: 'gui.extension.microbit.connectingMessage'
    });
  },

  helpLink: 'https://eu-rate-boson.github.io/',
  setFormatMessage: function setFormatMessage(formatter) {
    formatMessage$1 = formatter;
  },
  translationMap: translations$1
};

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

/**
 * Block argument types
 * @enum {string}
 */
var ArgumentType = {
  /**
   * Numeric value with angle picker
   */
  ANGLE: 'angle',

  /**
   * Boolean value with hexagonal placeholder
   */
  BOOLEAN: 'Boolean',

  /**
   * Numeric value with color picker
   */
  COLOR: 'color',

  /**
   * Numeric value with text field
   */
  NUMBER: 'number',

  /**
   * String value with text field
   */
  STRING: 'string',

  /**
   * String value with matrix field
   */
  MATRIX: 'matrix',

  /**
   * MIDI note number with note picker (piano) field
   */
  NOTE: 'note',

  /**
   * Inline image on block (as part of the label)
   */
  IMAGE: 'image'
};
var argumentType = ArgumentType;

/**
 * Types of block
 * @enum {string}
 */
var BlockType = {
  /**
   * Boolean reporter with hexagonal shape
   */
  BOOLEAN: 'Boolean',

  /**
   * A button (not an actual block) for some special action, like making a variable
   */
  BUTTON: 'button',

  /**
   * Command block
   */
  COMMAND: 'command',

  /**
   * Specialized command block which may or may not run a child branch
   * The thread continues with the next block whether or not a child branch ran.
   */
  CONDITIONAL: 'conditional',

  /**
   * Specialized hat block with no implementation function
   * This stack only runs if the corresponding event is emitted by other code.
   */
  EVENT: 'event',

  /**
   * Hat block which conditionally starts a block stack
   */
  HAT: 'hat',

  /**
   * Specialized command block which may or may not run a child branch
   * If a child branch runs, the thread evaluates the loop block again.
   */
  LOOP: 'loop',

  /**
   * General reporter with numeric or string value
   */
  REPORTER: 'reporter'
};
var blockType = BlockType;

var Color$1 = /*#__PURE__*/function () {
  function Color() {
    _classCallCheck(this, Color);
  }

  _createClass(Color, null, [{
    key: "RGB_BLACK",
    get:
    /**
     * @typedef {object} RGBObject - An object representing a color in RGB format.
     * @property {number} r - the red component, in the range [0, 255].
     * @property {number} g - the green component, in the range [0, 255].
     * @property {number} b - the blue component, in the range [0, 255].
     */

    /**
     * @typedef {object} HSVObject - An object representing a color in HSV format.
     * @property {number} h - hue, in the range [0-359).
     * @property {number} s - saturation, in the range [0,1].
     * @property {number} v - value, in the range [0,1].
     */

    /** @type {RGBObject} */
    function get() {
      return {
        r: 0,
        g: 0,
        b: 0
      };
    }
    /** @type {RGBObject} */

  }, {
    key: "RGB_WHITE",
    get: function get() {
      return {
        r: 255,
        g: 255,
        b: 255
      };
    }
    /**
     * Convert a Scratch decimal color to a hex string, #RRGGBB.
     * @param {number} decimal RGB color as a decimal.
     * @return {string} RGB color as #RRGGBB hex string.
     */

  }, {
    key: "decimalToHex",
    value: function decimalToHex(decimal) {
      if (decimal < 0) {
        decimal += 0xFFFFFF + 1;
      }

      var hex = Number(decimal).toString(16);
      hex = "#".concat('000000'.substr(0, 6 - hex.length)).concat(hex);
      return hex;
    }
    /**
     * Convert a Scratch decimal color to an RGB color object.
     * @param {number} decimal RGB color as decimal.
     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */

  }, {
    key: "decimalToRgb",
    value: function decimalToRgb(decimal) {
      var a = decimal >> 24 & 0xFF;
      var r = decimal >> 16 & 0xFF;
      var g = decimal >> 8 & 0xFF;
      var b = decimal & 0xFF;
      return {
        r: r,
        g: g,
        b: b,
        a: a > 0 ? a : 255
      };
    }
    /**
     * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.
     * CC-BY-SA Tim Down:
     * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
     * @param {!string} hex Hex representation of the color.
     * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */

  }, {
    key: "hexToRgb",
    value: function hexToRgb(hex) {
      var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      hex = hex.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
      });
      var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }
    /**
     * Convert an RGB color object to a hex color.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {!string} Hex representation of the color.
     */

  }, {
    key: "rgbToHex",
    value: function rgbToHex(rgb) {
      return Color.decimalToHex(Color.rgbToDecimal(rgb));
    }
    /**
     * Convert an RGB color object to a Scratch decimal color.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {!number} Number representing the color.
     */

  }, {
    key: "rgbToDecimal",
    value: function rgbToDecimal(rgb) {
      return (rgb.r << 16) + (rgb.g << 8) + rgb.b;
    }
    /**
    * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.
    * @param {!string} hex Hex representation of the color.
    * @return {!number} Number representing the color.
    */

  }, {
    key: "hexToDecimal",
    value: function hexToDecimal(hex) {
      return Color.rgbToDecimal(Color.hexToRgb(hex));
    }
    /**
     * Convert an HSV color to RGB format.
     * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */

  }, {
    key: "hsvToRgb",
    value: function hsvToRgb(hsv) {
      var h = hsv.h % 360;
      if (h < 0) h += 360;
      var s = Math.max(0, Math.min(hsv.s, 1));
      var v = Math.max(0, Math.min(hsv.v, 1));
      var i = Math.floor(h / 60);
      var f = h / 60 - i;
      var p = v * (1 - s);
      var q = v * (1 - s * f);
      var t = v * (1 - s * (1 - f));
      var r;
      var g;
      var b;

      switch (i) {
        default:
        case 0:
          r = v;
          g = t;
          b = p;
          break;

        case 1:
          r = q;
          g = v;
          b = p;
          break;

        case 2:
          r = p;
          g = v;
          b = t;
          break;

        case 3:
          r = p;
          g = q;
          b = v;
          break;

        case 4:
          r = t;
          g = p;
          b = v;
          break;

        case 5:
          r = v;
          g = p;
          b = q;
          break;
      }

      return {
        r: Math.floor(r * 255),
        g: Math.floor(g * 255),
        b: Math.floor(b * 255)
      };
    }
    /**
     * Convert an RGB color to HSV format.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
     */

  }, {
    key: "rgbToHsv",
    value: function rgbToHsv(rgb) {
      var r = rgb.r / 255;
      var g = rgb.g / 255;
      var b = rgb.b / 255;
      var x = Math.min(Math.min(r, g), b);
      var v = Math.max(Math.max(r, g), b); // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate

      var h = 0;
      var s = 0;

      if (x !== v) {
        var f = r === x ? g - b : g === x ? b - r : r - g;
        var i = r === x ? 3 : g === x ? 5 : 1;
        h = (i - f / (v - x)) * 60 % 360;
        s = (v - x) / v;
      }

      return {
        h: h,
        s: s,
        v: v
      };
    }
    /**
     * Linear interpolation between rgb0 and rgb1.
     * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.
     * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.
     * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.
     * @return {RGBObject} the interpolated color.
     */

  }, {
    key: "mixRgb",
    value: function mixRgb(rgb0, rgb1, fraction1) {
      if (fraction1 <= 0) return rgb0;
      if (fraction1 >= 1) return rgb1;
      var fraction0 = 1 - fraction1;
      return {
        r: fraction0 * rgb0.r + fraction1 * rgb1.r,
        g: fraction0 * rgb0.g + fraction1 * rgb1.g,
        b: fraction0 * rgb0.b + fraction1 * rgb1.b
      };
    }
  }]);

  return Color;
}();

var color$3 = Color$1;

var Color = color$3;
/**
 * @fileoverview
 * Utilities for casting and comparing Scratch data-types.
 * Scratch behaves slightly differently from JavaScript in many respects,
 * and these differences should be encapsulated below.
 * For example, in Scratch, add(1, join("hello", world")) -> 1.
 * This is because "hello world" is cast to 0.
 * In JavaScript, 1 + Number("hello" + "world") would give you NaN.
 * Use when coercing a value before computation.
 */

var Cast = /*#__PURE__*/function () {
  function Cast() {
    _classCallCheck(this, Cast);
  }

  _createClass(Cast, null, [{
    key: "toNumber",
    value:
    /**
     * Scratch cast to number.
     * Treats NaN as 0.
     * In Scratch 2.0, this is captured by `interp.numArg.`
     * @param {*} value Value to cast to number.
     * @return {number} The Scratch-casted number value.
     */
    function toNumber(value) {
      // If value is already a number we don't need to coerce it with
      // Number().
      if (typeof value === 'number') {
        // Scratch treats NaN as 0, when needed as a number.
        // E.g., 0 + NaN -> 0.
        if (Number.isNaN(value)) {
          return 0;
        }

        return value;
      }

      var n = Number(value);

      if (Number.isNaN(n)) {
        // Scratch treats NaN as 0, when needed as a number.
        // E.g., 0 + NaN -> 0.
        return 0;
      }

      return n;
    }
    /**
     * Scratch cast to boolean.
     * In Scratch 2.0, this is captured by `interp.boolArg.`
     * Treats some string values differently from JavaScript.
     * @param {*} value Value to cast to boolean.
     * @return {boolean} The Scratch-casted boolean value.
     */

  }, {
    key: "toBoolean",
    value: function toBoolean(value) {
      // Already a boolean?
      if (typeof value === 'boolean') {
        return value;
      }

      if (typeof value === 'string') {
        // These specific strings are treated as false in Scratch.
        if (value === '' || value === '0' || value.toLowerCase() === 'false') {
          return false;
        } // All other strings treated as true.


        return true;
      } // Coerce other values and numbers.


      return Boolean(value);
    }
    /**
     * Scratch cast to string.
     * @param {*} value Value to cast to string.
     * @return {string} The Scratch-casted string value.
     */

  }, {
    key: "toString",
    value: function toString(value) {
      return String(value);
    }
    /**
     * Cast any Scratch argument to an RGB color array to be used for the renderer.
     * @param {*} value Value to convert to RGB color array.
     * @return {Array.<number>} [r,g,b], values between 0-255.
     */

  }, {
    key: "toRgbColorList",
    value: function toRgbColorList(value) {
      var color = Cast.toRgbColorObject(value);
      return [color.r, color.g, color.b];
    }
    /**
     * Cast any Scratch argument to an RGB color object to be used for the renderer.
     * @param {*} value Value to convert to RGB color object.
     * @return {RGBOject} [r,g,b], values between 0-255.
     */

  }, {
    key: "toRgbColorObject",
    value: function toRgbColorObject(value) {
      var color;

      if (typeof value === 'string' && value.substring(0, 1) === '#') {
        color = Color.hexToRgb(value); // If the color wasn't *actually* a hex color, cast to black

        if (!color) color = {
          r: 0,
          g: 0,
          b: 0,
          a: 255
        };
      } else {
        color = Color.decimalToRgb(Cast.toNumber(value));
      }

      return color;
    }
    /**
     * Determine if a Scratch argument is a white space string (or null / empty).
     * @param {*} val value to check.
     * @return {boolean} True if the argument is all white spaces or null / empty.
     */

  }, {
    key: "isWhiteSpace",
    value: function isWhiteSpace(val) {
      return val === null || typeof val === 'string' && val.trim().length === 0;
    }
    /**
     * Compare two values, using Scratch cast, case-insensitive string compare, etc.
     * In Scratch 2.0, this is captured by `interp.compare.`
     * @param {*} v1 First value to compare.
     * @param {*} v2 Second value to compare.
     * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.
     */

  }, {
    key: "compare",
    value: function compare(v1, v2) {
      var n1 = Number(v1);
      var n2 = Number(v2);

      if (n1 === 0 && Cast.isWhiteSpace(v1)) {
        n1 = NaN;
      } else if (n2 === 0 && Cast.isWhiteSpace(v2)) {
        n2 = NaN;
      }

      if (isNaN(n1) || isNaN(n2)) {
        // At least one argument can't be converted to a number.
        // Scratch compares strings as case insensitive.
        var s1 = String(v1).toLowerCase();
        var s2 = String(v2).toLowerCase();

        if (s1 < s2) {
          return -1;
        } else if (s1 > s2) {
          return 1;
        }

        return 0;
      } // Handle the special case of Infinity


      if (n1 === Infinity && n2 === Infinity || n1 === -Infinity && n2 === -Infinity) {
        return 0;
      } // Compare as numbers.


      return n1 - n2;
    }
    /**
     * Determine if a Scratch argument number represents a round integer.
     * @param {*} val Value to check.
     * @return {boolean} True if number looks like an integer.
     */

  }, {
    key: "isInt",
    value: function isInt(val) {
      // Values that are already numbers.
      if (typeof val === 'number') {
        if (isNaN(val)) {
          // NaN is considered an integer.
          return true;
        } // True if it's "round" (e.g., 2.0 and 2).


        return val === parseInt(val, 10);
      } else if (typeof val === 'boolean') {
        // `True` and `false` always represent integer after Scratch cast.
        return true;
      } else if (typeof val === 'string') {
        // If it contains a decimal point, don't consider it an int.
        return val.indexOf('.') < 0;
      }

      return false;
    }
  }, {
    key: "LIST_INVALID",
    get: function get() {
      return 'INVALID';
    }
  }, {
    key: "LIST_ALL",
    get: function get() {
      return 'ALL';
    }
    /**
     * Compute a 1-based index into a list, based on a Scratch argument.
     * Two special cases may be returned:
     * LIST_ALL: if the block is referring to all of the items in the list.
     * LIST_INVALID: if the index was invalid in any way.
     * @param {*} index Scratch arg, including 1-based numbers or special cases.
     * @param {number} length Length of the list.
     * @param {boolean} acceptAll Whether it should accept "all" or not.
     * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.
     */

  }, {
    key: "toListIndex",
    value: function toListIndex(index, length, acceptAll) {
      if (typeof index !== 'number') {
        if (index === 'all') {
          return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;
        }

        if (index === 'last') {
          if (length > 0) {
            return length;
          }

          return Cast.LIST_INVALID;
        } else if (index === 'random' || index === 'any') {
          if (length > 0) {
            return 1 + Math.floor(Math.random() * length);
          }

          return Cast.LIST_INVALID;
        }
      }

      index = Math.floor(Cast.toNumber(index));

      if (index < 1 || index > length) {
        return Cast.LIST_INVALID;
      }

      return index;
    }
  }]);

  return Cast;
}();

var cast = Cast;

var web = {exports: {}};

var minilog$2 = {exports: {}};

function M() {
  this._events = {};
}

M.prototype = {
  on: function on(ev, cb) {
    this._events || (this._events = {});
    var e = this._events;
    (e[ev] || (e[ev] = [])).push(cb);
    return this;
  },
  removeListener: function removeListener(ev, cb) {
    var e = this._events[ev] || [],
        i;

    for (i = e.length - 1; i >= 0 && e[i]; i--) {
      if (e[i] === cb || e[i].cb === cb) {
        e.splice(i, 1);
      }
    }
  },
  removeAllListeners: function removeAllListeners(ev) {
    if (!ev) {
      this._events = {};
    } else {
      this._events[ev] && (this._events[ev] = []);
    }
  },
  listeners: function listeners(ev) {
    return this._events ? this._events[ev] || [] : [];
  },
  emit: function emit(ev) {
    this._events || (this._events = {});
    var args = Array.prototype.slice.call(arguments, 1),
        i,
        e = this._events[ev] || [];

    for (i = e.length - 1; i >= 0 && e[i]; i--) {
      e[i].apply(this, args);
    }

    return this;
  },
  when: function when(ev, cb) {
    return this.once(ev, cb, true);
  },
  once: function once(ev, cb, when) {
    if (!cb) return this;

    function c() {
      if (!when) this.removeListener(ev, c);
      if (cb.apply(this, arguments) && when) this.removeListener(ev, c);
    }

    c.cb = cb;
    this.on(ev, c);
    return this;
  }
};

M.mixin = function (dest) {
  var o = M.prototype,
      k;

  for (k in o) {
    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);
  }
};

var microee$1 = M;

var microee = microee$1; // Implements a subset of Node's stream.Transform - in a cross-platform manner.

function Transform$7() {}

microee.mixin(Transform$7); // The write() signature is different from Node's
// --> makes it much easier to work with objects in logs.
// One of the lessons from v1 was that it's better to target
// a good browser rather than the lowest common denominator
// internally.
// If you want to use external streams, pipe() to ./stringify.js first.

Transform$7.prototype.write = function (name, level, args) {
  this.emit('item', name, level, args);
};

Transform$7.prototype.end = function () {
  this.emit('end');
  this.removeAllListeners();
};

Transform$7.prototype.pipe = function (dest) {
  var s = this; // prevent double piping

  s.emit('unpipe', dest); // tell the dest that it's being piped to

  dest.emit('pipe', s);

  function onItem() {
    dest.write.apply(dest, Array.prototype.slice.call(arguments));
  }

  function onEnd() {
    !dest._isStdio && dest.end();
  }

  s.on('item', onItem);
  s.on('end', onEnd);
  s.when('unpipe', function (from) {
    var match = from === dest || typeof from == 'undefined';

    if (match) {
      s.removeListener('item', onItem);
      s.removeListener('end', onEnd);
      dest.emit('unpipe');
    }

    return match;
  });
  return dest;
};

Transform$7.prototype.unpipe = function (from) {
  this.emit('unpipe', from);
  return this;
};

Transform$7.prototype.format = function (dest) {
  throw new Error(['Warning: .format() is deprecated in Minilog v2! Use .pipe() instead. For example:', 'var Minilog = require(\'minilog\');', 'Minilog', '  .pipe(Minilog.backends.console.formatClean)', '  .pipe(Minilog.backends.console);'].join('\n'));
};

Transform$7.mixin = function (dest) {
  var o = Transform$7.prototype,
      k;

  for (k in o) {
    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);
  }
};

var transform = Transform$7;

var Transform$6 = transform;
var levelMap = {
  debug: 1,
  info: 2,
  warn: 3,
  error: 4
};

function Filter() {
  this.enabled = true;
  this.defaultResult = true;
  this.clear();
}

Transform$6.mixin(Filter); // allow all matching, with level >= given level

Filter.prototype.allow = function (name, level) {
  this._white.push({
    n: name,
    l: levelMap[level]
  });

  return this;
}; // deny all matching, with level <= given level


Filter.prototype.deny = function (name, level) {
  this._black.push({
    n: name,
    l: levelMap[level]
  });

  return this;
};

Filter.prototype.clear = function () {
  this._white = [];
  this._black = [];
  return this;
};

function test(rule, name) {
  // use .test for RegExps
  return rule.n.test ? rule.n.test(name) : rule.n == name;
}

Filter.prototype.test = function (name, level) {
  var i,
      len = Math.max(this._white.length, this._black.length);

  for (i = 0; i < len; i++) {
    if (this._white[i] && test(this._white[i], name) && levelMap[level] >= this._white[i].l) {
      return true;
    }

    if (this._black[i] && test(this._black[i], name) && levelMap[level] <= this._black[i].l) {
      return false;
    }
  }

  return this.defaultResult;
};

Filter.prototype.write = function (name, level, args) {
  if (!this.enabled || this.test(name, level)) {
    return this.emit('item', name, level, args);
  }
};

var filter = Filter;

(function (module, exports) {
  var Transform = transform,
      Filter = filter;
  var log = new Transform(),
      slice = Array.prototype.slice;

  exports = module.exports = function create(name) {
    var o = function o() {
      log.write(name, undefined, slice.call(arguments));
      return o;
    };

    o.debug = function () {
      log.write(name, 'debug', slice.call(arguments));
      return o;
    };

    o.info = function () {
      log.write(name, 'info', slice.call(arguments));
      return o;
    };

    o.warn = function () {
      log.write(name, 'warn', slice.call(arguments));
      return o;
    };

    o.error = function () {
      log.write(name, 'error', slice.call(arguments));
      return o;
    };

    o.log = o.debug; // for interface compliance with Node and browser consoles

    o.suggest = exports.suggest;
    o.format = log.format;
    return o;
  }; // filled in separately


  exports.defaultBackend = exports.defaultFormatter = null;

  exports.pipe = function (dest) {
    return log.pipe(dest);
  };

  exports.end = exports.unpipe = exports.disable = function (from) {
    return log.unpipe(from);
  };

  exports.Transform = Transform;
  exports.Filter = Filter; // this is the default filter that's applied when .enable() is called normally
  // you can bypass it completely and set up your own pipes

  exports.suggest = new Filter();

  exports.enable = function () {
    if (exports.defaultFormatter) {
      return log.pipe(exports.suggest) // filter
      .pipe(exports.defaultFormatter) // formatter
      .pipe(exports.defaultBackend); // backend
    }

    return log.pipe(exports.suggest) // filter
    .pipe(exports.defaultBackend); // formatter
  };
})(minilog$2, minilog$2.exports);

var hex = {
  black: '#000',
  red: '#c23621',
  green: '#25bc26',
  yellow: '#bbbb00',
  blue: '#492ee1',
  magenta: '#d338d3',
  cyan: '#33bbc8',
  gray: '#808080',
  purple: '#708'
};

function color$2(fg, isInverse) {
  if (isInverse) {
    return 'color: #fff; background: ' + hex[fg] + ';';
  } else {
    return 'color: ' + hex[fg] + ';';
  }
}

var util = color$2;

var Transform$5 = transform,
    color$1 = util;
var colors$1 = {
  debug: ['cyan'],
  info: ['purple'],
  warn: ['yellow', true],
  error: ['red', true]
},
    logger$4 = new Transform$5();

logger$4.write = function (name, level, args) {
  var fn = console.log;

  if (console[level] && console[level].apply) {
    fn = console[level];
    fn.apply(console, ['%c' + name + ' %c' + level, color$1('gray'), color$1.apply(color$1, colors$1[level])].concat(args));
  }
}; // NOP, because piping the formatted logs can only cause trouble.


logger$4.pipe = function () {};

var color_1 = logger$4;

var Transform$4 = transform,
    color = util,
    colors = {
  debug: ['gray'],
  info: ['purple'],
  warn: ['yellow', true],
  error: ['red', true]
},
    logger$3 = new Transform$4();

logger$3.write = function (name, level, args) {
  var fn = console.log;

  if (level != 'debug' && console[level]) {
    fn = console[level];
  }

  var i = 0;

  if (level != 'info') {
    for (; i < args.length; i++) {
      if (typeof args[i] != 'string') break;
    }

    fn.apply(console, ['%c' + name + ' ' + args.slice(0, i).join(' '), color.apply(color, colors[level])].concat(args.slice(i)));
  } else {
    fn.apply(console, ['%c' + name, color.apply(color, colors[level])].concat(args));
  }
}; // NOP, because piping the formatted logs can only cause trouble.


logger$3.pipe = function () {};

var minilog$1 = logger$3;

var Transform$3 = transform;
var newlines = /\n+$/,
    logger$2 = new Transform$3();

logger$2.write = function (name, level, args) {
  var i = args.length - 1;

  if (typeof console === 'undefined' || !console.log) {
    return;
  }

  if (console.log.apply) {
    return console.log.apply(console, [name, level].concat(args));
  } else if (JSON && JSON.stringify) {
    // console.log.apply is undefined in IE8 and IE9
    // for IE8/9: make console.log at least a bit less awful
    if (args[i] && typeof args[i] == 'string') {
      args[i] = args[i].replace(newlines, '');
    }

    try {
      for (i = 0; i < args.length; i++) {
        args[i] = JSON.stringify(args[i]);
      }
    } catch (e) {}

    console.log(args.join(' '));
  }
};

logger$2.formatters = ['color', 'minilog'];
logger$2.color = color_1;
logger$2.minilog = minilog$1;
var console_1 = logger$2;

var Transform$2 = transform,
    cache$1 = [];
var logger$1 = new Transform$2();

logger$1.write = function (name, level, args) {
  cache$1.push([name, level, args]);
}; // utility functions


logger$1.get = function () {
  return cache$1;
};

logger$1.empty = function () {
  cache$1 = [];
};

var array = logger$1;

var Transform$1 = transform,
    cache = false;
var logger = new Transform$1();

logger.write = function (name, level, args) {
  if (typeof window == 'undefined' || typeof JSON == 'undefined' || !JSON.stringify || !JSON.parse) return;

  try {
    if (!cache) {
      cache = window.localStorage.minilog ? JSON.parse(window.localStorage.minilog) : [];
    }

    cache.push([new Date().toString(), name, level, args]);
    window.localStorage.minilog = JSON.stringify(cache);
  } catch (e) {}
};

var localstorage = logger;

var Transform = transform;
var cid = new Date().valueOf().toString(36);

function AjaxLogger(options) {
  this.url = options.url || '';
  this.cache = [];
  this.timer = null;
  this.interval = options.interval || 30 * 1000;
  this.enabled = true;
  this.jQuery = window.jQuery;
  this.extras = {};
}

Transform.mixin(AjaxLogger);

AjaxLogger.prototype.write = function (name, level, args) {
  if (!this.timer) {
    this.init();
  }

  this.cache.push([name, level].concat(args));
};

AjaxLogger.prototype.init = function () {
  if (!this.enabled || !this.jQuery) return;
  var self = this;
  this.timer = setTimeout(function () {
    var i,
        logs = [],
        ajaxData,
        url = self.url;
    if (self.cache.length == 0) return self.init(); // Test each log line and only log the ones that are valid (e.g. don't have circular references).
    // Slight performance hit but benefit is we log all valid lines.

    for (i = 0; i < self.cache.length; i++) {
      try {
        JSON.stringify(self.cache[i]);
        logs.push(self.cache[i]);
      } catch (e) {}
    }

    if (self.jQuery.isEmptyObject(self.extras)) {
      ajaxData = JSON.stringify({
        logs: logs
      });
      url = self.url + '?client_id=' + cid;
    } else {
      ajaxData = JSON.stringify(self.jQuery.extend({
        logs: logs
      }, self.extras));
    }

    self.jQuery.ajax(url, {
      type: 'POST',
      cache: false,
      processData: false,
      data: ajaxData,
      contentType: 'application/json',
      timeout: 10000
    }).success(function (data, status, jqxhr) {
      if (data.interval) {
        self.interval = Math.max(1000, data.interval);
      }
    }).error(function () {
      self.interval = 30000;
    }).always(function () {
      self.init();
    });
    self.cache = [];
  }, this.interval);
};

AjaxLogger.prototype.end = function () {}; // wait until jQuery is defined. Useful if you don't control the load order.


AjaxLogger.jQueryWait = function (onDone) {
  if (typeof window !== 'undefined' && (window.jQuery || window.$)) {
    return onDone(window.jQuery || window.$);
  } else if (typeof window !== 'undefined') {
    setTimeout(function () {
      AjaxLogger.jQueryWait(onDone);
    }, 200);
  }
};

var jquery_simple = AjaxLogger;

(function (module, exports) {
  var Minilog = minilog$2.exports;
  var oldEnable = Minilog.enable,
      oldDisable = Minilog.disable,
      isChrome = typeof navigator != 'undefined' && /chrome/i.test(navigator.userAgent),
      console = console_1; // Use a more capable logging backend if on Chrome

  Minilog.defaultBackend = isChrome ? console.minilog : console; // apply enable inputs from localStorage and from the URL

  if (typeof window != 'undefined') {
    try {
      Minilog.enable(JSON.parse(window.localStorage['minilogSettings']));
    } catch (e) {}

    if (window.location && window.location.search) {
      var match = RegExp('[?&]minilog=([^&]*)').exec(window.location.search);
      match && Minilog.enable(decodeURIComponent(match[1]));
    }
  } // Make enable also add to localStorage


  Minilog.enable = function () {
    oldEnable.call(Minilog, true);

    try {
      window.localStorage['minilogSettings'] = JSON.stringify(true);
    } catch (e) {}

    return this;
  };

  Minilog.disable = function () {
    oldDisable.call(Minilog);

    try {
      delete window.localStorage.minilogSettings;
    } catch (e) {}

    return this;
  };

  exports = module.exports = Minilog;
  exports.backends = {
    array: array,
    browser: Minilog.defaultBackend,
    localStorage: localstorage,
    jQuery: jquery_simple
  };
})(web, web.exports);

var minilog = web.exports;
minilog.enable();
var log$2 = minilog('vm');

var img = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDIwMDEwOTA0Ly9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy1TVkctMjAwMTA5MDQvRFREL3N2ZzEwLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4wIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiB3aWR0aD0iMjA2My4wMDAwMDBwdCIgaGVpZ2h0PSI4NTMuMDAwMDAwcHQiIHZpZXdCb3g9IjAgMCAyMDYzLjAwMDAwMCA4NTMuMDAwMDAwIgogcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCI+Cgo8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjAwMDAwMCw4NTMuMDAwMDAwKSBzY2FsZSgwLjEwMDAwMCwtMC4xMDAwMDApIgpmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiPgo8cGF0aCBkPSJNMTE1NjUgODE0MyBjLTQ2IC0yNCAtNjYgLTQ1IC04NiAtODggLTQ3IC0xMDMgMTEgLTIyNSAxMjIgLTI1NSAyMwotNiA1MyAtOSA2NyAtNiAyNiA2IDMzIC01IDI4NSAtNDcyIDE0MSAtMjYzIDI1NyAtNDgxIDI1NyAtNDg0IDAgLTMgLTIxIC0xOQotNDcgLTM0IC0yODUgLTE2NSAtNDc4IC00NjggLTUxMyAtODA1IC02IC02NiAtMTAgLTc5MCAtMTAgLTIxMDUgbDAgLTIwMDQKMTIwOSAwIDEyMDggMCAxMiA3MyBjOSA1NSAxMSA1NTcgOSAyMDk3IGwtNCAyMDI1IC0yMSA3NSBjLTYzIDIxNCAtMTUzIDM2MwotMzA4IDUwOCAtNDIgMzkgLTExMCA5MiAtMTUxIDExOCAtNDEgMjUgLTc0IDQ4IC03NCA1MSAwIDMgMTE2IDIyMSAyNTggNDg0CjI1MiA0NzAgMjU4IDQ3OSAyODQgNDc0IDQ0IC0xMCAxMDkgMTQgMTQ5IDU0IDEyMyAxMjMgMjggMzIzIC0xNDYgMzA5IC0xNDgKLTEyIC0yMTMgLTE3NyAtMTIxIC0zMDMgMTQgLTE5IC00IC01NSAtMjQ0IC01MDAgLTE0OCAtMjc1IC0yNjUgLTQ3OSAtMjcyCi00NzkgLTcgMSAtNTMgMTQgLTEwMyAyOCAtMTMzIDM5IC0yNTYgNDkgLTUzNSA0MyAtMjUxIC02IC0zMTEgLTE0IC00MzQgLTU3Ci0zMyAtMTEgLTYzIC0xNyAtNjYgLTEzIC03IDcgLTQ2NiA4NTUgLTUwNCA5MzAgLTE1IDMxIC0xNSAzMyA5IDY5IDYyIDkxIDM1CjIwNyAtNjAgMjYxIC00OCAyNyAtMTI1IDMwIC0xNzAgNnogbTEyNSAtNzggYzM3IC0xOSA1MCAtNDMgNTAgLTkzIDAgLTgwIC05NQotMTIwIC0xNTggLTY3IC01MyA0NCAtNDcgMTIwIDEyIDE1NiAzOCAyMyA1OCAyNCA5NiA0eiBtMjQ0MCAwIGM4OSAtNDYgNTQKLTE4NSAtNDcgLTE4NSAtOTAgMSAtMTM1IDEwOCAtNzAgMTY3IDM5IDM2IDczIDQxIDExNyAxOHogbS05OTAgLTE2NTUgYzE3MgotMzMgMzI1IC0xNjcgMzg5IC0zNDMgbDI2IC03MiAzIC01MTcgYzIgLTI4NSAyIC01MTggMCAtNTE4IC0yIDAgLTMwIDE0IC02MgozMCAtMTY4IDg1IC0zNDUgLTE2IC00MzIgLTI0NyAtMTMzIC0zNTAgLTMgLTgwNiAyNTAgLTg3NCA1OCAtMTYgMTM5IC01IDE5MwoyNSAyNSAxNCA0NyAyNiA0OSAyNiAyIDAgNCAtNDI3IDQgLTk1MCBsMCAtOTUwIC02OTUgMCAtNjk1IDAgMCA5NTUgMCA5NTQgMzYKLTI0IGMxMDYgLTcyIDIyNyAtNTcgMzMzIDQxIDY4IDYzIDExMCAxMzYgMTQ3IDI1OSAyMyA3OSAyNyAxMDggMjcgMjMwIDEgMTU4Ci0xMyAyMzIgLTY4IDM1MiAtMzggODIgLTExOCAxNzQgLTE4MCAyMDUgLTIyIDEyIC02NyAyMyAtMTAxIDI2IC02MSA0IC03NyAwCi0xODYgLTU2IC0xMiAtNiAtMTAgOTc3IDIgMTAzOSAzNiAxODggMTkxIDM1MiAzODIgNDAzIDY0IDE4IDQ5NSAyMiA1NzggNnoKbS03MzIgLTE1MzQgYzEwOSAtNTcgMTc2IC0yMjMgMTc2IC00MzYgMCAtMTc1IC0zNiAtMjk0IC0xMTUgLTM4NSAtMTI2IC0xNDMKLTI4OSAtMzYgLTM0NCAyMjYgLTcwIDMzMiAxMDEgNjkwIDI4MyA1OTV6IG0xMDMwIDAgYzE3MiAtOTEgMjM3IC00NzcgMTIyCi03MjUgLTY3IC0xNDIgLTE2MSAtMTk0IC0yNTIgLTEzOCAtMTY2IDEwMCAtMjIyIDQ4MiAtMTA3IDcyNSAzMSA2NCA4NSAxMjcKMTIzIDE0MiAzMyAxMyA4NCAxMiAxMTQgLTR6Ii8+CjxwYXRoIGQ9Ik0xMjQwMCAzMjQ1IGwtNDUgLTQ1IDIzOCAtMjM4IDIzNyAtMjM3IDIzMCAyMzAgMjMwIDIzMCAtMzYgNTQgLTM2CjU0IC0xOTQgLTE5NCAtMTk0IC0xOTQgLTE5MyAxOTMgLTE5MyAxOTIgLTQ0IC00NXoiLz4KPHBhdGggZD0iTTU2MiA0NDQzIGwzIC0yNDM4IDEwNTQgLTMgYzU4MCAtMSAxMDU5IDIgMTA2MyA2IDcgNyAxMDggNDg5IDEwOAo1MTQgMCA0IC0zODIgOCAtODUwIDggbC04NTAgMCAwIDgyMCAwIDgyMCA3MjQgMCBjNDQ4IDAgNzI3IDQgNzMxIDEwIDUgOCAxMDUKNDk0IDEwNSA1MTIgMCA0IC0zNTEgOCAtNzgwIDggbC03ODAgMCAwIDgyNSAwIDgyNSA3NjQgMCA3NjMgMCA1MiAyNTggYzI4CjE0MSA1MSAyNjAgNTEgMjY1IDAgNCAtNDg2IDcgLTEwODAgNyBsLTEwODAgMCAyIC0yNDM3eiIvPgo8cGF0aCBkPSJNMzQ1NCA2ODY3IGMtMiAtNyAtMyAtOTE1IC0xIC0yMDE3IDMgLTIyMzQgLTMgLTIwNDQgNzEgLTIyNDIgNTQKLTE0NCAxMTcgLTIzOSAyNDEgLTM2MyAxNTcgLTE1NyAzMTQgLTI0NCA1MjUgLTI5MCA5OCAtMjEgNDk0IC0zMiA2NDAgLTE3CjE5MCAyMCAzNTAgNzUgNDkzIDE2OCA4NiA1NyAyMzkgMjA3IDI4OSAyODUgODIgMTI1IDE0NiAyODUgMTY4IDQyMSA2IDQxIDEwCjc1MiAxMCAyMDY2IGwwIDIwMDIgLTI2MCAwIC0yNjAgMCAtMiAtMjAwMiAtMyAtMjAwMyAtMjMgLTU5IGMtNjcgLTE3NyAtMjAyCi0zMDAgLTM3MyAtMzQxIC05MSAtMjEgLTQ5NyAtMjEgLTU4OCAwIC0xODggNDUgLTM0MSAxOTggLTM4NiAzODcgLTEzIDU0IC0xNQozMzIgLTE1IDIwNDEgbDAgMTk3NyAtMjYwIDAgYy0yMDQgMCAtMjYyIC0zIC0yNjYgLTEzeiIvPgo8cGF0aCBkPSJNODU0NSA2ODY4IGMtMyAtNyAtNCAtMTEwNCAtMyAtMjQzOCBsMyAtMjQyNSAyNjAgMCAyNjAgMCAzIDEwMzMgMgoxMDMyIDQ2NSAwIGMzMDYgMCA0ODIgLTQgNTE3IC0xMSAxNzAgLTM2IDMxMiAtMTY2IDM3NyAtMzQzIGwyNiAtNzEgMyAtODIyIDMKLTgyMyAyNjAgMCAyNjAgMCAtMyA4NTMgYy0zIDg1MCAtMyA4NTIgLTI2IDkzMiAtNTAgMTc3IC0xNjYgMzY0IC0zMDUgNDg5CmwtNzEgNjUgMjkgMjIgYzUzIDM5IDE2MyAxNTcgMjA1IDIxOCA3OSAxMTcgMTM3IDI1NiAxNTkgMzg1IDcgMzYgMTEgMjQyIDExCjUxNyAwIDM2NiAtMyA0NzMgLTE1IDUzNiAtNDMgMjI3IC0xNDkgNDIwIC0zMTUgNTc3IC0xMzIgMTI0IC0yNzMgMjAxIC00NjkKMjU0IGwtOTYgMjYgLTc2OCA0IGMtNjIzIDIgLTc2OCAxIC03NzIgLTEweiBtMTUyMCAtNTMzIGMxNDYgLTM4IDI2NiAtMTM4CjMzNCAtMjc2IDU5IC0xMjEgNjMgLTE2NCA1OSAtNjMxIC00IC0zNTUgLTYgLTQxMCAtMjIgLTQ1OCAtNDkgLTE0OSAtMTQwCi0yNTYgLTI3NCAtMzIzIGwtODUgLTQyIC01MDQgLTMgLTUwMyAtMyAwIDg3NiAwIDg3NSA0NjggMCBjMzg4IDAgNDc4IC0zIDUyNwotMTV6Ii8+CjxwYXRoIGQ9Ik0xNDc1MCA2NjE1IGwwIC0yNjUgNDY1IDAgNDY1IDAgMiAtMjE3MiAzIC0yMTczIDI2MyAtMyAyNjIgLTIgMAoyMTc1IDAgMjE3NSA0MzUgMCBjMjM5IDAgNDM1IDEgNDM1IDMgMCAyIDIzIDExNSA1MCAyNTIgMjggMTM3IDUwIDI1NSA1MCAyNjIKMCAxMSAtMjIyIDEzIC0xMjE1IDEzIGwtMTIxNSAwIDAgLTI2NXoiLz4KPHBhdGggZD0iTTE3ODUwIDQ0NDAgbDAgLTI0NDAgMTA2MCAwIDEwNjAgMCA1IDIzIGMzIDEyIDI3IDEzMSA1NCAyNjQgbDQ4CjI0MyAtODUzIDAgLTg1NCAwIDAgODIwIDAgODIwIDczMCAwIDczMCAwIDUgMjMgYzMgMTIgMjcgMTMxIDU0IDI2NSBsNDggMjQyCi03ODMgMCAtNzg0IDAgMCA4MjUgMCA4MjUgNzY1IDAgNzY1IDAgNSAyMyBjMTYgNjggOTUgNDc0IDk1IDQ4OSAwIDE3IC00NCAxOAotMTA3NSAxOCBsLTEwNzUgMCAwIC0yNDQweiIvPgo8cGF0aCBkPSJNNjU2MCAzOTE1IGwwIC0yNjUgNjYwIDAgNjYwIDAgMCAyNjUgMCAyNjUgLTY2MCAwIC02NjAgMCAwIC0yNjV6Ii8+CjxwYXRoIGQ9Ik0xMTg4MCAxNjQwIGwwIC03MCA5NjUgMCA5NjUgMCA5IDIzIGM1IDEzIDEyIDQ1IDE2IDcwIGw3IDQ3IC05ODEgMAotOTgxIDAgMCAtNzB6Ii8+CjxwYXRoIGQ9Ik0xMjE2NyAxMzkzIGMtNCAtMyAtNyAtMzUgLTcgLTcwIGwwIC02MyA2ODUgMCA2ODQgMCAxMCAzOCBjNSAyMCAxMgo1MiAxNiA3MCBsNyAzMiAtNjk1IDAgYy0zODEgMCAtNjk3IC0zIC03MDAgLTd6Ii8+CjxwYXRoIGQ9Ik01NjAgODIwIGwwIC0yNjAgOTY4MCAwIDk2ODAgMCA1IDIzIGMxMyA1NSA5NSA0NzIgOTUgNDg0IDAgMTEKLTE3MDQgMTMgLTk3MzAgMTMgbC05NzMwIDAgMCAtMjYweiIvPgo8L2c+Cjwvc3ZnPgo=";

var ja = {
	"mbitMore.name": "Boson",
	"mbitMore.whenButtonEvent": " [NAME]  [EVENT] ",
	"mbitMore.buttonIDMenu.a": "A",
	"mbitMore.buttonIDMenu.b": "B",
	"mbitMore.buttonEventMenu.down": "",
	"mbitMore.buttonEventMenu.hold": "",
	"mbitMore.buttonEventMenu.up": "",
	"mbitMore.buttonEventMenu.click": "",
	"mbitMore.buttonEventMenu.longClick": "",
	"mbitMore.buttonEventMenu.doubleClick": "",
	"mbitMore.isButtonPressed": " [NAME] ",
	"mbitMore.whenTouchEvent": " [NAME]  [EVENT] ",
	"mbitMore.isPinTouched": " [NAME] ",
	"mbitMore.touchIDMenu.logo": "",
	"mbitMore.touchEventMenu.touched": "",
	"mbitMore.touchEventMenu.hold": "",
	"mbitMore.touchEventMenu.released": "",
	"mbitMore.touchEventMenu.tapped": "",
	"mbitMore.touchEventMenu.longTapped": "",
	"mbitMore.touchEventMenu.doubleTapped": "",
	"mbitMore.whenGesture": "[GESTURE] ",
	"mbitMore.gesturesMenu.tiltUp": "",
	"mbitMore.gesturesMenu.tiltDown": "",
	"mbitMore.gesturesMenu.tiltLeft": "",
	"mbitMore.gesturesMenu.tiltRight": "",
	"mbitMore.gesturesMenu.faceUp": "",
	"mbitMore.gesturesMenu.faceDown": "",
	"mbitMore.gesturesMenu.freefall": "",
	"mbitMore.gesturesMenu.g3": "3G",
	"mbitMore.gesturesMenu.g6": "6G",
	"mbitMore.gesturesMenu.g8": "8G",
	"mbitMore.gesturesMenu.shake": "",
	"mbitMore.displayMatrix": " [MATRIX] ",
	"mbitMore.displayText": " [TEXT]  [DELAY] ",
	"mbitMore.clearDisplay": "",
	"mbitMore.isPinHigh": " [PIN] ",
	"mbitMore.lightLevel": "",
	"mbitMore.temperature": "",
	"mbitMore.compassHeading": "",
	"mbitMore.magneticForce": " [AXIS]",
	"mbitMore.acceleration": " [AXIS]",
	"mbitMore.pitch": "",
	"mbitMore.roll": "",
	"mbitMore.soundLevel": "",
	"mbitMore.analogValue": " [PIN] ",
	"mbitMore.setPullMode": " [PIN]  [MODE] ",
	"mbitMore.setDigitalOut": " [PIN]  [LEVEL] ",
	"mbitMore.setAnalogOut": " [PIN]  [LEVEL] %",
	"mbitMore.playTone": "[FREQ] Hz [VOL] %",
	"mbitMore.stopTone": "",
	"mbitMore.setServo": " [PIN]  [ANGLE] ",
	"mbitMore.digitalValueMenu.Low": "",
	"mbitMore.digitalValueMenu.High": "",
	"mbitMore.axisMenu.x": "x",
	"mbitMore.axisMenu.y": "y",
	"mbitMore.axisMenu.z": "z",
	"mbitMore.axisMenu.absolute": "",
	"mbitMore.pinModeMenu.pullNone": "",
	"mbitMore.pinModeMenu.pullUp": "",
	"mbitMore.pinModeMenu.pullDown": "",
	"mbitMore.listenPinEventType": " [PIN]  [EVENT_TYPE] ",
	"mbitMore.pinEventTypeMenu.none": "",
	"mbitMore.pinEventTypeMenu.edge": "",
	"mbitMore.pinEventTypeMenu.pulse": "",
	"mbitMore.pinEventTypeMenu.touch": "",
	"mbitMore.whenPinEvent": " [PIN]  [EVENT] ",
	"mbitMore.pinEventMenu.rise": "",
	"mbitMore.pinEventMenu.fall": "",
	"mbitMore.pinEventMenu.pulseHigh": "",
	"mbitMore.pinEventMenu.pulseLow": "",
	"mbitMore.getPinEventValue": " [PIN]  [EVENT]",
	"mbitMore.pinEventTimestampMenu.rise": "",
	"mbitMore.pinEventTimestampMenu.fall": "",
	"mbitMore.pinEventTimestampMenu.pulseHigh": "",
	"mbitMore.pinEventTimestampMenu.pulseLow": "",
	"mbitMore.whenDataReceived": "micro:bit  [LABEL] ",
	"mbitMore.getDataLabeled": " [LABEL] ",
	"mbitMore.sendData": "micro:bit  [DATA]  [LABEL] ",
	"mbitMore.connectionStateMenu.connected": "",
	"mbitMore.connectionStateMenu.disconnected": "",
	"mbitMore.whenConnectionChanged": "micro:bit [STATE]",
	"mbitMore.selectCommunicationRoute.connectWith": "",
	"mbitMore.selectCommunicationRoute.bluetooth": "Bluetooth",
	"mbitMore.selectCommunicationRoute.usb": "USB",
	"mbitMore.selectCommunicationRoute.connect": "",
	"mbitMore.selectCommunicationRoute.cancel": ""
};
var pt = {
	"mbitMore.name": "Boson",
	"mbitMore.lightLevel": "Intensidade da Luz",
	"mbitMore.compassHeading": "Est em direo ao Norte",
	"mbitMore.magneticForce": "Fora Magntica [AXIS]",
	"mbitMore.acceleration": "Acelerao no Eixo[AXIS]",
	"mbitMore.analogValue": "Ler Pino Analgico [PIN]",
	"mbitMore.setInput": "Definir Pino[PIN] como entrada",
	"mbitMore.setAnalogOut": "Definir pino PWM[PIN]com[LEVEL]",
	"mbitMore.setServo": "Definir Servo no pino [PIN]com ngulo de [ANGLE]",
	"mbitMore.digitalValueMenu.Low": "desligado",
	"mbitMore.digitalValueMenu.High": "ligado"
};
var translations = {
	ja: ja,
	"ja-Hira": {
	"mbitMore.name": "Boson",
	"mbitMore.whenButtonEvent": "[NAME]  [EVENT] ",
	"mbitMore.buttonIDMenu.a": "A",
	"mbitMore.buttonIDMenu.b": "B",
	"mbitMore.buttonEventMenu.down": "",
	"mbitMore.buttonEventMenu.hold": "",
	"mbitMore.buttonEventMenu.up": "",
	"mbitMore.buttonEventMenu.click": "",
	"mbitMore.buttonEventMenu.longClick": "",
	"mbitMore.buttonEventMenu.doubleClick": "",
	"mbitMore.isButtonPressed": "[NAME] ",
	"mbitMore.whenTouchEvent": " [NAME]  [EVENT] ",
	"mbitMore.isPinTouched": " [NAME] ",
	"mbitMore.touchIDMenu.logo": "",
	"mbitMore.touchEventMenu.touched": "",
	"mbitMore.touchEventMenu.hold": "",
	"mbitMore.touchEventMenu.released": "",
	"mbitMore.touchEventMenu.tapped": "",
	"mbitMore.touchEventMenu.longTapped": "",
	"mbitMore.touchEventMenu.doubleTapped": "",
	"mbitMore.whenGesture": "[GESTURE] ",
	"mbitMore.gesturesMenu.tiltUp": "",
	"mbitMore.gesturesMenu.tiltDown": "",
	"mbitMore.gesturesMenu.tiltLeft": "",
	"mbitMore.gesturesMenu.tiltRight": "",
	"mbitMore.gesturesMenu.faceUp": "",
	"mbitMore.gesturesMenu.faceDown": "",
	"mbitMore.gesturesMenu.freefall": "",
	"mbitMore.gesturesMenu.g3": "3G",
	"mbitMore.gesturesMenu.g6": "6G",
	"mbitMore.gesturesMenu.g8": "8G",
	"mbitMore.gesturesMenu.shake": "",
	"mbitMore.displayMatrix": " [MATRIX] ",
	"mbitMore.displayText": " [TEXT]  [DELAY] ",
	"mbitMore.clearDisplay": "",
	"mbitMore.isPinHigh": " [PIN] ",
	"mbitMore.lightLevel": "",
	"mbitMore.temperature": "",
	"mbitMore.compassHeading": "",
	"mbitMore.magneticForce": " [AXIS]",
	"mbitMore.acceleration": " [AXIS]",
	"mbitMore.pitch": "",
	"mbitMore.roll": "",
	"mbitMore.soundLevel": "",
	"mbitMore.analogValue": " [PIN] ",
	"mbitMore.setPullMode": " [PIN]  [MODE] ",
	"mbitMore.setDigitalOut": " [PIN]  [LEVEL] ",
	"mbitMore.setAnalogOut": " [PIN]  [LEVEL] ",
	"mbitMore.playTone": "[FREQ]  [VOL] ",
	"mbitMore.stopTone": "",
	"mbitMore.setServo": " [PIN]  [ANGLE] ",
	"mbitMore.digitalValueMenu.Low": "",
	"mbitMore.digitalValueMenu.High": "",
	"mbitMore.axisMenu.x": "x",
	"mbitMore.axisMenu.y": "y",
	"mbitMore.axisMenu.z": "z",
	"mbitMore.axisMenu.absolute": "",
	"mbitMore.pinModeMenu.pullNone": "",
	"mbitMore.pinModeMenu.pullUp": "",
	"mbitMore.pinModeMenu.pullDown": "",
	"mbitMore.listenPinEventType": " [PIN]  [EVENT_TYPE]",
	"mbitMore.pinEventTypeMenu.none": "",
	"mbitMore.pinEventTypeMenu.edge": "",
	"mbitMore.pinEventTypeMenu.pulse": "",
	"mbitMore.pinEventTypeMenu.touch": "",
	"mbitMore.whenPinEvent": " [PIN]  [EVENT] ",
	"mbitMore.pinEventMenu.rise": "",
	"mbitMore.pinEventMenu.fall": "",
	"mbitMore.pinEventMenu.pulseHigh": "",
	"mbitMore.pinEventMenu.pulseLow": "",
	"mbitMore.getPinEventValue": " [PIN]  [EVENT]",
	"mbitMore.pinEventTimestampMenu.rise": "",
	"mbitMore.pinEventTimestampMenu.fall": "",
	"mbitMore.pinEventTimestampMenu.pulseHigh": "",
	"mbitMore.pinEventTimestampMenu.pulseLow": "",
	"mbitMore.whenDataReceived": "micro:bit  [LABEL] ",
	"mbitMore.getDataLabeled": " [LABEL] ",
	"mbitMore.sendData": "micro:bit  [DATA]  [LABEL] ",
	"mbitMore.connectionStateMenu.connected": "",
	"mbitMore.connectionStateMenu.disconnected": "",
	"mbitMore.whenConnectionChanged": "micro:bit [STATE]",
	"mbitMore.selectCommunicationRoute.connectWith": "",
	"mbitMore.selectCommunicationRoute.bluetooth": "",
	"mbitMore.selectCommunicationRoute.usb": "",
	"mbitMore.selectCommunicationRoute.connect": "",
	"mbitMore.selectCommunicationRoute.cancel": ""
},
	"pt-br": {
	"mbitMore.name": "Boson",
	"mbitMore.lightLevel": "Intensidade da Luz",
	"mbitMore.compassHeading": "Est em direo ao Norte",
	"mbitMore.magneticForce": "Fora Magntica [AXIS]",
	"mbitMore.acceleration": "Acelerao no Eixo[AXIS]",
	"mbitMore.analogValue": "Ler Pino Analgico [PIN]",
	"mbitMore.setInput": "Definir Pino[PIN] como entrada",
	"mbitMore.setAnalogOut": "Definir pino PWM[PIN]com[LEVEL]",
	"mbitMore.setServo": "Definir Servo no pino [PIN]com ngulo de [ANGLE]",
	"mbitMore.digitalValueMenu.Low": "desligado",
	"mbitMore.digitalValueMenu.High": "ligado"
},
	pt: pt
};

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

var JSONRPC$1 = /*#__PURE__*/function () {
  function JSONRPC() {
    _classCallCheck(this, JSONRPC);

    this._requestID = 0;
    this._openRequests = {};
  }
  /**
   * Make an RPC request and retrieve the result.
   * @param {string} method - the remote method to call.
   * @param {object} params - the parameters to pass to the remote method.
   * @returns {Promise} - a promise for the result of the call.
   */


  _createClass(JSONRPC, [{
    key: "sendRemoteRequest",
    value: function sendRemoteRequest(method, params) {
      var _this = this;

      var requestID = this._requestID++;
      var promise = new Promise(function (resolve, reject) {
        _this._openRequests[requestID] = {
          resolve: resolve,
          reject: reject
        };
      });

      this._sendRequest(method, params, requestID);

      return promise;
    }
    /**
     * Make an RPC notification with no expectation of a result or callback.
     * @param {string} method - the remote method to call.
     * @param {object} params - the parameters to pass to the remote method.
     */

  }, {
    key: "sendRemoteNotification",
    value: function sendRemoteNotification(method, params) {
      this._sendRequest(method, params);
    }
    /**
     * Handle an RPC request from remote, should return a result or Promise for result, if appropriate.
     * @param {string} method - the method requested by the remote caller.
     * @param {object} params - the parameters sent with the remote caller's request.
     */

  }, {
    key: "didReceiveCall",
    value: function
      /* method , params */
    didReceiveCall() {
      throw new Error('Must override didReceiveCall');
    }
  }, {
    key: "_sendMessage",
    value: function
      /* jsonMessageObject */
    _sendMessage() {
      throw new Error('Must override _sendMessage');
    }
  }, {
    key: "_sendRequest",
    value: function _sendRequest(method, params, id) {
      var request = {
        jsonrpc: '2.0',
        method: method,
        params: params
      };

      if (id !== null) {
        request.id = id;
      }

      this._sendMessage(request);
    }
  }, {
    key: "_handleMessage",
    value: function _handleMessage(json) {
      if (json.jsonrpc !== '2.0') {
        throw new Error("Bad or missing JSON-RPC version in message: ".concat(json));
      }

      if (json.hasOwnProperty('method')) {
        this._handleRequest(json);
      } else {
        this._handleResponse(json);
      }
    }
  }, {
    key: "_sendResponse",
    value: function _sendResponse(id, result, error) {
      var response = {
        jsonrpc: '2.0',
        id: id
      };

      if (error) {
        response.error = error;
      } else {
        response.result = result || null;
      }

      this._sendMessage(response);
    }
  }, {
    key: "_handleResponse",
    value: function _handleResponse(json) {
      var result = json.result,
          error = json.error,
          id = json.id;
      var openRequest = this._openRequests[id];
      delete this._openRequests[id];

      if (openRequest) {
        if (error) {
          openRequest.reject(error);
        } else {
          openRequest.resolve(result);
        }
      }
    }
  }, {
    key: "_handleRequest",
    value: function _handleRequest(json) {
      var _this2 = this;

      var method = json.method,
          params = json.params,
          id = json.id;
      var rawResult = this.didReceiveCall(method, params);

      if (id) {
        Promise.resolve(rawResult).then(function (result) {
          _this2._sendResponse(id, result);
        }, function (error) {
          _this2._sendResponse(id, null, error);
        });
      }
    }
  }]);

  return JSONRPC;
}();

var jsonrpc = JSONRPC$1;

var log$1 = log$2;

var uint8ArrayToBase64$2 = function uint8ArrayToBase64(array) {
  return window.btoa(String.fromCharCode.apply(String, _toConsumableArray(array)));
};

var base64ToUint8Array$2 = function base64ToUint8Array(base64) {
  var raw = window.atob(base64);
  return Uint8Array.from(Array.prototype.map.call(raw, function (x) {
    return x.charCodeAt(0);
  }));
};

var WebBLE$1 = /*#__PURE__*/function () {
  /**
   * A BLE peripheral object.  It handles connecting, over Web Bluetooth API, to
   * BLE peripherals, and reading and writing data to them.
   * @param {Runtime} runtime - the Runtime for sending/receiving GUI update events.
   * @param {string} extensionId - the id of the extension using this object.
   * @param {object} peripheralOptions - the list of options for peripheral discovery.
   * @param {object} connectCallback - a callback for connection.
   * @param {object} resetCallback - a callback for resetting extension state.
   */
  function WebBLE(runtime, extensionId, peripheralOptions, connectCallback) {
    var resetCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

    _classCallCheck(this, WebBLE);

    /**
     * Remote device which have been connected.
     * @type {BluetoothDevice}
     */
    this._device = null;
    /**
     * Remote GATT server
     * @type {BluetoothRemoteGATTServer}
     */

    this._server = null;
    this._connectCallback = connectCallback;
    this._disconnected = true;
    this._characteristicDidChangeCallback = null;
    this._resetCallback = resetCallback;
    this._extensionId = extensionId;
    this._peripheralOptions = peripheralOptions;
    this._runtime = runtime;
    this.requestPeripheral();
  }
  /**
   * Request connection to the peripheral.
   * Request user to choose a device, and then connect it automatically.
   */


  _createClass(WebBLE, [{
    key: "requestPeripheral",
    value: function requestPeripheral() {
      var _this = this;

      if (this._server) {
        this.disconnect();
      }

      navigator.bluetooth.requestDevice(this._peripheralOptions).then(function (device) {
        _this._device = device;
        log$1.debug("device=".concat(_this._device.name));

        _this._runtime.connectPeripheral(_this._extensionId, _this._device.id);
      }).catch(function (e) {
        _this._handleRequestError(e);
      });
    }
    /**
     * Try connecting to the GATT server of the device, and then call the connect
     * callback when connection is successful.
     */

  }, {
    key: "connectPeripheral",
    value: function
      /* id */
    connectPeripheral() {
      var _this2 = this;

      if (!this._device) {
        throw new Error('device is not chosen');
      }

      this._device.gatt.connect().then(function (gattServer) {
        log$1.debug("GATTServer is connected");
        _this2._server = gattServer;

        _this2._runtime.emit(_this2._runtime.constructor.PERIPHERAL_CONNECTED);

        _this2._disconnected = false;

        _this2._connectCallback();

        _this2._device.addEventListener('gattserverdisconnected', function (event) {
          _this2.onDisconnected(event);
        });
      });
    }
    /**
     * Disconnect from the device and clean up.
     * Then emit the connection state by the runtime.
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      if (!this._server) return;

      this._server.disconnect();

      this._disconnected = true;
      this._server = null;
      this._device = null;

      this._runtime.emit(this._runtime.constructor.PERIPHERAL_DISCONNECTED);
    }
    /**
     * @return {bool} whether the peripheral is connected.
     */

  }, {
    key: "isConnected",
    value: function isConnected() {
      if (!this._server) return false;
      return this._server.connected;
    }
    /**
     * Start receiving notifications from the specified ble service.
     * @param {number} serviceId - the ble service to read.
     * @param {number} characteristicId - the ble characteristic to get notifications from.
     * @param {object} onCharacteristicChanged - callback for characteristic change notifications
     *  like function(base64message).
     * @return {Promise} - a promise from the remote startNotifications request.
     */

  }, {
    key: "startNotifications",
    value: function startNotifications(serviceId, characteristicId) {
      var onCharacteristicChanged = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      return this._server.getPrimaryService(serviceId).then(function (service) {
        return service.getCharacteristic(characteristicId);
      }).then(function (characteristic) {
        characteristic.addEventListener('characteristicvaluechanged', function (event) {
          var dataView = event.target.value;
          onCharacteristicChanged(uint8ArrayToBase64$2(new Uint8Array(dataView.buffer)));
        });
        characteristic.startNotifications();
      });
    }
    /**
     * Read from the specified ble service.
     * @param {number} serviceId - the ble service to read.
     * @param {number} characteristicId - the ble characteristic to read.
     * @param {boolean} optStartNotifications - whether to start receiving characteristic change notifications.
     * @param {object} onCharacteristicChanged - callback for characteristic change notifications
     *  like function(base64message).
     * @return {Promise} - a promise from the remote read request which resolve {message: base64string}.
     */

  }, {
    key: "read",
    value: function read(serviceId, characteristicId) {
      var _this3 = this;

      var optStartNotifications = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var onCharacteristicChanged = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      return this._server.getPrimaryService(serviceId).then(function (service) {
        return service.getCharacteristic(characteristicId);
      }).then(function (characteristic) {
        if (optStartNotifications) {
          _this3.startNotifications(serviceId, characteristicId, onCharacteristicChanged);
        }

        return characteristic.readValue();
      }).then(function (dataView) {
        return {
          message: uint8ArrayToBase64$2(new Uint8Array(dataView.buffer))
        };
      });
    }
    /**
     * Write data to the specified ble service.
     * @param {number} serviceId - the ble service to write.
     * @param {number} characteristicId - the ble characteristic to write.
     * @param {string} message - the message to send.
     * @param {string} encoding - the message encoding type.
     * @param {boolean} withResponse - if true, resolve after peripheral's response.
     * @return {Promise} - a promise from the remote send request.
     */
    // eslint-disable-next-line no-unused-vars

  }, {
    key: "write",
    value: function write(serviceId, characteristicId, message) {
      var encoding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var withResponse = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var value = encoding === 'base64' ? base64ToUint8Array$2(message) : message;
      return this._server.getPrimaryService(serviceId).then(function (service) {
        return service.getCharacteristic(characteristicId);
      }).then(function (characteristic) {
        if (withResponse && characteristic.writeValueWithResponse) {
          return characteristic.writeValueWithResponse(value);
        }

        if (characteristic.writeValueWithoutResponse) {
          return characteristic.writeValueWithoutResponse(value);
        }

        return characteristic.writeValue(value);
      });
    }
    /**
     * Handle an error resulting from losing connection to a peripheral.
     *
     * This could be due to:
     * - battery depletion
     * - going out of bluetooth range
     * - being powered down
     *
     * Disconnect the device, and if the extension using this object has a
     * reset callback, call it. Finally, emit an error to the runtime.
     */

  }, {
    key: "handleDisconnectError",
    value: function
      /* e */
    handleDisconnectError() {
      // log.error(`BLE error: ${JSON.stringify(e)}`);
      if (this._disconnected) return;
      this.disconnect();

      if (this._resetCallback) {
        this._resetCallback();
      }

      this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTION_LOST_ERROR, {
        message: "Scratch lost connection to",
        extensionId: this._extensionId
      });
    }
  }, {
    key: "_handleRequestError",
    value: function
      /* e */
    _handleRequestError() {
      // log.error(`BLE error: ${JSON.stringify(e)}`);
      this._runtime.emit(this._runtime.constructor.PERIPHERAL_REQUEST_ERROR, {
        message: "Scratch lost connection to",
        extensionId: this._extensionId
      });
    }
    /**
     * Called when disconnected by the device.
     */

  }, {
    key: "onDisconnected",
    value: function
      /* event */
    onDisconnected() {
      this.handleDisconnectError(new Error('device disconnected'));
    }
  }]);

  return WebBLE;
}();

var bleWeb = WebBLE$1;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var JSONRPC = jsonrpc;
var WebBLE = bleWeb;

var BLE$1 = /*#__PURE__*/function (_JSONRPC) {
  _inherits(BLE, _JSONRPC);

  var _super = _createSuper(BLE);

  /**
   * A BLE peripheral socket object.  It handles connecting, over web sockets, to
   * BLE peripherals, and reading and writing data to them.
   * @param {Runtime} runtime - the Runtime for sending/receiving GUI update events.
   * @param {string} extensionId - the id of the extension using this socket.
   * @param {object} peripheralOptions - the list of options for peripheral discovery.
   * @param {object} connectCallback - a callback for connection.
   * @param {object} resetCallback - a callback for resetting extension state.
   */
  function BLE(runtime, extensionId, peripheralOptions, connectCallback) {
    var _this;

    var resetCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

    _classCallCheck(this, BLE);

    _this = _super.call(this);
    _this._socket = runtime.getScratchLinkSocket('BLE');

    _this._socket.setOnOpen(_this.requestPeripheral.bind(_assertThisInitialized(_this)));

    _this._socket.setOnClose(_this.handleDisconnectError.bind(_assertThisInitialized(_this)));

    _this._socket.setOnError(_this._handleRequestError.bind(_assertThisInitialized(_this)));

    _this._socket.setHandleMessage(_this._handleMessage.bind(_assertThisInitialized(_this)));

    _this._sendMessage = _this._socket.sendMessage.bind(_this._socket);
    _this._availablePeripherals = {};
    _this._connectCallback = connectCallback;
    _this._connected = false;
    _this._characteristicDidChangeCallback = null;
    _this._resetCallback = resetCallback;
    _this._discoverTimeoutID = null;
    _this._extensionId = extensionId;
    _this._peripheralOptions = peripheralOptions;
    _this._runtime = runtime;

    _this._socket.open();

    return _this;
  }
  /**
   * Request connection to the peripheral.
   * If the web socket is not yet open, request when the socket promise resolves.
   */


  _createClass(BLE, [{
    key: "requestPeripheral",
    value: function requestPeripheral() {
      var _this2 = this;

      this._availablePeripherals = {};

      if (this._discoverTimeoutID) {
        window.clearTimeout(this._discoverTimeoutID);
      }

      this._discoverTimeoutID = window.setTimeout(this._handleDiscoverTimeout.bind(this), 15000);
      this.sendRemoteRequest('discover', this._peripheralOptions).catch(function (e) {
        _this2._handleRequestError(e);
      });
    }
    /**
     * Try connecting to the input peripheral id, and then call the connect
     * callback if connection is successful.
     * @param {number} id - the id of the peripheral to connect to
     */

  }, {
    key: "connectPeripheral",
    value: function connectPeripheral(id) {
      var _this3 = this;

      this.sendRemoteRequest('connect', {
        peripheralId: id
      }).then(function () {
        _this3._connected = true;

        _this3._runtime.emit(_this3._runtime.constructor.PERIPHERAL_CONNECTED);

        _this3._connectCallback();
      }).catch(function (e) {
        _this3._handleRequestError(e);
      });
    }
    /**
     * Close the websocket.
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      if (this._connected) {
        this._connected = false;
      }

      if (this._socket.isOpen()) {
        this._socket.close();
      }

      if (this._discoverTimeoutID) {
        window.clearTimeout(this._discoverTimeoutID);
      } // Sets connection status icon to orange


      this._runtime.emit(this._runtime.constructor.PERIPHERAL_DISCONNECTED);
    }
    /**
     * @return {bool} whether the peripheral is connected.
     */

  }, {
    key: "isConnected",
    value: function isConnected() {
      return this._connected;
    }
    /**
     * Start receiving notifications from the specified ble service.
     * @param {number} serviceId - the ble service to read.
     * @param {number} characteristicId - the ble characteristic to get notifications from.
     * @param {object} onCharacteristicChanged - callback for characteristic change notifications.
     * @return {Promise} - a promise from the remote startNotifications request.
     */

  }, {
    key: "startNotifications",
    value: function startNotifications(serviceId, characteristicId) {
      var _this4 = this;

      var onCharacteristicChanged = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var params = {
        serviceId: serviceId,
        characteristicId: characteristicId
      };
      this._characteristicDidChangeCallback = onCharacteristicChanged;
      return this.sendRemoteRequest('startNotifications', params).catch(function (e) {
        _this4.handleDisconnectError(e);
      });
    }
    /**
     * Read from the specified ble service.
     * @param {number} serviceId - the ble service to read.
     * @param {number} characteristicId - the ble characteristic to read.
     * @param {boolean} optStartNotifications - whether to start receiving characteristic change notifications.
     * @param {object} onCharacteristicChanged - callback for characteristic change notifications.
     * @return {Promise} - a promise from the remote read request.
     */

  }, {
    key: "read",
    value: function read(serviceId, characteristicId) {
      var _this5 = this;

      var optStartNotifications = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var onCharacteristicChanged = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var params = {
        serviceId: serviceId,
        characteristicId: characteristicId
      };

      if (optStartNotifications) {
        params.startNotifications = true;
      }

      if (onCharacteristicChanged) {
        this._characteristicDidChangeCallback = onCharacteristicChanged;
      }

      return this.sendRemoteRequest('read', params).catch(function (e) {
        _this5.handleDisconnectError(e);
      });
    }
    /**
     * Write data to the specified ble service.
     * @param {number} serviceId - the ble service to write.
     * @param {number} characteristicId - the ble characteristic to write.
     * @param {string} message - the message to send.
     * @param {string} encoding - the message encoding type.
     * @param {boolean} withResponse - if true, resolve after peripheral's response.
     * @return {Promise} - a promise from the remote send request.
     */

  }, {
    key: "write",
    value: function write(serviceId, characteristicId, message) {
      var _this6 = this;

      var encoding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var withResponse = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var params = {
        serviceId: serviceId,
        characteristicId: characteristicId,
        message: message
      };

      if (encoding) {
        params.encoding = encoding;
      }

      if (withResponse !== null) {
        params.withResponse = withResponse;
      }

      return this.sendRemoteRequest('write', params).catch(function (e) {
        _this6.handleDisconnectError(e);
      });
    }
    /**
     * Handle a received call from the socket.
     * @param {string} method - a received method label.
     * @param {object} params - a received list of parameters.
     * @return {object} - optional return value.
     */

  }, {
    key: "didReceiveCall",
    value: function didReceiveCall(method, params) {
      switch (method) {
        case 'didDiscoverPeripheral':
          this._availablePeripherals[params.peripheralId] = params;

          this._runtime.emit(this._runtime.constructor.PERIPHERAL_LIST_UPDATE, this._availablePeripherals);

          if (this._discoverTimeoutID) {
            window.clearTimeout(this._discoverTimeoutID);
          }

          break;

        case 'userDidPickPeripheral':
          this._availablePeripherals[params.peripheralId] = params;

          this._runtime.emit(this._runtime.constructor.USER_PICKED_PERIPHERAL, this._availablePeripherals);

          if (this._discoverTimeoutID) {
            window.clearTimeout(this._discoverTimeoutID);
          }

          break;

        case 'userDidNotPickPeripheral':
          this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);

          if (this._discoverTimeoutID) {
            window.clearTimeout(this._discoverTimeoutID);
          }

          break;

        case 'characteristicDidChange':
          if (this._characteristicDidChangeCallback) {
            this._characteristicDidChangeCallback(params.message);
          }

          break;

        case 'ping':
          return 42;
      }
    }
    /**
     * Handle an error resulting from losing connection to a peripheral.
     *
     * This could be due to:
     * - battery depletion
     * - going out of bluetooth range
     * - being powered down
     *
     * Disconnect the socket, and if the extension using this socket has a
     * reset callback, call it. Finally, emit an error to the runtime.
     */

  }, {
    key: "handleDisconnectError",
    value: function
      /* e */
    handleDisconnectError() {
      // log.error(`BLE error: ${JSON.stringify(e)}`);
      if (!this._connected) return;
      this.disconnect();

      if (this._resetCallback) {
        this._resetCallback();
      }

      this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTION_LOST_ERROR, {
        message: "Scratch lost connection to",
        extensionId: this._extensionId
      });
    }
  }, {
    key: "_handleRequestError",
    value: function
      /* e */
    _handleRequestError() {
      // log.error(`BLE error: ${JSON.stringify(e)}`);
      this._runtime.emit(this._runtime.constructor.PERIPHERAL_REQUEST_ERROR, {
        message: "Scratch lost connection to",
        extensionId: this._extensionId
      });
    }
  }, {
    key: "_handleDiscoverTimeout",
    value: function _handleDiscoverTimeout() {
      if (this._discoverTimeoutID) {
        window.clearTimeout(this._discoverTimeoutID);
      }

      this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);
    }
  }]);

  return BLE;
}(JSONRPC);

var ble$1 = navigator.bluetooth ? WebBLE : BLE$1;

var BLE = ble$1;
var ble = BLE;

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

var runtime = {exports: {}};

(function (module) {
  var runtime = function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.

    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }

    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function define(obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.

      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.

    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.


    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = GeneratorFunctionPrototype;
    define(Gp, "constructor", GeneratorFunctionPrototype);
    define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    exports.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    exports.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    }; // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.


    exports.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function (unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      } // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).


      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);
    define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    });
    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.

    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          } // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted; // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.

            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    } // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.


    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

        context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      } // The delegate iterator is finished, so forget it and continue with
      // the outer generator.


      context.delegate = null;
      return ContinueSentinel;
    } // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.


    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.

    define(Gp, iteratorSymbol, function () {
      return this;
    });
    define(Gp, "toString", function () {
      return "[object Generator]";
    });

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse(); // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.

      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        } // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.


        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      } // Return an iterator with no values.


      return {
        next: doneResult
      };
    }

    exports.values = values;

    function doneResult() {
      return {
        value: undefined$1,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0; // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.

        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function stop() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        } // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.


        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    }; // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.

    return exports;
  }( // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  module.exports );

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, in modern engines
    // we can explicitly access globalThis. In older engines we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    if ((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
})(runtime);

var regenerator = runtime.exports;

var log = log$2;

var uint8ArrayToBase64$1 = function uint8ArrayToBase64(array) {
  return window.btoa(String.fromCharCode.apply(String, _toConsumableArray(array)));
};

var base64ToUint8Array$1 = function base64ToUint8Array(base64) {
  var raw = window.atob(base64);
  return Uint8Array.from(Array.prototype.map.call(raw, function (x) {
    return x.charCodeAt(0);
  }));
};
/**
 * Characteristic ID on serial-port.
 */


var SERIAL_CH_ID = {
  '0b500100-607f-4151-9091-7d008d6ffc5c': 0x0100,
  '0b500101-607f-4151-9091-7d008d6ffc5c': 0x0101,
  '0b500102-607f-4151-9091-7d008d6ffc5c': 0x0102,
  '0b500110-607f-4151-9091-7d008d6ffc5c': 0x0110,
  '0b500111-607f-4151-9091-7d008d6ffc5c': 0x0111,
  '0b500120-607f-4151-9091-7d008d6ffc5c': 0x0120,
  '0b500121-607f-4151-9091-7d008d6ffc5c': 0x0121,
  '0b500122-607f-4151-9091-7d008d6ffc5c': 0x0122,
  '0b500130-607f-4151-9091-7d008d6ffc5c': 0x0130
};
/**
 * Start Frame Delimiter
 */

var SFD = 0xFF;
/**
 * Request type in data frame.
 */

var ChRequest = {
  READ: 0x01,
  WRITE: 0x10,
  WRITE_RESPONSE: 0x11,
  NOTIFY_STOP: 0x20,
  NOTIFY_START: 0x21
};
/**
 * Response type in data frame.
 */

var ChResponse = {
  READ: 0x01,
  WRITE_RESPONSE: 0x11,
  NOTIFY: 0x21
};
/**
 * Class to communicate with device via USB serial-port using Web Serial API.
 */

var WebSerial = /*#__PURE__*/function () {
  /**
   * A BLE peripheral object.  It handles connecting, over Web Bluetooth API, to
   * BLE peripherals, and reading and writing data to them.
   * @param {Runtime} runtime - the Runtime for sending/receiving GUI update events.
   * @param {string} extensionId - the id of the extension using this object.
   * @param {object} peripheralOptions - the list of options for peripheral discovery.
   * @param {function} connectCallback - a callback for connection.
   * @param {function} resetCallback - a callback for resetting extension state.
   */
  function WebSerial(runtime, extensionId, peripheralOptions, connectCallback) {
    var resetCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

    _classCallCheck(this, WebSerial);

    /**
     * Remote device which have been connected.
     * @type {SerialPort}
     */
    this.port = null;
    this._connectCallback = connectCallback;
    this.state = 'init';
    this._resetCallback = resetCallback;
    this._extensionId = extensionId;
    this._peripheralOptions = peripheralOptions;
    this._serialOptions = {
      // baudRate: 57600
      baudRate: 115200 // Default for micro:bit

    };
    this._runtime = runtime;
    this.receivingInterval = 1;
    this.sendDataInterval = 10; // Time for receiving process in micro:bit

    /**
     * Store of received type and value for each characteristics.
     * @type {Object.<number, Object.<number, Uint8Array>>} - { ch: { type: value }}.
     */

    this.chValues = {};
    /**
     * Notification callbacks.
     * @type {Object.<number, function>} - { ch: callback }
     */

    this.notifyListeners = {};
    this.requestPeripheral();
  }
  /**
   * Request connection to the peripheral.
   * Request user to choose a device, and then connect it automatically.
   * @return {Promise} - a Promise which will resolved when a serial-port was selected.
   */


  _createClass(WebSerial, [{
    key: "requestPeripheral",
    value: function requestPeripheral() {
      var _this = this;

      var promise = Promise.resolve();

      if (this.isConnected()) {
        promise = promise.then(function () {
          return _this.disconnect();
        });
      }

      return promise.then(function () {
        navigator.serial.requestPort(_this._peripheralOptions).then(function (selected) {
          _this.port = selected;

          _this._runtime.connectPeripheral(_this._extensionId, null);
        }).catch(function (e) {
          _this._handleRequestError(e);
        });
      });
    }
    /**
     * Try connecting to the serial-port of the device, and then call the connect
     * callback when connection is successful.
     */

  }, {
    key: "connectPeripheral",
    value: function
      /* id */
    connectPeripheral() {
      var _this2 = this;

      if (!this.port) {
        throw new Error('device is not chosen');
      }

      var ChValueTransformer = /*#__PURE__*/function () {
        function ChValueTransformer() {
          _classCallCheck(this, ChValueTransformer);

          // A container for holding stream data until a new frame.
          this.chunks = [];
        }

        _createClass(ChValueTransformer, [{
          key: "transform",
          value: function transform(chunk, controller) {
            // Append new chunks to existing chunks.
            this.chunks = this.chunks.concat(Array.from(chunk)); // Split chunks into {ch: {type: value}.
            // Skip until SFD occurred

            var frameStart = this.chunks.findIndex(function (element) {
              return element === SFD;
            });

            if (frameStart === -1) {
              this.chunks = [];
              return;
            }

            this.chunks = this.chunks.slice(frameStart); // Read header

            if (this.chunks.length < 5) {
              return;
            }

            var type = this.chunks[1];

            if (type > ChResponse.NOTIFY) {
              this.chunks = []; // remove all until SFD + valid type

              return;
            }

            var ch = this.chunks[2] << 8 | this.chunks[3];
            var valueLength = this.chunks[4];
            var frameEnd = 5 + valueLength;

            if (this.chunks.length < frameEnd + 1) {
              return;
            }

            var value = this.chunks.slice(5, frameEnd); // Checksum

            var checksum = this.chunks.slice(0, frameEnd).reduce(function (acc, cur) {
              return acc + cur;
            }) % 0xFF;

            if (checksum === this.chunks[frameEnd]) {
              // Received successfully
              this.chunks.splice(0, frameEnd + 1);
              controller.enqueue({
                ch: ch,
                data: {
                  type: type,
                  value: value
                }
              });
            } else {
              // Error occurred
              // log.debug(this.chunks); // debug
              this.chunks.shift(); // Remove current SFD

              return;
            }
          }
        }, {
          key: "flush",
          value: function flush(controller) {
            // When the stream is closed, delete any remaining chunks.
            controller.terminate();
          }
        }]);

        return ChValueTransformer;
      }();

      this.port.open(this._serialOptions).then(function () {
        log.log("SerialPort: open");
        _this2.state = 'open';
        _this2.writer = _this2.port.writable.getWriter(); // eslint-disable-next-line no-undef

        var chValueTransformStream = new TransformStream(new ChValueTransformer());
        _this2.readableStreamClosed = _this2.port.readable.pipeTo(chValueTransformStream.writable);
        _this2.reader = chValueTransformStream.readable.getReader();

        _this2.port.addEventListener('disconnect', function (event) {
          _this2.onDisconnected(event);
        });

        _this2._runtime.emit(_this2._runtime.constructor.PERIPHERAL_CONNECTED);

        _this2._connectCallback();

        _this2.startReceiving();
      });
    }
    /**
     * Disconnect from the device and clean up.
     * Then emit the connection state by the runtime.
     * @return {Promise} - a Promise which will resolve when the serial-port was disconnected.
     */

  }, {
    key: "disconnect",
    value: function () {
      var _disconnect = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(this.state !== 'open')) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return");

              case 2:
                this.state = 'closing';
                this.stopReceiving();
                _context.next = 6;
                return this.reader.cancel();

              case 6:
                _context.next = 8;
                return this.readableStreamClosed.catch(function () {
                  /* Ignore the error */
                });

              case 8:
                this.writer.close();
                _context.next = 11;
                return this.writer.closed;

              case 11:
                _context.next = 13;
                return this.port.close();

              case 13:
                this.state = 'close';
                this.reader = null;
                this.writer = null;
                this.port = null;

                this._runtime.emit(this._runtime.constructor.PERIPHERAL_DISCONNECTED);

              case 18:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function disconnect() {
        return _disconnect.apply(this, arguments);
      }

      return disconnect;
    }()
    /**
     * @return {bool} whether the peripheral is connected.
     */

  }, {
    key: "isConnected",
    value: function isConnected() {
      return this.state === 'open';
    }
    /**
     * Receive data and process it.
     * @returns {Promise} - a Promise which will resolve when read next data
     */

  }, {
    key: "receiveData",
    value: function receiveData() {
      var _this3 = this;

      return this.reader.read().then(function (result) {
        var value = result.value,
            done = result.done;

        if (done) {
          _this3.reader.releaseLock();
        }

        if (value) {
          var data = value.data;
          var ch = value.ch;

          if (!_this3.chValues[ch]) {
            _this3.chValues[ch] = {};
          }

          _this3.chValues[ch][data.type] = data.value;

          if (data.type === ChResponse.NOTIFY) {
            if (ch in _this3.notifyListeners) {
              _this3.notifyListeners[ch](uint8ArrayToBase64$1(data.value));
            }
          } // log.debug({ch: ch, type: data.type, value: data.value});

        }
      });
    }
    /**
     * Start data receiving process.
     */

  }, {
    key: "startReceiving",
    value: function startReceiving() {
      var _this4 = this;

      this.dataReceiving = window.setTimeout(function () {
        if (_this4.state !== 'open') return;

        _this4.receiveData().then(function () {
          // start again
          _this4.startReceiving();
        }).catch(function () {
          _this4.handleDisconnectError();
        });
      }, this.receivingInterval);
    }
    /**
     * Stop data receiving process.
     */

  }, {
    key: "stopReceiving",
    value: function stopReceiving() {
      clearTimeout(this.dataReceiving);
      this.dataReceiving = null;
    }
    /**
     * Send data to the device.
     * @param {Uint8Array} data - data to send
     * @returns {Promise} - a Promise which will resolve write process was done
     */

  }, {
    key: "sendData",
    value: function sendData(data) {
      var _this5 = this;

      return this.writer.ready.then(function () {
        return _this5.writer.write(data);
      }).then(function () {
        return new Promise(function (resolve) {
          setTimeout(function () {
            return resolve();
          }, _this5.sendDataInterval); // Wait for receiving process in micro:bit
        });
      });
    }
    /**
     * Start receiving notifications from the device.
     * @param {number} _serviceId - the ble service to read. (ignore it for serial-port)
     * @param {number} characteristicId - the ble characteristic to get notifications from.
     * @param {function?} onCharacteristicChanged - callback for characteristic change notifications
     *  like function(base64message).
     * @return {Promise} - a Promise which will resolve when requested start notification.
     */

  }, {
    key: "startNotifications",
    value: function startNotifications(_serviceId, characteristicId) {
      var onCharacteristicChanged = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      // Connected device will start necessary notifications automatically on serial-port.
      this.notifyListeners[SERIAL_CH_ID[characteristicId]] = onCharacteristicChanged;
      return Promise.resolve();
    }
  }, {
    key: "readCh",
    value: function readCh(ch) {
      var _this6 = this;

      if (this.state !== 'open') {
        return Promise.reject(new Error('port is not opened'));
      }

      return new Promise(function (resolve) {
        var dataFrame = new Uint8Array(4);
        dataFrame[0] = SFD;
        dataFrame[1] = ChRequest.READ;
        dataFrame[2] = ch >> 8;
        dataFrame[3] = ch & 0xFF;

        if (_this6.chValues[ch]) {
          _this6.chValues[ch][ChResponse.READ] = null;
        }

        _this6.sendData(dataFrame).then(function () {
          var checkInterval = 10;

          var check = function check(count) {
            var received = _this6.chValues[ch];

            if (received && received[ChResponse.READ]) {
              return resolve({
                message: uint8ArrayToBase64$1(received[ChResponse.READ])
              });
            }

            count--;

            if (count === 0) {
              return resolve(null);
            }

            setTimeout(function () {
              check(count);
            }, checkInterval);
          };

          check(50);
        });
      });
    }
    /**
     * Read from the specified ble service.
     * @param {number} serviceId - the ble service to read.
     * @param {number} characteristicId - the ble characteristic to read.
     * @param {boolean} optStartNotifications - whether to start receiving characteristic change notifications.
     * @param {function} onCharacteristicChanged - callback for characteristic change notifications
     *  like function(base64message).
     * @return {Promise} - a Promise from the remote read request which resolve {message: base64string}.
     */

  }, {
    key: "read",
    value: function read(serviceId, characteristicId) {
      var _this7 = this;

      var optStartNotifications = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var onCharacteristicChanged = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var ch = SERIAL_CH_ID[characteristicId];
      var constantUpdatingCh = [0x0101,
      /* State */
      0x0102
      /* Motion */
      ];

      if (constantUpdatingCh.includes(ch)) {
        // Return already received values because rapid repeating requests will make the port freeze.
        if (!this.chValues[ch]) {
          return Promise.resolve(null);
        }

        return Promise.resolve({
          message: uint8ArrayToBase64$1(this.chValues[ch][ChResponse.READ])
        });
      }

      var readRetry = function readRetry(count) {
        return new Promise(function (resolve, reject) {
          if (count < 0) {
            reject(new Error("no response"));
            log.debug("read ch: ".concat(ch, " dose not response"));
            return;
          }

          _this7.readCh(ch).then(function (result) {
            if (result) {
              if (optStartNotifications) {
                _this7.startNotifications(serviceId, characteristicId, onCharacteristicChanged).then(function () {
                  return resolve(result);
                });

                return;
              }

              resolve(result);
              return;
            }

            count--;
            resolve(readRetry(count));
            return;
          }).catch(function (err) {
            resolve(null);
            log.debug(err);
            return;
          });
        });
      };

      return readRetry(2).catch(function (err) {
        log.debug(err);

        _this7.handleDisconnectError(err);

        return;
      });
    }
    /**
     * Write value on the characteristic.
     * @param {number} ch - characteristic to write
     * @param {Uint8Array} value - value to write
     * @param {boolean} withResponse - whether request response or not
     * @returns {Promise} - a Promise which will resolve true when success to write
     */

  }, {
    key: "writeCh",
    value: function writeCh(ch, value, withResponse) {
      var _this8 = this;

      if (this.state !== 'open') {
        return Promise.reject(new Error('port is not opened'));
      }

      return new Promise(function (resolve) {
        var header = new Uint8Array(5);
        header[0] = SFD;
        header[1] = withResponse ? ChRequest.WRITE_RESPONSE : ChRequest.WRITE;
        header[2] = ch >> 8;
        header[3] = ch & 0xFF;
        header[4] = value.length;
        var dataFrame = new Uint8Array([].concat(_toConsumableArray(header), _toConsumableArray(value), [0]));
        dataFrame[dataFrame.length - 1] = dataFrame.reduce(function (acc, cur) {
          return acc + cur;
        }) % 0xFF;

        if (withResponse) {
          _this8.sendData(dataFrame).then(function () {
            var checkInterval = 10;

            var check = function check(count) {
              var received = _this8.chValues[ch];

              if (received && received[ChResponse.WRITE_RESPONSE]) {
                return resolve(received[ChResponse.WRITE_RESPONSE][0] === 1);
              }

              count--;

              if (count === 0) {
                return resolve(false);
              }

              setTimeout(function () {
                check(count);
              }, checkInterval);
            };

            check(20);
          });
        } else {
          _this8.sendData(dataFrame).then(function () {
            return resolve(true);
          });
        }
      });
    }
    /**
     * Write data to the specified ble service.
     * @param {number} serviceId - the ble service to write.
     * @param {number} characteristicId - the ble characteristic to write.
     * @param {string} message - the message to send.
     * @param {string} encoding - the message encoding type.
     * @param {boolean} withResponse - if true, resolve after peripheral's response. Always true for serial port.
     * @return {Promise} - a Promise which will resolve true when success to write or reject with 'no response'
     */
    // eslint-disable-next-line no-unused-vars

  }, {
    key: "write",
    value: function write(serviceId, characteristicId, message) {
      var _this9 = this;

      var encoding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var withResponse = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      withResponse = false; // true for noise tolerance on serial-port.

      var value = encoding === 'base64' ? base64ToUint8Array$1(message) : message;
      var ch = SERIAL_CH_ID[characteristicId];

      if (this.chValues[ch]) {
        this.chValues[ch][ChResponse.WRITE_RESPONSE] = null;
      }

      var writeRetry = function writeRetry(count) {
        return new Promise(function (resolve, reject) {
          if (count < 0) {
            reject(new Error("no response"));
            log.debug("write ch: ".concat(ch, " dose not response"));
            return;
          }

          _this9.writeCh(ch, value, withResponse).then(function (result) {
            if (result) {
              resolve(result);
              return;
            }

            count--;
            resolve(writeRetry(count));
            return;
          }).catch(function (err) {
            resolve(null);
            log.debug(err);
            return;
          });
        });
      };

      return writeRetry(2).catch(function (err) {
        log.debug(err);

        _this9.handleDisconnectError(err);

        return;
      });
    }
    /**
     * Handle an error resulting from losing connection to a peripheral.
     *
     * This could be due to:
     * - battery depletion
     * - going out of bluetooth range
     * - being powered down
     *
     * Disconnect the device, and if the extension using this object has a
     * reset callback, call it. Finally, emit an error to the runtime.
     */

  }, {
    key: "handleDisconnectError",
    value: function
      /* e */
    handleDisconnectError() {
      var _this10 = this;

      if (this.state !== 'open') return;
      this.disconnect().then(function () {
        if (_this10._resetCallback) {
          _this10._resetCallback();
        }

        _this10._runtime.emit(_this10._runtime.constructor.PERIPHERAL_CONNECTION_LOST_ERROR, {
          message: "Scratch lost connection to",
          extensionId: _this10._extensionId
        });
      });
    }
  }, {
    key: "_handleRequestError",
    value: function
      /* e */
    _handleRequestError() {
      // log.error(`BLE error: ${JSON.stringify(e)}`);
      this._runtime.emit(this._runtime.constructor.PERIPHERAL_REQUEST_ERROR, {
        message: "Scratch lost connection to",
        extensionId: this._extensionId
      });
    }
    /**
     * Called when disconnected by the device.
     */

  }, {
    key: "onDisconnected",
    value: function
      /* event */
    onDisconnected() {
      this.handleDisconnectError(new Error('device disconnected'));
    }
  }]);

  return WebSerial;
}();

var serialWeb = WebSerial;

var uint8ArrayToBase64 = function uint8ArrayToBase64(array) {
  return window.btoa(String.fromCharCode.apply(String, _toConsumableArray(array)));
};

var base64ToUint8Array = function base64ToUint8Array(base64) {
  var raw = window.atob(base64);
  return Uint8Array.from(Array.prototype.map.call(raw, function (x) {
    return x.charCodeAt(0);
  }));
};

var formatMessage = function formatMessage(messageData) {
  return messageData.defaultMessage;
};
/**
 * Setup format-message for this extension.
 */


var setupTranslations = function setupTranslations() {
  var localeSetup = formatMessage.setup();

  if (localeSetup && localeSetup.translations[localeSetup.locale]) {
    Object.assign(localeSetup.translations[localeSetup.locale], translations[localeSetup.locale]);
  }
};

var EXTENSION_ID = 'microbitMore';
/**
 * URL to get this extension as a module.
 * When it was loaded as a module, 'extensionURL' will be replaced a URL which is retrieved from.
 * @type {string}
 */

var extensionURL = 'https://eu-rate-boson.github.io/dist/microbitMore.mjs';
/**
 * Enum for version of the hardware.
 * @readonly
 * @enum {number}
 */

var MbitMoreHardwareVersion = {
  MICROBIT_V1: 1,
  MICROBIT_V2: 2
};
/**
 * Communication route between Scratch and micro:bit
 *
 */

var CommunicationRoute = {
  BLE: 0,
  SERIAL: 1
};
/**
 * Enum for micro:bit BLE command protocol.
 * https://github.com/LLK/scratch-microbit-firmware/blob/master/protocol.md
 * @readonly
 * @enum {number}
 */

var BLECommand = {
  CMD_CONFIG: 0x00,
  CMD_PIN: 0x01,
  CMD_DISPLAY: 0x02,
  CMD_AUDIO: 0x03,
  CMD_DATA: 0x04
};
/**
 * Enum for command about gpio pins.
 * @readonly
 * @enum {number}
 */

var MbitMorePinCommand = {
  SET_OUTPUT: 0x01,
  SET_PWM: 0x02,
  SET_SERVO: 0x03,
  SET_PULL: 0x04,
  SET_EVENT: 0x05
};
/**
 * Enum for command about gpio pins.
 * @readonly
 * @enum {number}
 */

var MbitMoreDisplayCommand = {
  CLEAR: 0x00,
  TEXT: 0x01,
  PIXELS_0: 0x02,
  PIXELS_1: 0x03
};
/**
 * Enum for name of pull mode.
 * @readonly
 * @enum {number}
 */

var MbitMorePullModeName = {
  NONE: 'NONE',
  DOWN: 'DOWN',
  UP: 'UP'
};
/**
 * Enum for ID of pull mode.
 * @readonly
 * @enum {number}
 */

var MbitMorePullModeID = {
  NONE: 0,
  DOWN: 1,
  UP: 2
};
/**
 * Enum for data format.
 * @readonly
 * @enum {number}
 */

var MbitMoreDataFormat = {
  CONFIG: 0x10,
  // not used at this version
  PIN_EVENT: 0x11,
  ACTION_EVENT: 0x12,
  DATA_NUMBER: 0x13,
  DATA_TEXT: 0x14
};
/**
 * Enum for action event type.
 * @readonly
 * @enum {number}
 */

var MbitMoreActionEvent = {
  BUTTON: 0x01,
  GESTURE: 0x02
};
/**
 * Enum for ID of pin-mode
 * @readonly
 * @enum {string}
 */

var MbitMorePinMode = {
  INPUT: 'INPUT',
  OUTPUT: 'OUTPUT',
  PWM: 'PWM',
  SERVO: 'SERVO',
  TOUCH: 'TOUCH'
};
/**
 * Enum for ID of buttons
 * @readonly
 * @enum {string}
 */

var MbitMoreButtonName = {
  P0: 'P0',
  P1: 'P1',
  P2: 'P2',
  A: 'A',
  B: 'B',
  LOGO: 'LOGO'
};
/**
 * Enum for componentID of buttons
 * @readonly
 * @enum {string}
 */

var MbitMoreButtonID = {
  1: 'A',
  2: 'B',
  100: 'P0',
  101: 'P1',
  102: 'P2',
  121: 'LOGO'
};
/**
 * Enum for index of pin for buttons
 * @readonly
 * @enum {number}
 */

var MbitMoreButtonPinIndex = {
  P0: 0,
  P1: 1,
  P2: 2
};
/**
 * Enum for index in data of button state
 * @readonly
 * @enum {number}
 */

var MbitMoreButtonStateIndex = {
  P0: 0,
  P1: 1,
  P2: 2,
  A: 3,
  B: 4,
  LOGO: 5
};
/**
 * Enum for name of event from button
 * @readonly
 * @enum {string}
 */

var MbitMoreButtonEventName = {
  DOWN: 'DOWN',
  UP: 'UP',
  CLICK: 'CLICK',
  LONG_CLICK: 'LONG_CLICK',
  HOLD: 'HOLD',
  DOUBLE_CLICK: 'DOUBLE_CLICK'
};
/**
 * Enum for ID of event from button
 * @readonly
 * @enum {string}
 */

var MbitMoreButtonEventID = {
  1: 'DOWN',
  2: 'UP',
  3: 'CLICK',
  4: 'LONG_CLICK',
  5: 'HOLD',
  6: 'DOUBLE_CLICK'
};
/**
 * Enum for name of gesture.
 * @readonly
 * @enum {string}
 */

var MbitMoreGestureName = {
  TILT_UP: 'TILT_UP',
  TILT_DOWN: 'TILT_DOWN',
  TILT_LEFT: 'TILT_LEFT',
  TILT_RIGHT: 'TILT_RIGHT',
  FACE_UP: 'FACE_UP',
  FACE_DOWN: 'FACE_DOWN',
  FREEFALL: 'FREEFALL',
  G3: 'G3',
  G6: 'G6',
  G8: 'G8',
  SHAKE: 'SHAKE'
};
/**
 * Enum for ID of gesture.
 * @readonly
 * @enum {string}
 */

var MbitMoreGestureID = {
  1: 'TILT_UP',
  2: 'TILT_DOWN',
  3: 'TILT_LEFT',
  4: 'TILT_RIGHT',
  5: 'FACE_UP',
  6: 'FACE_DOWN',
  7: 'FREEFALL',
  8: 'G3',
  9: 'G6',
  10: 'G8',
  11: 'SHAKE'
};
/**
 * Enum for event type in the micro:bit runtime.
 * @readonly
 * @enum {number}
 */

var MbitMorePinEventType = {
  NONE: 0,
  ON_EDGE: 1,
  ON_PULSE: 2,
  ON_TOUCH: 3
};
/**
 * Enum for event value in the micro:bit runtime.
 * @readonly
 * @enum {number}
 */

var MbitMorePinEvent = {
  RISE: 2,
  FALL: 3,
  PULSE_HIGH: 4,
  PULSE_LOW: 5
};
/**
 * Enum for data type of data-sending.
 * @readonly
 * @enum {number}
 */

var MbitMoreSendingDataType = {
  NUMBER: 1,
  TEXT: 2
};
/**
 * Enum for sub-command about configurations.
 * @readonly
 * @enum {number}
 */

var MbitMoreConfig = {
  MIC: 0x01,
  TOUCH: 0x02
};
/**
 * Enum for sub-command about audio.
 * @readonly
 * @enum {number}
 */

var MbitMoreAudioCommand = {
  STOP_TONE: 0x00,
  PLAY_TONE: 0x01
};
/**
 * A time interval to wait (in milliseconds) before reporting to the BLE socket
 * that data has stopped coming from the peripheral.
 */

var BLETimeout = 4500;
/**
 * A string to report to the BLE socket when the micro:bit has stopped receiving data.
 * @type {string}
 */

var BLEDataStoppedError = 'micro:bit extension stopped receiving data';
var MM_SERVICE = {
  ID: '0b50f3e4-607f-4151-9091-7d008d6ffc5c',
  COMMAND_CH: '0b500100-607f-4151-9091-7d008d6ffc5c',
  STATE_CH: '0b500101-607f-4151-9091-7d008d6ffc5c',
  MOTION_CH: '0b500102-607f-4151-9091-7d008d6ffc5c',
  PIN_EVENT_CH: '0b500110-607f-4151-9091-7d008d6ffc5c',
  ACTION_EVENT_CH: '0b500111-607f-4151-9091-7d008d6ffc5c',
  ANALOG_IN_CH: ['0b500120-607f-4151-9091-7d008d6ffc5c', '0b500121-607f-4151-9091-7d008d6ffc5c', '0b500122-607f-4151-9091-7d008d6ffc5c'],
  MESSAGE_CH: '0b500130-607f-4151-9091-7d008d6ffc5c'
};
/**
 * Enum for axis menu options.
 * @readonly
 * @enum {string}
 */

var AxisSymbol = {
  X: 'x',
  Y: 'y',
  Z: 'z',
  Absolute: 'absolute'
};
/**
 * The unit-value of the gravitational acceleration from Micro:bit.
 * @type {number}
 */

var G = 1024;
/**
 * Manage communication with a MicroBit peripheral over a Scrath Link client socket.
 */

var MbitMore = /*#__PURE__*/function () {
  /**
   * Construct a MicroBit communication object.
   * @param {Runtime} runtime - the Scratch 3.0 runtime
   * @param {string} extensionId - the id of the extension
   */
  function MbitMore(runtime, extensionId) {
    var _this = this;

    _classCallCheck(this, MbitMore);

    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this.runtime = runtime;
    /**
     * The BluetoothLowEnergy connection socket for reading/writing peripheral data.
     * @type {BLE}
     * @private
     */

    this._ble = null;
    this.runtime.registerPeripheralExtension(extensionId, this);
    /**
     * The id of the extension this peripheral belongs to.
     */

    this._extensionId = extensionId;
    this.digitalLevel = {};
    this.lightLevel = 0;
    this.temperature = 0;
    this.soundLevel = 0;
    this.pitch = 0;
    this.roll = 0;
    this.acceleration = {
      x: 0,
      y: 0,
      z: 0
    };
    this.compassHeading = 0;
    this.magneticForce = {
      x: 0,
      y: 0,
      z: 0
    };
    this.buttonState = {};
    /**
     * The most recently received button events for each buttons.
     * @type {Object} - Store of buttons which has events.
     * @private
     */

    this.buttonEvents = {};
    Object.keys(MbitMoreButtonStateIndex).forEach(function (name) {
      _this.buttonEvents[name] = {};
    });
    /**
     * The most recently received gesture events.
     * @type {Object <number, number>} - Store of gesture ID and timestamp.
     * @private
     */

    this.gestureEvents = {};
    /**
     * The most recently received events for each pin.
     * @type {Object} - Store of pins which has events.
     * @private
     */

    this._pinEvents = {};
    /**
     * The most recently received data from micro:bit.
     * @type {Object} - Store of received data
     * @private
     */

    this.receivedData = {};
    this.analogIn = [0, 1, 2];
    this.analogValue = [];
    this.analogIn.forEach(function (pinIndex) {
      _this.analogValue[pinIndex] = 0;
    });
    this.gpio = [0, 1, 2, 8, 12, 13, 14, 15, 16];
    this.gpio.forEach(function (pinIndex) {
      _this.digitalLevel[pinIndex] = 0;
    });
    /**
     * Interval ID for data reading timeout.
     * @type {number}
     * @private
     */

    this._timeoutID = null;
    /**
     * A flag that is true while we are busy sending data to the BLE socket.
     * @type {boolean}
     * @private
     */

    this.bleBusy = true;
    /**
     * ID for a timeout which is used to clear the busy flag if it has been
     * true for a long time.
     */

    this.bleBusyTimeoutID = null;
    this.onDisconnect = this.onDisconnect.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this.onNotify = this.onNotify.bind(this);
    this.stopTone = this.stopTone.bind(this);

    if (this.runtime) {
      this.runtime.on('PROJECT_STOP_ALL', this.stopTone);
    }

    this.analogInUpdateInterval = 100; // milli-seconds

    this.analogInLastUpdated = [Date.now(), Date.now(), Date.now()];
    /**
     * A time interval to wait (in milliseconds) while a block that sends a BLE message is running.
     * @type {number}
     */

    this.sendCommandInterval = 30;
    this.initConfig(); // keyboard state monitor

    this.keyState = {};
    document.body.addEventListener('keydown', function (e) {
      _this.keyState[e.code] = {
        key: e.key,
        code: e.code,
        alt: e.altKey,
        ctrl: e.ctrlKey,
        meta: e.metaKey,
        shift: e.shiftKey
      };
    });
    document.body.addEventListener('keyup', function (e) {
      delete _this.keyState[e.code];
    });
  }
  /**
   * Initialize configuration of the micro:bit.
   */


  _createClass(MbitMore, [{
    key: "initConfig",
    value: function initConfig() {
      this.config = {};
      this.config.mic = false;
      this.config.pinMode = {};
    }
    /**
     * Start updating process for micro:bit state and motion.
     */

  }, {
    key: "startUpdater",
    value: function startUpdater() {
      var _this2 = this;

      if (this.updater) {
        clearTimeout(this.updater);
      }

      if (this.bleAccessWaiting) {
        this.updater = setTimeout(function () {
          return _this2.startUpdater();
        }, 0);
        return;
      }

      this.updateState().then(function () {
        return _this2.updateMotion();
      }).finally(function () {
        _this2.updater = setTimeout(function () {
          return _this2.startUpdater();
        }, _this2.microbitUpdateInterval);
      });
    }
    /**
     * Stop updating process for micro:bit state and motion.
     */

  }, {
    key: "stopUpdater",
    value: function stopUpdater() {
      clearTimeout(this.updater);
    }
    /**
     * @param {string} text - the text to display.
     * @param {number} delay - The time to delay between characters, in milliseconds.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */

  }, {
    key: "displayText",
    value: function displayText(text, delay, util) {
      var textLength = Math.min(18, text.length);
      var textData = new Uint8Array(textLength + 1);

      for (var i = 0; i < textLength; i++) {
        textData[i] = text.charCodeAt(i);
      }

      return this.sendCommandSet([{
        id: BLECommand.CMD_DISPLAY << 5 | MbitMoreDisplayCommand.TEXT,
        message: new Uint8Array([Math.min(255, Math.max(0, delay) / 10)].concat(_toConsumableArray(textData)))
      }], util);
    }
    /**
     * Send display pixcels command to micro:bit.
     * @param {Array.<Array.<number>>} matrix - pattern to display.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */

  }, {
    key: "displayPixels",
    value: function displayPixels(matrix, util) {
      var cmdSet = [{
        id: BLECommand.CMD_DISPLAY << 5 | MbitMoreDisplayCommand.PIXELS_0,
        message: new Uint8Array([].concat(_toConsumableArray(matrix[0]), _toConsumableArray(matrix[1]), _toConsumableArray(matrix[2])))
      }, {
        id: BLECommand.CMD_DISPLAY << 5 | MbitMoreDisplayCommand.PIXELS_1,
        message: new Uint8Array([].concat(_toConsumableArray(matrix[3]), _toConsumableArray(matrix[4])))
      }];
      return this.sendCommandSet(cmdSet, util);
    }
    /**
     * Set pull mode to the pin.
     * @param {number} pinIndex - index of the pin
     * @param {MbitMorePullModeID} pullMode - pull mode to set
     * @param {BlockUtility} util - utility object provided from the runtime
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */

  }, {
    key: "setPullMode",
    value: function setPullMode(pinIndex, pullMode, util) {
      this.config.pinMode[pinIndex] = MbitMorePinMode.INPUT;
      return this.sendCommandSet([{
        id: BLECommand.CMD_PIN << 5 | MbitMorePinCommand.SET_PULL,
        message: new Uint8Array([pinIndex, pullMode])
      }], util);
    }
    /**
     * Set pin to digital output mode on the level.
     * @param {number} pinIndex - Index of pin.
     * @param {boolean} level - Value in digital (true = High)
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */

  }, {
    key: "setPinOutput",
    value: function setPinOutput(pinIndex, level, util) {
      this.config.pinMode[pinIndex] = MbitMorePinMode.OUTPUT;
      return this.sendCommandSet([{
        id: BLECommand.CMD_PIN << 5 | MbitMorePinCommand.SET_OUTPUT,
        message: new Uint8Array([pinIndex, level ? 1 : 0])
      }], util);
    }
    /**
     * Set the pin to PWM mode on the level.
     * @param {number} pinIndex - index of the pin
     * @param {number} level - value of analog output [0..1024].
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */

  }, {
    key: "setPinPWM",
    value: function setPinPWM(pinIndex, level, util) {
      this.config.pinMode[pinIndex] = MbitMorePinMode.PWM;
      var dataView = new DataView(new ArrayBuffer(2));
      dataView.setUint16(0, level, true);
      return this.sendCommandSet([{
        id: BLECommand.CMD_PIN << 5 | MbitMorePinCommand.SET_PWM,
        message: new Uint8Array([pinIndex, dataView.getUint8(0), dataView.getUint8(1)])
      }], util);
    }
    /**
     * Set the pin to Servo mode on the angle in the range and center.
     * @param {number} pinIndex - index of the pin.
     * @param {number} angle - the level to set on the output pin, in the range 0 - 180.
     * @param {number} range - the span of possible values. '0' means default(2000).
     * @param {number} center - the center point from which to calculate the lower and upper bounds.
     *                          '0' means default(1500).
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */

  }, {
    key: "setPinServo",
    value: function setPinServo(pinIndex, angle, range, center, util) {
      this.config.pinMode[pinIndex] = MbitMorePinMode.SERVO;
      if (!range || range < 0) range = 0;
      if (!center || center < 0) center = 0;
      var dataView = new DataView(new ArrayBuffer(6));
      dataView.setUint16(0, angle, true);
      dataView.setUint16(2, range, true);
      dataView.setUint16(4, center, true);
      return this.sendCommandSet([{
        id: BLECommand.CMD_PIN << 5 | MbitMorePinCommand.SET_SERVO,
        message: new Uint8Array([pinIndex, dataView.getUint8(0), dataView.getUint8(1), dataView.getUint8(2), dataView.getUint8(3), dataView.getUint8(4), dataView.getUint8(5)])
      }], util);
    }
    /**
     * Read light level from the light sensor.
     * @param {object} util - utility object provided by the runtime.
     * @return {number} - value of the light level [0..255].
     */

  }, {
    key: "readLightLevel",
    value: function readLightLevel() {
      if (!this.isConnected()) {
        return 0;
      }

      return this.lightLevel;
    }
    /**
     * Update data of the analog input.
     * @param {number} pinIndex - index of the pin to get value.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves value of analog input or undefined if this process was yield.
     */

  }, {
    key: "readAnalogIn",
    value: function readAnalogIn(pinIndex, util) {
      var _this3 = this;

      if (!this.isConnected()) {
        return Promise.resolve(0);
      }

      if (Date.now() - this.analogInLastUpdated[pinIndex] < this.analogInUpdateInterval) {
        return Promise.resolve(this.analogValue[pinIndex]);
      }

      if (this.bleBusy) {
        this.bleAccessWaiting = true;
        if (util) util.yield(); // re-try this call after a while.

        return; // Do not return Promise.resolve() to re-try.
      }

      this.bleBusy = true;
      this.bleBusyTimeoutID = window.setTimeout(function () {
        _this3.bleBusy = false;
        _this3.bleAccessWaiting = false;
      }, 1000);
      return new Promise(function (resolve) {
        return _this3._ble.read(MM_SERVICE.ID, MM_SERVICE.ANALOG_IN_CH[pinIndex], false).then(function (result) {
          window.clearTimeout(_this3.bleBusyTimeoutID);
          _this3.bleBusy = false;
          _this3.bleAccessWaiting = false;

          if (!result) {
            return resolve(_this3.analogValue[pinIndex]);
          }

          var data = base64ToUint8Array(result.message);
          var dataView = new DataView(data.buffer, 0);
          _this3.analogValue[pinIndex] = dataView.getUint16(0, true);
          _this3.analogInLastUpdated = Date.now();
          resolve(_this3.analogValue[pinIndex]);
        });
      });
    }
    /**
     * Update data of digital level, light level, temperature, sound level.
     * @return {Promise} - a Promise that resolves updated data holder.
     */

  }, {
    key: "updateState",
    value: function updateState() {
      var _this4 = this;

      if (!this.isConnected()) return Promise.resolve(this);

      if (this.bleBusy) {
        return Promise.resolve(this);
      }

      this.bleBusy = true;
      this.bleBusyTimeoutID = window.setTimeout(function () {
        _this4.bleBusy = false;
      }, 1000);
      return new Promise(function (resolve) {
        _this4._ble.read(MM_SERVICE.ID, MM_SERVICE.STATE_CH, false).then(function (result) {
          window.clearTimeout(_this4.bleBusyTimeoutID);
          _this4.bleBusy = false;
          if (!result) return resolve(_this4);
          var data = base64ToUint8Array(result.message);
          var dataView = new DataView(data.buffer, 0); // Digital Input

          var gpioData = dataView.getUint32(0, true);

          for (var i = 0; i < _this4.gpio.length; i++) {
            _this4.digitalLevel[_this4.gpio[i]] = gpioData >> _this4.gpio[i] & 1;
          }

          Object.keys(MbitMoreButtonStateIndex).forEach(function (name) {
            _this4.buttonState[name] = gpioData >> 24 + MbitMoreButtonStateIndex[name] & 1;
          });
          _this4.lightLevel = dataView.getUint8(4);
          _this4.temperature = dataView.getUint8(5) - 128;
          _this4.soundLevel = dataView.getUint8(6);

          _this4.resetConnectionTimeout();

          resolve(_this4);
        });
      });
    }
    /**
     * Read temperature (integer in celsius) from the micro:bit cpu.
     * @return {number} - degrees of temperature [centigrade].
     */

  }, {
    key: "readTemperature",
    value: function readTemperature() {
      if (!this.isConnected()) {
        return 0;
      }

      return this.temperature;
    }
    /**
     * Configure microphone.
     * @param {boolean} use - true to use microphone.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} - a Promise that resolves state of the microphone or undefined if the process was yield.
     */

  }, {
    key: "configMic",
    value: function configMic(use, util) {
      var _this5 = this;

      use = use === true;

      if (!this.isConnected()) {
        return Promise.resolve(false);
      }

      if (this.config.mic === use) {
        return Promise.resolve(this.config.mic);
      }

      var sendPromise = this.sendCommandSet([{
        id: BLECommand.CMD_CONFIG << 5 | MbitMoreConfig.MIC,
        message: new Uint8Array([use ? 1 : 0]) // use microphone

      }], util);

      if (sendPromise) {
        return sendPromise.then(function () {
          _this5.config.mic = use;
          return _this5.config.mic;
        });
      }

      return;
    }
    /**
     * Play tone on the speaker.
     * @param {number} frequency - wave frequency to play [Hz]
     * @param {number} volume laudness of tone [%]
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} - a Promise that resolves to send command or undefined if this process was yield.
     */

  }, {
    key: "playTone",
    value: function playTone(frequency, volume, util) {
      if (!this.isConnected()) {
        return Promise.resolve();
      }

      var frequencyData = new DataView(new ArrayBuffer(4));
      frequencyData.setUint32(0, Math.round(1000000 / frequency), true);
      volume = Math.round(volume * 0xff / 100);
      return this.sendCommandSet([{
        id: BLECommand.CMD_AUDIO << 5 | MbitMoreAudioCommand.PLAY_TONE,
        message: new Uint8Array([frequencyData.getUint8(0), frequencyData.getUint8(1), frequencyData.getUint8(2), frequencyData.getUint8(3), volume])
      }], util);
    }
    /**
     * Stop playing tone on the speaker.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} - a Promise that resolves to send command or undefined if this process was yield.
     */

  }, {
    key: "stopTone",
    value: function stopTone(util) {
      if (!this.isConnected()) {
        return Promise.resolve();
      }

      return this.sendCommandSet([{
        id: BLECommand.CMD_AUDIO << 5 | MbitMoreAudioCommand.STOP_TONE,
        message: new Uint8Array([])
      }], util);
    }
    /**
     * Read sound level.
     * @return {number} - level of loudness (0 .. 255).
     */

  }, {
    key: "readSoundLevel",
    value: function readSoundLevel() {
      if (!this.isConnected()) {
        return 0;
      }

      return this.soundLevel;
    }
    /**
     * Update data of acceleration, magnetic force.
     * @return {Promise} - a Promise that resolves updated data holder.
     */

  }, {
    key: "updateMotion",
    value: function updateMotion() {
      var _this6 = this;

      if (!this.isConnected()) return Promise.resolve(this);

      if (this.bleBusy) {
        return Promise.resolve(this);
      }

      this.bleBusy = true;
      this.bleBusyTimeoutID = window.setTimeout(function () {
        _this6.bleBusy = false;
      }, 1000);
      return new Promise(function (resolve) {
        _this6._ble.read(MM_SERVICE.ID, MM_SERVICE.MOTION_CH, false).then(function (result) {
          window.clearTimeout(_this6.bleBusyTimeoutID);
          _this6.bleBusy = false;
          if (!result) return resolve(_this6);
          var data = base64ToUint8Array(result.message);
          var dataView = new DataView(data.buffer, 0); // Accelerometer

          _this6.pitch = Math.round(dataView.getInt16(0, true) * 180 / Math.PI / 1000);
          _this6.roll = Math.round(dataView.getInt16(2, true) * 180 / Math.PI / 1000);
          _this6.acceleration.x = 1000 * dataView.getInt16(4, true) / G;
          _this6.acceleration.y = 1000 * dataView.getInt16(6, true) / G;
          _this6.acceleration.z = 1000 * dataView.getInt16(8, true) / G; // Magnetometer

          _this6.compassHeading = dataView.getUint16(10, true);
          _this6.magneticForce.x = dataView.getInt16(12, true);
          _this6.magneticForce.y = dataView.getInt16(14, true);
          _this6.magneticForce.z = dataView.getInt16(16, true);

          _this6.resetConnectionTimeout();

          resolve(_this6);
        });
      });
    }
    /**
     * Read pitch [degrees] of the micro:bit heading direction.
     * @return {number} - degree of pitch.
     */

  }, {
    key: "readPitch",
    value: function readPitch() {
      if (!this.isConnected()) {
        return 0;
      }

      return this.pitch;
    }
    /**
     * Read roll [degrees] of the micro:bit heading direction.
     * @return {number} - degree of roll.
     */

  }, {
    key: "readRoll",
    value: function readRoll() {
      if (!this.isConnected()) {
        return 0;
      }

      return this.roll;
    }
    /**
     * Read the value of gravitational acceleration [milli-g] for the axis.
     * @param {AxisSymbol} axis - direction of acceleration.
     * @return {number} - value of acceleration.
     */

  }, {
    key: "readAcceleration",
    value: function readAcceleration(axis) {
      if (!this.isConnected()) {
        return 0;
      }

      if (axis === AxisSymbol.Absolute) {
        return Math.round(Math.sqrt(Math.pow(this.acceleration.x, 2) + Math.pow(this.acceleration.y, 2) + Math.pow(this.acceleration.z, 2)));
      }

      return this.acceleration[axis];
    }
    /**
     * Read the angle (degrees) of heading direction from the north.
     * @return {number} - degree of compass heading.
     */

  }, {
    key: "readCompassHeading",
    value: function readCompassHeading() {
      if (!this.isConnected()) {
        return 0;
      }

      return this.compassHeading;
    }
    /**
     * Read value of magnetic force [micro teslas] for the axis.
     * @param {AxisSymbol} axis - direction of magnetic force.
     * @return {number} - value of magnetic force.
     */

  }, {
    key: "readMagneticForce",
    value: function readMagneticForce(axis) {
      if (!this.isConnected()) {
        return 0;
      }

      if (axis === AxisSymbol.Absolute) {
        return Math.round(Math.sqrt(Math.pow(this.magneticForce.x, 2) + Math.pow(this.magneticForce.y, 2) + Math.pow(this.magneticForce.z, 2)));
      }

      return this.magneticForce[axis];
    }
    /**
     * Start to scan Bluetooth LE devices to find micro:bit with Boson service.
     */

  }, {
    key: "scanBLE",
    value: function scanBLE() {
      var connectorClass = ble;
      this._ble = new connectorClass(this.runtime, this._extensionId, {
        filters: [{
          namePrefix: 'BBC micro:bit'
        }, {
          services: [MM_SERVICE.ID]
        }]
      }, this._onConnect, this.onDisconnect);
    }
    /**
     * Start to scan USB serial devices to find micro:bit v2.
     */

  }, {
    key: "scanSerial",
    value: function scanSerial() {
      this._ble = new serialWeb(this.runtime, this._extensionId, {
        filters: [{
          usbVendorId: 0x0d28,
          usbProductId: 0x0204
        }]
      }, this._onConnect, this.onDisconnect);
    }
    /**
     * Whether the key is pressed at this moment.
     * @param {string} key - key in keyboard event
     * @returns {boolean} - return true when the key is pressed
     */

  }, {
    key: "isKeyPressing",
    value: function isKeyPressing(key) {
      return Object.values(this.keyState).find(function (state) {
        return state.key === key;
      });
    }
    /**
     * Called by the runtime when user wants to scan for a peripheral.
     */

  }, {
    key: "scan",
    value: function scan() {
      if (this._ble) {
        this._ble.disconnect();
      }

      this.bleBusy = true;

      if ('serial' in navigator && this.isKeyPressing('Shift')) {
        this.scanSerial();
      } else {
        this.scanBLE();
      } // The key state is cleared because the keyup event will be dropped by the browser dialog.


      this.keyState = {};
    }
    /**
     * Called by the runtime when user wants to connect to a certain peripheral.
     * @param {number} id - the id of the peripheral to connect to.
     */

  }, {
    key: "connect",
    value: function connect(id) {
      if (this._ble) {
        this._ble.connectPeripheral(id);
      }
    }
    /**
     * Disconnect from the micro:bit.
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      if (this._ble) {
        this._ble.disconnect();
      }

      this.onDisconnect();
    }
    /**
     * Reset all the state and timeout/interval ids.
     */

  }, {
    key: "onDisconnect",
    value: function onDisconnect() {
      this.stopUpdater();

      if (this._timeoutID) {
        window.clearTimeout(this._timeoutID);
        this._timeoutID = null;
      }
    }
    /**
     * Return true if connected to the micro:bit.
     * @return {boolean} - whether the micro:bit is connected.
     */

  }, {
    key: "isConnected",
    value: function isConnected() {
      var connected = false;

      if (this._ble) {
        connected = this._ble.isConnected();
      }

      return connected;
    }
    /**
     * Send a command to micro:bit.
     * @param {object} command command to send.
     * @param {number} command.id ID of the command.
     * @param {Uint8Array} command.message Contents of the command.
     * @return {Promise} a Promise that resolves when the data was sent and after send command interval.
     */

  }, {
    key: "sendCommand",
    value: function sendCommand(command) {
      var _this7 = this;

      var data = uint8ArrayToBase64(new Uint8Array([command.id].concat(_toConsumableArray(command.message))));
      return new Promise(function (resolve) {
        _this7._ble.write(MM_SERVICE.ID, MM_SERVICE.COMMAND_CH, data, 'base64', false);

        setTimeout(function () {
          return resolve();
        }, _this7.sendCommandInterval);
      });
    }
    /**
     * Send multiple commands sequentially.
     * @param {Array.<{id: number, message: Uint8Array}>} commands array of command.
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when the all commands was sent.
     */

  }, {
    key: "sendCommandSet",
    value: function sendCommandSet(commands, util) {
      var _this8 = this;

      if (!this.isConnected()) return Promise.resolve();

      if (this.bleBusy) {
        this.bleAccessWaiting = true;

        if (util) {
          util.yield(); // re-try this call after a while.
        } else {
          setTimeout(function () {
            return _this8.sendCommandSet(commands, util);
          }, 1);
        }

        return; // Do not return Promise.resolve() to re-try.
      }

      this.bleBusy = true; // Clear busy and BLE access waiting flag when the scratch-link does not respond.

      this.bleBusyTimeoutID = window.setTimeout(function () {
        _this8.bleBusy = false;
        _this8.bleAccessWaiting = false;
      }, 1000);
      return new Promise(function (resolve) {
        commands.reduce(function (acc, cur) {
          return acc.then(function () {
            return _this8.sendCommand(cur);
          });
        }, Promise.resolve()).then(function () {
          window.clearTimeout(_this8.bleBusyTimeoutID);
        }).catch(function (err) {
          log$2.log(err);

          _this8._ble.handleDisconnectError(err);
        }).finally(function () {
          _this8.bleBusy = false;
          _this8.bleAccessWaiting = false;
          resolve();
        });
      });
    }
    /**
     * Starts reading data from peripheral after BLE has connected to it.
     */

  }, {
    key: "_onConnect",
    value: function _onConnect() {
      var _this9 = this;

      this._ble.read(MM_SERVICE.ID, MM_SERVICE.COMMAND_CH, false).then(function (result) {
        if (!result) {
          throw new Error('Config is not readable');
        }

        var data = base64ToUint8Array(result.message);
        var dataView = new DataView(data.buffer, 0);
        _this9.hardware = dataView.getUint8(0);
        _this9.protocol = dataView.getUint8(1);
        _this9.route = dataView.getUint8(2);

        _this9._ble.startNotifications(MM_SERVICE.ID, MM_SERVICE.ACTION_EVENT_CH, _this9.onNotify);

        _this9._ble.startNotifications(MM_SERVICE.ID, MM_SERVICE.PIN_EVENT_CH, _this9.onNotify);

        if (_this9.hardware === MbitMoreHardwareVersion.MICROBIT_V1) {
          _this9.microbitUpdateInterval = 100; // milliseconds
        } else {
          _this9._ble.startNotifications(MM_SERVICE.ID, MM_SERVICE.MESSAGE_CH, _this9.onNotify);

          _this9.microbitUpdateInterval = 50; // milliseconds
        }

        if (_this9.route === CommunicationRoute.SERIAL) {
          _this9.sendCommandInterval = 100; // milliseconds
        } else {
          _this9.sendCommandInterval = 30; // milliseconds
        }

        _this9.initConfig();

        _this9.bleBusy = false;

        _this9.startUpdater();

        _this9.resetConnectionTimeout();
      }).catch(function (err) {
        return _this9._ble.handleDisconnectError(err);
      });
    }
    /**
     * Process the data from the incoming BLE characteristic.
     * @param {string} msg - the incoming BLE data.
     * @private
     */

  }, {
    key: "onNotify",
    value: function onNotify(msg) {
      var data = base64ToUint8Array(msg);
      var dataView = new DataView(data.buffer, 0);
      var dataFormat = dataView.getUint8(19);

      if (dataFormat === MbitMoreDataFormat.ACTION_EVENT) {
        var actionEventType = dataView.getUint8(0);

        if (actionEventType === MbitMoreActionEvent.BUTTON) {
          var buttonName = MbitMoreButtonID[dataView.getUint16(1, true)];
          var eventName = MbitMoreButtonEventID[dataView.getUint8(3)];
          this.buttonEvents[buttonName][eventName] = dataView.getUint32(4, true); // Timestamp
        } else if (actionEventType === MbitMoreActionEvent.GESTURE) {
          var gestureName = MbitMoreGestureID[dataView.getUint8(1)];
          this.gestureEvents[gestureName] = dataView.getUint32(2, true); // Timestamp
        }
      } else if (dataFormat === MbitMoreDataFormat.PIN_EVENT) {
        var pinIndex = dataView.getUint8(0);

        if (!this._pinEvents[pinIndex]) {
          this._pinEvents[pinIndex] = {};
        }

        var event = dataView.getUint8(1);
        this._pinEvents[pinIndex][event] = {
          value: dataView.getUint32(2, true),
          // timesamp of the edge or duration of the pulse
          timestamp: Date.now() // received time

        };
      } else if (dataFormat === MbitMoreDataFormat.DATA_NUMBER) {
        var label = new TextDecoder().decode(data.slice(0, 8).filter(function (char) {
          return char !== 0;
        }));
        this.receivedData[label] = {
          content: dataView.getFloat32(8, true),
          timestamp: Date.now()
        };
      } else if (dataFormat === MbitMoreDataFormat.DATA_TEXT) {
        var _label = new TextDecoder().decode(data.slice(0, 8).filter(function (char) {
          return char !== 0;
        }));

        this.receivedData[_label] = {
          content: new TextDecoder().decode(data.slice(8, 20).filter(function (char) {
            return char !== 0;
          })),
          timestamp: Date.now()
        };
      }

      this.resetConnectionTimeout();
    }
    /**
     * Cancel disconnect timeout and start counting again.
     */

  }, {
    key: "resetConnectionTimeout",
    value: function resetConnectionTimeout() {
      var _this10 = this;

      if (this._timeoutID) window.clearTimeout(this._timeoutID);
      this._timeoutID = window.setTimeout(function () {
        return _this10._ble.handleDisconnectError(BLEDataStoppedError);
      }, BLETimeout);
    }
    /**
     * Return whether the pin value is high.
     * @param {number} pin - the pin to check.
     * @param {number} threshold - the analog value threshold to surpass.
     * @param {object} util - utility object provided by the runtime.
     * @return {boolean} - whether the pin is high or not.
     */

  }, {
    key: "isPinAfterThreshold",
    value: function isPinAfterThreshold(pin, threshold, util) {
      
      if (threshold<0) {threshold = 0;}
      else if (threshold>100) {threshold = 100;}

      return this.getAnalogValue(pin, util) >= threshold;
    }
    /**
     * Return whether the pin value is high.
     * @param {number} pin - the pin to check.
     * @return {boolean} - whether the pin is high or not.
     */

  }, {
    key: "isPinHigh",
    value: function isPinHigh(pin) {
      var level = this.readDigitalLevel(pin);
      return level === 1;
    }
    /**
     * Read digital input from the pin.
     * @param {number} pin - the pin to read.
     * @return {number} - digital input value of the pin [0|1].
     */

  }, {
    key: "readDigitalLevel",
    value: function readDigitalLevel(pin) {
      if (!this.isConnected()) {
        return 0;
      }

      return this.digitalLevel[pin];
    }
    /**
     * Return whether the button is pressed.
     * @param {string} buttonName - name of the button
     * @return {boolean} - true when it is pressed
     */

  }, {
    key: "isButtonPressed",
    value: function isButtonPressed(buttonName) {
      if (!this.isConnected()) {
        return false;
      }

      return this.buttonState[buttonName] === 1;
    }
    /**
     * Return whether the pin is touch-mode.
     * @param {number} pinIndex - indesx of the pin
     * @return {boolean} - true when it is touch-mode
     */

  }, {
    key: "isPinTouchMode",
    value: function isPinTouchMode(pinIndex) {
      return this.config.pinMode[pinIndex] === MbitMorePinMode.TOUCH;
    }
    /**
     * Configurate touch mode of the pin.
     * @param {number} pinIndex - index of the pin as a button.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} - a Promise that resolves when configured or undefined if the process was yield.
     */

  }, {
    key: "configTouchPin",
    value: function configTouchPin(pinIndex, util) {
      var _this11 = this;

      if (!this.isConnected()) {
        return Promise.resolve();
      }

      if (this.isPinTouchMode(pinIndex)) {
        return Promise.resolve();
      }

      var sendPromise = this.sendCommandSet([{
        id: BLECommand.CMD_CONFIG << 5 | MbitMoreConfig.TOUCH,
        message: new Uint8Array([pinIndex, 1])
      }], util);

      if (sendPromise) {
        return sendPromise.then(function () {
          _this11.config.pinMode[pinIndex] = MbitMorePinMode.TOUCH;
        });
      }

      return;
    }
    /**
     * Return whether the touche-pin is touched.
     * @param {string} buttonName - ID to check.
     * @return {boolean} - whether the id is high or not.
     */

  }, {
    key: "isTouched",
    value: function isTouched(buttonName) {
      if (!this.isConnected()) {
        return false;
      }

      return this.buttonState[buttonName] === 1;
    }
    /**
     * Return the last timestamp of the button event or undefined if the event is not received.
     * @param {MbitMoreButtonName} buttonName - name of the button to get the event.
     * @param {MbitMoreButtonEventName} eventName - name of event to get.
     * @return {?number} Timestamp of the last event or null.
     */

  }, {
    key: "getButtonEventTimestamp",
    value: function getButtonEventTimestamp(buttonName, eventName) {
      if (this.buttonEvents[buttonName] && this.buttonEvents[buttonName][eventName]) {
        return this.buttonEvents[buttonName][eventName];
      }

      return null;
    }
    /**
     * Return the last timestamp of the gesture event or undefined if the event is not received.
     * @param {MbitMoreGestureName} gestureName - name of the event.
     * @return {?number} Timestamp of the last event or null.
     */

  }, {
    key: "getGestureEventTimestamp",
    value: function getGestureEventTimestamp(gestureName) {
      if (this.gestureEvents[gestureName]) {
        return this.gestureEvents[gestureName];
      }

      return null;
    }
    /**
     * Return the last value of the pin event or undefined if the event was not received.
     * @param {number} pinIndex - index of the pin to get the event.
     * @param {MbitMorePinEvent} event - event to get.
     * @return {?number} Timestamp of the last event or null.
     */

  }, {
    key: "getPinEventValue",
    value: function getPinEventValue(pinIndex, event) {
      if (this._pinEvents[pinIndex] && this._pinEvents[pinIndex][event]) {
        return this._pinEvents[pinIndex][event].value;
      }

      return null;
    }
    /**
     * Return the last timestamp of the pin event or undefined if the event was not received.
     * @param {number} pinIndex - index of the pin to get the event.
     * @param {MbitMorePinEvent} event - event to get.
     * @return {?number} Timestamp of the last event or null.
     */

  }, {
    key: "getPinEventTimestamp",
    value: function getPinEventTimestamp(pinIndex, event) {
      if (this._pinEvents[pinIndex] && this._pinEvents[pinIndex][event]) {
        return this._pinEvents[pinIndex][event].timestamp;
      }

      return null;
    }
    /**
     * Set event type to be get from the pin.
     * @param {number} pinIndex - Index of the pin to set.
     * @param {MbitMorePinEventType} eventType - Event type to set.
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */

  }, {
    key: "listenPinEventType",
    value: function listenPinEventType(pinIndex, eventType, util) {
      return this.sendCommandSet([{
        id: BLECommand.CMD_PIN << 5 | MbitMorePinCommand.SET_EVENT,
        message: new Uint8Array([pinIndex, eventType])
      }], util);
    }
    /**
     * Send data to micro:bit.
     * @param {string} label - label of the data [ascii]
     * @param {string} content - content of the data [ascii | number]
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when sending done or undefined if this process was yield.
     */

  }, {
    key: "sendData",
    value: function sendData(label, content, util) {
      var labelData = new Array(8).fill().map(function (_value, index) {
        return label.charCodeAt(index);
      });
      var contentNumber = Number(content);
      var contentData;
      var type;

      if (Number.isNaN(contentNumber)) {
        type = MbitMoreSendingDataType.TEXT;
        contentData = content.split('').map(function (ascii) {
          return ascii.charCodeAt(0);
        }).slice(0, 11);
      } else {
        type = MbitMoreSendingDataType.NUMBER;
        var dataView = new DataView(new ArrayBuffer(4));
        dataView.setFloat32(0, contentNumber, true);
        contentData = [dataView.getUint8(0), dataView.getUint8(1), dataView.getUint8(2), dataView.getUint8(3)];
      }

      return this.sendCommandSet([{
        id: BLECommand.CMD_DATA << 5 | type,
        message: new Uint8Array([].concat(_toConsumableArray(labelData), _toConsumableArray(contentData)))
      }], util);
    }
    /**
     * Return the last data with the label or undefined if no data received with the label.
     * @param {string} label - label to get.
     * @return {?(number | string)} data of the label or null.
     */

  }, {
    key: "getDataLabeled",
    value: function getDataLabeled(label) {
      if (this.receivedData[label]) {
        return this.receivedData[label].content;
      }

      return null;
    }
    /**
     * Return the last timestamp of the data or undefined if the data is not received.
     * @param {string} label - label of the data.
     * @return {?number} Timestamp of the last data or null.
     */

  }, {
    key: "getDataTimestamp",
    value: function getDataTimestamp(label) {
      if (this.receivedData[label]) {
        return this.receivedData[label].timestamp;
      }

      return null;
    }
  }]);

  return MbitMore;
}();
/**
 * Scratch 3.0 blocks to interact with a MicroBit peripheral.
 */


var MbitMoreBlocks = /*#__PURE__*/function () {
  /**
   * Construct a set of MicroBit blocks.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */
  function MbitMoreBlocks(runtime) {
    _classCallCheck(this, MbitMoreBlocks);

    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime;

    if (runtime.formatMessage) {
      // Replace 'formatMessage' to a formatter which is used in the runtime.
      formatMessage = runtime.formatMessage;
    } // Create a new MicroBit peripheral instance


    this._peripheral = new MbitMore(this.runtime, MbitMoreBlocks.EXTENSION_ID);
    /**
     * The previous timestamps of button events.
     * @type {Object.<number, Object.<number, number>>} button ID to object with event and timestamp.
     */

    this.prevButtonEvents = {};
    /**
     * The previous timestamps of gesture events.
     * @type {Object.<number, number>} key: event ID, value: timestamp.
     */

    this.prevGestureEvents = {};
    /**
     * The previous timestamps of pin events.
     * @type {Object.<number, Object.<number, number>>} pin index to object with event and timestamp.
     */

    this.prevPinEvents = {};
    /**
     * The previous timestamps of messages.
     * @type {Object.<number, Object>} pin index to object with event and timestamp.
     */

    this.prevReceivedData = {};
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  _createClass(MbitMoreBlocks, [{
    key: "GESTURES_MENU",
    get:
    /**
     * @return {array} - text and values for each gestures menu element
     */
    function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.tiltUp',
          default: 'titl up',
          description: 'label for tilt up gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.TILT_UP
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.tiltDown',
          default: 'titl down',
          description: 'label for tilt down gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.TILT_DOWN
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.tiltLeft',
          default: 'titl left',
          description: 'label for tilt left gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.TILT_LEFT
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.tiltRight',
          default: 'titl right',
          description: 'label for tilt right gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.TILT_RIGHT
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.faceUp',
          default: 'face up',
          description: 'label for face up gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.FACE_UP
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.faceDown',
          default: 'face down',
          description: 'label for face down gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.FACE_DOWN
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.freefall',
          default: 'freefall',
          description: 'label for freefall gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.FREEFALL
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.g3',
          default: '3G',
          description: 'label for 3G gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.G3
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.g6',
          default: '6G',
          description: 'label for 6G gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.G6
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.g8',
          default: '8G',
          description: 'label for 3G gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.G8
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.shake',
          default: 'shake',
          description: 'label for shaken gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.SHAKE
      }];
    }
    /**
     * @return {array} - text and values for each buttons menu element
     */

  }, {
    key: "BUTTON_ID_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.buttonIDMenu.a',
          default: 'A',
          description: 'label for "A" element in button picker for Boson extension'
        }),
        value: MbitMoreButtonName.A
      }, {
        text: formatMessage({
          id: 'mbitMore.buttonIDMenu.b',
          default: 'B',
          description: 'label for "B" element in button picker for Boson extension'
        }),
        value: MbitMoreButtonName.B
      }];
    }
    /**
     * @return {array} - Menu items for button event selector.
     */

  }, {
    key: "BUTTON_EVENT_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.buttonEventMenu.down',
          default: 'down',
          description: 'label for button down event'
        }),
        value: MbitMoreButtonEventName.DOWN
      }, {
        text: formatMessage({
          id: 'mbitMore.buttonEventMenu.up',
          default: 'up',
          description: 'label for button up event'
        }),
        value: MbitMoreButtonEventName.UP
      }, {
        text: formatMessage({
          id: 'mbitMore.buttonEventMenu.click',
          default: 'click',
          description: 'label for button click event'
        }),
        value: MbitMoreButtonEventName.CLICK // },
        // // These events are not in use because they are unstable in coal-microbit-v2.
        // {
        //     text: formatMessage({
        //         id: 'mbitMore.buttonEventMenu.hold',
        //         default: 'hold',
        //         description: 'label for button hold event'
        //     }),
        //     value: MbitMoreButtonEventName.HOLD
        // },
        // {
        //     text: formatMessage({
        //         id: 'mbitMore.buttonEventMenu.longClick',
        //         default: 'long click',
        //         description: 'label for button long click event'
        //     }),
        //     value: MbitMoreButtonEventName.LONG_CLICK
        // },
        // {
        //     text: formatMessage({
        //         id: 'mbitMore.buttonEventMenu.doubleClick',
        //         default: 'double click',
        //         description: 'label for button double click event'
        //     }),
        //     value: MbitMoreButtonEventName.DOUBLE_CLICK

      }];
    }
    /**
     * @return {array} - text and values for each buttons menu element
     */

  }, {
    key: "TOUCH_ID_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.touchIDMenu.logo',
          default: 'LOGO',
          description: 'label for "LOGO" element in touch button picker for Boson extension'
        }),
        value: MbitMoreButtonName.LOGO
      }, {
        text: 'P0',
        value: MbitMoreButtonName.P0
      }, {
        text: 'P1',
        value: MbitMoreButtonName.P1
      }, {
        text: 'P2',
        value: MbitMoreButtonName.P2
      }];
    }
    /**
     * @return {array} - Menu items for touch event selector.
     */

  }, {
    key: "TOUCH_EVENT_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.touchEventMenu.touched',
          default: 'touched',
          description: 'label for touched event'
        }),
        value: MbitMoreButtonEventName.DOWN
      }, {
        text: formatMessage({
          id: 'mbitMore.touchEventMenu.released',
          default: 'released',
          description: 'label for released event'
        }),
        value: MbitMoreButtonEventName.UP
      }, {
        text: formatMessage({
          id: 'mbitMore.touchEventMenu.tapped',
          default: 'tapped',
          description: 'label for tapped event'
        }),
        value: MbitMoreButtonEventName.CLICK // },
        // // These events are not in use because they are unstable in coal-microbit-v2.
        // {
        //     text: formatMessage({
        //         id: 'mbitMore.touchEventMenu.hold',
        //         default: 'hold',
        //         description: 'label for hold event in touch'
        //     }),
        //     value: MbitMoreButtonEventName.HOLD
        // },
        // {
        //     text: formatMessage({
        //         id: 'mbitMore.touchEventMenu.longTapped',
        //         default: 'long tapped',
        //         description: 'label for long click event in touch'
        //     }),
        //     value: MbitMoreButtonEventName.LONG_CLICK
        // },
        // {
        //     text: formatMessage({
        //         id: 'mbitMore.touchEventMenu.doubleTapped',
        //         default: 'double tapped',
        //         description: 'label for double click event in touch'
        //     }),
        //     value: MbitMoreButtonEventName.DOUBLE_CLICK

      }];
    }
  }, {
    key: "ANALOG_IN_PINS_MENU",
    get: function get() {
      return this._peripheral.analogIn.map(function (pinIndex) {
        return Object.create({
          text: "P".concat(pinIndex.toString()),
          value: pinIndex.toString()
        });
      });
    }
  }, {
    key: "GPIO_MENU",
    get: function get() {
      return this._peripheral.gpio.map(function (pinIndex) {
        return Object.create({
          text: "P".concat(pinIndex.toString()),
          value: pinIndex.toString()
        });
      });
    }
  }, {
    key: "DIGITAL_VALUE_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.digitalValueMenu.Low',
          default: 'Low',
          description: 'label for low value in digital output menu for Boson extension'
        }),
        value: 'false'
      }, {
        text: formatMessage({
          id: 'mbitMore.digitalValueMenu.High',
          default: 'High',
          description: 'label for high value in digital output menu for Boson extension'
        }),
        value: 'true'
      }];
    }
  }, {
    key: "AXIS_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.axisMenu.x',
          default: 'x',
          description: 'label of X axis.'
        }),
        value: AxisSymbol.X
      }, {
        text: formatMessage({
          id: 'mbitMore.axisMenu.y',
          default: 'y',
          description: 'label of Y axis.'
        }),
        value: AxisSymbol.Y
      }, {
        text: formatMessage({
          id: 'mbitMore.axisMenu.z',
          default: 'z',
          description: 'label of Z axis.'
        }),
        value: AxisSymbol.Z
      }, {
        text: formatMessage({
          id: 'mbitMore.axisMenu.absolute',
          default: 'absolute',
          description: 'label of absolute value.'
        }),
        value: AxisSymbol.Absolute
      }];
    }
    /**
     * @return {array} - text and values for each pin mode menu element
     */

  }, {
    key: "PIN_MODE_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.pinModeMenu.pullNone',
          default: 'pull none',
          description: 'label for pullNone mode'
        }),
        value: MbitMorePullModeName.NONE
      }, {
        text: formatMessage({
          id: 'mbitMore.pinModeMenu.pullUp',
          default: 'pull up',
          description: 'label for pullUp mode'
        }),
        value: MbitMorePullModeName.UP
      }, {
        text: formatMessage({
          id: 'mbitMore.pinModeMenu.pullDown',
          default: 'pull down',
          description: 'label for pullDown mode'
        }),
        value: MbitMorePullModeName.DOWN
      }];
    }
    /**
     * @return {array} - Menu items for event selector.
     */

  }, {
    key: "PIN_EVENT_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.pinEventMenu.pulseLow',
          default: 'low pulse',
          description: 'label for low pulse event'
        }),
        value: 'PULSE_LOW'
      }, {
        text: formatMessage({
          id: 'mbitMore.pinEventMenu.pulseHigh',
          default: 'high pulse',
          description: 'label for high pulse event'
        }),
        value: 'PULSE_HIGH'
      }, {
        text: formatMessage({
          id: 'mbitMore.pinEventMenu.fall',
          default: 'fall',
          description: 'label for fall event'
        }),
        value: 'FALL'
      }, {
        text: formatMessage({
          id: 'mbitMore.pinEventMenu.rise',
          default: 'rise',
          description: 'label for rise event'
        }),
        value: 'RISE'
      }];
    }
    /**
     * @return {array} - Menu items for event selector.
     */

  }, {
    key: "PIN_EVENT_TIMESTAMP_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.pinEventTimestampMenu.pulseLow',
          default: 'low pulse',
          description: 'label for low pulse event'
        }),
        value: 'PULSE_LOW'
      }, {
        text: formatMessage({
          id: 'mbitMore.pinEventTimestampMenu.pulseHigh',
          default: 'high pulse',
          description: 'label for high pulse event'
        }),
        value: 'PULSE_HIGH'
      }, {
        text: formatMessage({
          id: 'mbitMore.pinEventTimestampMenu.fall',
          default: 'fall',
          description: 'label for fall event'
        }),
        value: 'FALL'
      }, {
        text: formatMessage({
          id: 'mbitMore.pinEventTimestampMenu.rise',
          default: 'rise',
          description: 'label for rise event'
        }),
        value: 'RISE'
      }];
    }
    /**
     * @return {array} - Menu items for event listening.
     */

  }, {
    key: "PIN_EVENT_TYPE_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.pinEventTypeMenu.none',
          default: 'none',
          description: 'label for remove event listener'
        }),
        value: 'NONE'
      }, {
        text: formatMessage({
          id: 'mbitMore.pinEventTypeMenu.pulse',
          default: 'pulse',
          description: 'label for pulse event type'
        }),
        value: 'ON_PULSE'
      }, {
        text: formatMessage({
          id: 'mbitMore.pinEventTypeMenu.edge',
          default: 'edge',
          description: 'label for edge event type'
        }),
        value: 'ON_EDGE'
      }];
    }
    /**
     * @return {array} - Menu items for connection state.
     */

  }, {
    key: "CONNECTION_STATE_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.connectionStateMenu.connected',
          default: 'connected',
          description: 'label for connected'
        }),
        value: 'connected'
      }, {
        text: formatMessage({
          id: 'mbitMore.connectionStateMenu.disconnected',
          default: 'disconnected',
          description: 'label for disconnected'
        }),
        value: 'disconnected'
      }];
    }
  },{
    key: "IMPLEMENTATIONS_MENU ",
    get: function get() {
        return [
            {
                text: formatMessage({
                    id: 'mbitMore.implementationsMenu.neopixel',
                    default: 'NeoPixel LEDs',
                    description: 'label for NeoPixel LEDs'
                }),
                value: 'neopixel'
            }
        ];
    }
  }, {
    key: "getInfo",
    value: function getInfo() {
      setupTranslations();
      return {
        id: MbitMoreBlocks.EXTENSION_ID,
        name: MbitMoreBlocks.EXTENSION_NAME,
        extensionURL: MbitMoreBlocks.extensionURL,
        blockIconURI: img,
        showStatusButton: true,
        blocks: [{
          opcode: 'whenConnectionChanged',
          text: formatMessage({
            id: 'mbitMore.whenConnectionChanged',
            default: 'when micro:bit [STATE]',
            description: 'when a micro:bit connection state changed'
          }),
          blockType: blockType.HAT,
          arguments: {
            STATE: {
              type: argumentType.STRING,
              menu: 'connectionStateMenu',
              defaultValue: 'connected'
            }
          }
        }, '---', {
          opcode: 'whenButtonEvent',
          text: formatMessage({
            id: 'mbitMore.whenButtonEvent',
            default: 'when button [NAME] is [EVENT]',
            description: 'when the selected button on the micro:bit get the selected event'
          }),
          blockType: blockType.HAT,
          arguments: {
            NAME: {
              type: argumentType.STRING,
              menu: 'buttonIDMenu',
              defaultValue: MbitMoreButtonName.A
            },
            EVENT: {
              type: argumentType.STRING,
              menu: 'buttonEventMenu',
              defaultValue: MbitMoreButtonEventName.DOWN
            }
          }
        }, {
          opcode: 'isButtonPressed',
          text: formatMessage({
            id: 'mbitMore.isButtonPressed',
            default: 'button [NAME] pressed?',
            description: 'is the selected button on the micro:bit pressed?'
          }),
          blockType: blockType.BOOLEAN,
          arguments: {
            NAME: {
              type: argumentType.STRING,
              menu: 'buttonIDMenu',
              defaultValue: MbitMoreButtonName.A
            }
          }
        }, {
          opcode: 'whenTouchEvent',
          text: formatMessage({
            id: 'mbitMore.whenTouchEvent',
            default: 'when pin [NAME] is [EVENT]',
            description: 'when the selected touch pin on the micro:bit is touched'
          }),
          blockType: blockType.HAT,
          arguments: {
            NAME: {
              type: argumentType.STRING,
              menu: 'touchIDMenu',
              defaultValue: MbitMoreButtonName.LOGO
            },
            EVENT: {
              type: argumentType.STRING,
              menu: 'touchEventMenu',
              defaultValue: MbitMoreButtonEventName.DOWN
            }
          }
        }, {
          opcode: 'isPinTouched',
          text: formatMessage({
            id: 'mbitMore.isPinTouched',
            default: 'pin [NAME] is touched?',
            description: 'is the selected pin is touched?'
          }),
          blockType: blockType.BOOLEAN,
          arguments: {
            NAME: {
              type: argumentType.STRING,
              menu: 'touchIDMenu',
              defaultValue: MbitMoreButtonName.LOGO
            }
          }
        }, '---', {
          opcode: 'whenGesture',
          text: formatMessage({
            id: 'mbitMore.whenGesture',
            default: 'when [GESTURE]',
            description: 'when the selected gesture is detected by the micro:bit'
          }),
          blockType: blockType.HAT,
          arguments: {
            GESTURE: {
              type: argumentType.STRING,
              menu: 'gestures',
              defaultValue: MbitMoreGestureName.SHAKE
            }
          }
        }, '---', {
          opcode: 'displayMatrix',
          text: formatMessage({
            id: 'mbitMore.displayMatrix',
            default: 'display pattern [MATRIX] ',
            description: 'display a pattern on the micro:bit display'
          }),
          blockType: blockType.COMMAND,
          arguments: {
            MATRIX: {
              type: argumentType.MATRIX,
              defaultValue: '0101010101100010101000100'
            }
          }
        }, {
          opcode: 'displayText',
          text: formatMessage({
            id: 'mbitMore.displayText',
            default: 'display text [TEXT] delay [DELAY] ms',
            description: 'display text on the micro:bit display'
          }),
          blockType: blockType.COMMAND,
          arguments: {
            TEXT: {
              type: argumentType.STRING,
              defaultValue: 'Hello!'
            },
            DELAY: {
              type: argumentType.NUMBER,
              defaultValue: 120
            }
          }
        }, {
          opcode: 'displayClear',
          text: formatMessage({
            id: 'mbitMore.clearDisplay',
            default: 'clear display',
            description: 'display nothing on the micro:bit display'
          }),
          blockType: blockType.COMMAND
        }, '---', {
          opcode: 'getLightLevel',
          text: formatMessage({
            id: 'mbitMore.lightLevel',
            default: 'light intensity',
            description: 'how much the amount of light falling on the LEDs on micro:bit'
          }),
          blockType: blockType.REPORTER
        }, {
          opcode: 'getTemperature',
          text: formatMessage({
            id: 'mbitMore.temperature',
            default: 'temperature',
            description: 'temperature (celsius) on the surface of CPU of micro:bit'
          }),
          blockType: blockType.REPORTER
        }, {
          opcode: 'getCompassHeading',
          text: formatMessage({
            id: 'mbitMore.compassHeading',
            default: 'angle with the North',
            description: 'angle from the North to the micro:bit heading direction'
          }),
          blockType: blockType.REPORTER
        }, {
          opcode: 'getPitch',
          text: formatMessage({
            id: 'mbitMore.pitch',
            default: 'pitch',
            description: 'nose up movement of the micro:bit from level'
          }),
          blockType: blockType.REPORTER
        }, {
          opcode: 'getRoll',
          text: formatMessage({
            id: 'mbitMore.roll',
            default: 'roll',
            description: 'clockwise circular movement of the micro:bit from level'
          }),
          blockType: blockType.REPORTER
        }, {
          opcode: 'getSoundLevel',
          text: formatMessage({
            id: 'mbitMore.soundLevel',
            default: 'sound level',
            description: 'level of the sound from microphone on micro:bit'
          }),
          blockType: blockType.REPORTER
        }, {
          opcode: 'getMagneticForce',
          text: formatMessage({
            id: 'mbitMore.magneticForce',
            default: 'magnetic force',
            description: 'value of magnetic force (micro tesla)'
          }),
          blockType: blockType.REPORTER,
          arguments: {
            AXIS: {
              type: argumentType.STRING,
              menu: 'axis'
            }
          }
        }, {
          opcode: 'getAcceleration',
          text: formatMessage({
            id: 'mbitMore.acceleration',
            default: 'acceleration [AXIS]',
            description: 'value of acceleration on the axis (milli-g)'
          }),
          blockType: blockType.REPORTER,
          arguments: {
            AXIS: {
              type: argumentType.STRING,
              menu: 'axis'
            }
          }
        },{
          opcode: 'getAnalogValue',
          text: formatMessage({
            id: 'mbitMore.analogValue', 
            default: 'analog value of pin [PIN]',
            description: 'analog input value of the pin'
          }),
          blockType: blockType.REPORTER,
          arguments: {
            PIN: {
              type: argumentType.STRING,
              menu: 'analogInPins'
            }
          }
        },
        {
          opcode: 'readDigitalLevel',
          text: formatMessage({
            id: 'mbitMore.readDigitalLevel', 
            default: 'digital value of pin [PIN]',
            description: 'digital input value of the pin'
          }),
          blockType: blockType.REPORTER,
          arguments: {
            PIN: {
              type: argumentType.STRING,
              menu: 'gpio'
            }
          }
        }, '---',  {
          opcode: 'setPullMode',
          text: formatMessage({
            id: 'mbitMore.setPullMode',
            default: 'set pin [PIN] to input [MODE]',
            description: 'set a pin into the mode'
          }),
          blockType: blockType.COMMAND,
          arguments: {
            PIN: {
              type: argumentType.STRING,
              menu: 'gpio',
              defaultValue: '0'
            },
            MODE: {
              type: argumentType.STRING,
              menu: 'pinMode',
              defaultValue: MbitMorePullModeName.UP
            }
          }
        }, {
          opcode: 'isPinHigh',
          text: formatMessage({
            id: 'mbitMore.isPinHigh',
            default: '[PIN] pin is high?',
            description: 'is the selected pin high as digital?'
          }),
          blockType: blockType.BOOLEAN,
          arguments: {
            PIN: {
              type: argumentType.STRING,
              menu: 'gpio',
              defaultValue: '0'
            }
          }
        }, {
          opcode: 'isPinAfterThreshold',
          text: formatMessage({
            id: 'mbitMore.isPinAfterThreshold',
            default: '[PIN] pin analog is higher than [THRESHOLD] (0-100)?',
            description: 'is the selected pin higher than the value?'
          }),
          blockType: blockType.BOOLEAN,
          arguments: {
            PIN: {
              type: argumentType.STRING,
              menu: 'gpio',
              defaultValue: '0'
            },
            THRESHOLD: {
              type: argumentType.NUMBER,
              defaultValue: 50
            }
          }
        }, '---', {
          opcode: 'setDigitalOut',
          text: formatMessage({
            id: 'mbitMore.setDigitalOut',
            default: 'set [PIN] Digital [LEVEL]',
            description: 'set pin to Digital Output mode and the level(High = true)'
          }),
          blockType: blockType.COMMAND,
          arguments: {
            PIN: {
              type: argumentType.STRING,
              menu: 'gpio',
              defaultValue: '0'
            },
            LEVEL: {
              type: argumentType.STRING,
              menu: 'digitalValueMenu',
              defaultValue: 'false'
            }
          }
        }, {
          opcode: 'setAnalogOut',
          text: formatMessage({
            id: 'mbitMore.setAnalogOut',
            default: 'set [PIN] analog [LEVEL] %',
            description: 'set pin to PWM mode and the level(0 to 1023)'
          }),
          blockType: blockType.COMMAND,
          arguments: {
            PIN: {
              type: argumentType.STRING,
              menu: 'gpio',
              defaultValue: '0'
            },
            LEVEL: {
              type: argumentType.NUMBER,
              defaultValue: 0
            }
          }
        }, {
          opcode: 'setServo',
          text: formatMessage({
            id: 'mbitMore.setServo',
            default: 'set [PIN] Servo [ANGLE]',
            description: 'set pin to Servo mode and the angle(0 to 180)'
          }),
          blockType: blockType.COMMAND,
          arguments: {
            PIN: {
              type: argumentType.STRING,
              menu: 'gpio',
              defaultValue: '0'
            },
            ANGLE: {
              type: argumentType.NUMBER,
              defaultValue: 0
            },
            RANGE: {
              type: argumentType.NUMBER,
              defaultValue: 2000
            },
            CENTER: {
              type: argumentType.NUMBER,
              defaultValue: 1500
            }
          }
        }, {
          opcode: 'playTone',
          text: formatMessage({
            id: 'mbitMore.playTone',
            default: 'play tone [FREQ] Hz volume [VOL] %',
            description: 'play tone on the speaker'
          }),
          blockType: blockType.COMMAND,
          arguments: {
            FREQ: {
              type: argumentType.NUMBER,
              defaultValue: 440
            },
            VOL: {
              type: argumentType.NUMBER,
              defaultValue: 100
            }
          }
        }, {
          opcode: 'stopTone',
          text: formatMessage({
            id: 'mbitMore.stopTone',
            default: 'stop tone',
            description: 'stop tone on the speaker'
          }),
          blockType: blockType.COMMAND
        }, '---', {
          opcode: 'listenPinEventType',
          text: formatMessage({
            id: 'mbitMore.listenPinEventType',
            default: 'listen [EVENT_TYPE] event on [PIN]',
            description: 'listen the event on the pin'
          }),
          blockType: blockType.COMMAND,
          arguments: {
            EVENT_TYPE: {
              type: argumentType.STRING,
              menu: 'pinEventTypeMenu',
              defaultValue: 'NONE'
            },
            PIN: {
              type: argumentType.STRING,
              menu: 'gpio',
              defaultValue: '0'
            }
          }
        }, {
          opcode: 'whenPinEvent',
          text: formatMessage({
            id: 'mbitMore.whenPinEvent',
            default: 'when catch [EVENT] at pin [PIN]',
            description: 'when catch the event at the pin'
          }),
          blockType: blockType.HAT,
          arguments: {
            EVENT: {
              type: argumentType.STRING,
              menu: 'pinEventMenu',
              defaultValue: 'PULSE_LOW'
            },
            PIN: {
              type: argumentType.STRING,
              menu: 'gpio',
              defaultValue: '0'
            }
          }
        }, {
          opcode: 'getPinEventValue',
          text: formatMessage({
            id: 'mbitMore.getPinEventValue',
            default: 'value of [EVENT] at [PIN]',
            description: 'value of the value of the event (timestamp of the edge or duration of the pulse)'
          }),
          blockType: blockType.REPORTER,
          arguments: {
            EVENT: {
              type: argumentType.STRING,
              menu: 'pinEventTimestampMenu',
              defaultValue: 'PULSE_LOW'
            },
            PIN: {
              type: argumentType.STRING,
              menu: 'gpio',
              defaultValue: '0'
            }
          }
        }, '---', {
          opcode: 'whenDataReceived',
          text: formatMessage({
            id: 'mbitMore.whenDataReceived',
            default: 'when data with label [LABEL] received from micro:bit',
            description: 'when the data which has the label received'
          }),
          blockType: blockType.HAT,
          arguments: {
            LABEL: {
              type: argumentType.STRING,
              defaultValue: 'label-01'
            }
          }
        }, {
          opcode: 'getDataLabeled',
          text: formatMessage({
            id: 'mbitMore.getDataLabeled',
            default: 'data of label [LABEL]',
            description: 'the last data which has the label'
          }),
          blockType: blockType.REPORTER,
          arguments: {
            LABEL: {
              type: argumentType.STRING,
              defaultValue: 'label-01'
            }
          }
        }, {
          opcode: 'sendData',
          text: formatMessage({
            id: 'mbitMore.sendData',
            default: 'send data [DATA] with label [LABEL] to micro:bit',
            description: 'send data content with label to micro:bit'
          }),
          blockType: blockType.COMMAND,
          arguments: {
            LABEL: {
              type: argumentType.STRING,
              defaultValue: 'label-01'
            },
            DATA: {
              type: argumentType.STRING,
              defaultValue: 'data'
            }
          }
        },
        '---',
        {
            opcode: 'redirectImplementation',
            text: formatMessage({
                id:'mbitMore.redirectImplementation',
                default: 'To use [IMPLEMENTATION] click here',
                description: 'To use the NeoPixel led strip click here'
            }),
            blockType: BlockType.REPORTER,
            arguments: {
                IMPLEMENTATION: {
                    type: ArgumentType.STRING,
                    menu: 'implementationsMenu',
                    defaultValue: 'neopixel'
                }
            }
        }],
        menus: {
          buttonIDMenu: {
            acceptReporters: false,
            items: this.BUTTON_ID_MENU
          },
          buttonEventMenu: {
            acceptReporters: false,
            items: this.BUTTON_EVENT_MENU
          },
          touchIDMenu: {
            acceptReporters: false,
            items: this.TOUCH_ID_MENU
          },
          touchEventMenu: {
            acceptReporters: false,
            items: this.TOUCH_EVENT_MENU
          },
          gestures: {
            acceptReporters: false,
            items: this.GESTURES_MENU
          },
          analogInPins: {
            acceptReporters: false,
            items: this.ANALOG_IN_PINS_MENU
          },
          digitalValueMenu: {
            acceptReporters: true,
            items: this.DIGITAL_VALUE_MENU
          },
          gpio: {
            acceptReporters: false,
            items: this.GPIO_MENU
          },
          axis: {
            acceptReporters: false,
            items: this.AXIS_MENU
          },
          pinMode: {
            acceptReporters: false,
            items: this.PIN_MODE_MENU
          },
          pinEventTypeMenu: {
            acceptReporters: false,
            items: this.PIN_EVENT_TYPE_MENU
          },
          pinEventMenu: {
            acceptReporters: false,
            items: this.PIN_EVENT_MENU
          },
          pinEventTimestampMenu: {
            acceptReporters: false,
            items: this.PIN_EVENT_TIMESTAMP_MENU
          },
          connectionStateMenu: {
            acceptReporters: false,
            items: this.CONNECTION_STATE_MENU
          },
          implementationsMenu: {
              acceptReporters: false,
              items: this.IMPLEMENTATIONS_MENU
          }
        },
        translationMap: translations
      };
    }
    /**
     * Update the previous occured time of all button events.
     */

  }, {
    key: "updatePrevButtonEvents",
    value: function updatePrevButtonEvents() {
      var _this12 = this;

      this.prevButtonEvents = {};
      Object.entries(this._peripheral.buttonEvents).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            componentID = _ref2[0],
            events = _ref2[1];

        _this12.prevButtonEvents[componentID] = {};
        Object.entries(events).forEach(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
              eventName = _ref4[0],
              timestamp = _ref4[1];

          _this12.prevButtonEvents[componentID][eventName] = timestamp;
        });
      });
    }
    /**
     * Test whether the event raised at the button.
     * @param {object} args - the block's arguments.
     * @param {string} args.NAME - name of the button.
     * @param {string} args.EVENT - name of event to catch.
     * @return {boolean} - true if the event raised.
     */

  }, {
    key: "whenButtonEvent",
    value: function whenButtonEvent(args) {
      var _this13 = this;

      if (!this.updateLastButtonEventTimer) {
        this.updateLastButtonEventTimer = setTimeout(function () {
          _this13.updatePrevButtonEvents();

          _this13.updateLastButtonEventTimer = null;
        }, this.runtime.currentStepTime);
      }

      var buttonName = args.NAME;
      var eventName = args.EVENT;

      var lastTimestamp = this._peripheral.getButtonEventTimestamp(buttonName, eventName);

      if (lastTimestamp === null) return false;
      if (!this.prevButtonEvents[buttonName]) return true;
      return lastTimestamp !== this.prevButtonEvents[buttonName][eventName];
    }
    /**
     * Test whether the A or B button is pressed
     * @param {object} args - the block's arguments.
     * @param {string} args.NAME - name of the button.
     * @param {object} util - utility object provided by the runtime.
     * @return {boolean} - whether the button is pressed or not.
     */

  }, {
    key: "isButtonPressed",
    value: function isButtonPressed(args) {
      var buttonName = args.NAME;
      return this._peripheral.isButtonPressed(buttonName);
    }
    /**
     * Test whether the touch event raised at the pin.
     * @param {object} args - the block's arguments.
     * @param {string} args.NAME - name of the pin to catch.
     * @param {string} args.EVENT - event to catch.
     * @param {object} util - utility object provided by the runtime.
     * @return {boolean|Promise<boolean>|undefined} - true if the event raised or promise that or undefinde if yield.
     */

  }, {
    key: "whenTouchEvent",
    value: function whenTouchEvent(args, util) {
      var _this14 = this;

      var buttonName = args.NAME;

      if (buttonName === MbitMoreButtonName.LOGO) {
        return this.whenButtonEvent(args);
      }

      if (this._peripheral.isPinTouchMode(MbitMoreButtonPinIndex[buttonName])) {
        return this.whenButtonEvent(args);
      }

      var configPromise = this._peripheral.configTouchPin(MbitMoreButtonPinIndex[buttonName], util);

      if (!configPromise) return; // This thread was yielded.

      return configPromise.then(function () {
        return _this14.whenButtonEvent(args);
      });
    }
    /**
     * Test whether the touch-pin is touched.
     * @param {object} args - the block's arguments.
     * @param {string} args.NAME - name of the pin.
     * @param {object} util - utility object provided by the runtime.
     * @return {boolean|Promise<boolean>|undefined} - true if touched or promise that or undefinde if yield.
     */

  }, {
    key: "isPinTouched",
    value: function isPinTouched(args, util) {
      var _this15 = this;

      var buttonName = args.NAME;

      if (buttonName === MbitMoreButtonName.LOGO) {
        return this._peripheral.isTouched(buttonName);
      }

      if (this._peripheral.isPinTouchMode(MbitMoreButtonPinIndex[buttonName])) {
        return this._peripheral.isTouched(buttonName);
      }

      var configPromise = this._peripheral.configTouchPin(MbitMoreButtonPinIndex[buttonName], util);

      if (!configPromise) return; // This thread was yielded.

      return configPromise.then(function () {
        return _this15._peripheral.isTouched(buttonName);
      });
    }
    /**
     * Update the last occured time of all gesture events.
     */

  }, {
    key: "updatePrevGestureEvents",
    value: function updatePrevGestureEvents() {
      var _this16 = this;

      this.prevGestureEvents = {};
      Object.entries(this._peripheral.gestureEvents).forEach(function (_ref5) {
        var _ref6 = _slicedToArray(_ref5, 2),
            gestureName = _ref6[0],
            timestamp = _ref6[1];

        _this16.prevGestureEvents[gestureName] = timestamp;
      });
    }
    /**
     * Test whether the gesture event raised.
     * @param {object} args - the block's arguments.
     * @param {string} args.GESTURE - name of the gesture.
     * @return {boolean} - true if the event raised.
     */

  }, {
    key: "whenGesture",
    value: function whenGesture(args) {
      var _this17 = this;

      if (!this.updateLastGestureEventTimer) {
        this.updateLastGestureEventTimer = setTimeout(function () {
          _this17.updatePrevGestureEvents();

          _this17.updateLastGestureEventTimer = null;
        }, this.runtime.currentStepTime);
      }

      var gestureName = args.GESTURE;

      var lastTimestamp = this._peripheral.getGestureEventTimestamp(gestureName);

      if (lastTimestamp === null) return false;
      if (!this.prevGestureEvents[gestureName]) return true;
      return lastTimestamp !== this.prevGestureEvents[gestureName];
    }
    /**
     * Display pixcel pattern on the 5x5 LED matrix with brightness and write mode.
     * @param {object} args - the block's arguments.
     * @param {string} args.MATRIX - the pattern of the pixels.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} - a Promise that resolves after a tick or undefinde if yield.
     */

  }, {
    key: "displayMatrix",
    value: function displayMatrix(args, util) {
      var matrixString = cast.toString(args.MATRIX).replace(/[-]/g, function (ws) {
        return String.fromCharCode(ws.charCodeAt(0) - 0xFEE0);
      }); // zenkaku to hankaku

      var matrixData;

      if (matrixString.includes(',')) {
        // comma separated values
        matrixData = matrixString.split(/[,\n]/);
      } else if (/[ \t]\d*[ \t]/g.test(matrixString)) {
        // space|tab separated values
        matrixData = matrixString.split(/\s/g);
      } else {
        // 0|1 pattern.
        matrixData = matrixString.replace(/\s/g, '').split('');
        matrixData = matrixData.map(function (level) {
          return level === '0' ? 0 : 100;
        });
      }

      matrixData = matrixData.map(function (brightness) {
        return Math.max(0, Math.min(100, Number(brightness)) * 255 / 100);
      }); // percent to 8bits value

      var matrix = [];

      for (var line = 0; line < 5; line++) {
        matrix[line] = [];

        for (var col = 0; col < 5; col++) {
          matrix[line][col] = matrixData[line * 5 + col];
        }
      }

      return this._peripheral.displayPixels(matrix, util);
    }
    /**
     * Display text on the 5x5 LED matrix.
     * Displayable character is ascii and non-ascii is replaced to '?'.
     * @param {object} args - the block's arguments.
     * @param {string} args.TEXT - The contents to display.
     * @param {number} args.DELAY - The time to delay between characters, in milliseconds.
     * @param {object} util - utility object provided by the runtime.
     * @return {Promise} - a Promise that resolves after the text is done printing or undefinde if yield.
     * Note the limit is 18 characters
     * The print time is calculated by multiplying the number of horizontal pixels
     * by the default scroll delay of 120ms.
     * The number of horizontal pixels = 6px for each character in the string,
     * 1px before the string, and 5px after the string.
     */

  }, {
    key: "displayText",
    value: function displayText(args, util) {
      // zenkaku to hankaku
      var text = cast.toString(args.TEXT).replace(/[----]/g, function (ws) {
        return String.fromCharCode(ws.charCodeAt(0) - 0xFEE0);
      }).replace(//g, '"').replace(//g, "'").replace(//g, '`').replace(//g, '\\') // eslint-disable-next-line no-irregular-whitespace
      .replace(//g, ' ').replace(//g, '~');
      var delay = parseInt(args.DELAY, 10);
      delay = isNaN(delay) ? 120 : delay; // Use default delay if NaN.

      var resultPromise = this._peripheral.displayText(text, delay, util);

      if (!resultPromise) return; // This thread was yielded.

      var yieldDelay = delay * (6 * text.length + 6);
      return new Promise(function (resolve) {
        setTimeout(function () {
          resolve();
        }, yieldDelay);
      });
    }
    /**
     * Turn all 5x5 matrix LEDs off.
     * @param {object} args - the block's arguments.
     * @param {object} util - utility object provided by the runtime.
     * @return {Promise} - a Promise that resolves after a tick or undefinde if yield.
     */

  }, {
    key: "displayClear",
    value: function displayClear(args, util) {
      var matrix = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]];
      return this._peripheral.displayPixels(matrix, util);
    }
    /**
     * Test the selected pin is higher than analog value.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @param {number} args.threshold - threshold.
     * @param {object} util - utility object provided by the runtime.
     * @return {boolean} - true if the pin is high.
     */

  }, {
    key: "isPinAfterThreshold",
    value: function isPinAfterThreshold(args, util) {
      return this._peripheral.isPinAfterThreshold(parseInt(args.PIN, 10), args.threshold, util);
    }
    /**
     * Test the selected pin is high as digital.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @return {boolean} - true if the pin is high.
     */

  }, {
    key: "isPinHigh",
    value: function isPinHigh(args) {
      return this._peripheral.isPinHigh(parseInt(args.PIN, 10));
    }
    /**
     * Get amount of light (0 - 255) on the LEDs.
     * @param {object} args - the block's arguments.
     * @return {number} - light level.
     */

  }, {
    key: "getLightLevel",
    value: function getLightLevel() {
      var level = this._peripheral.readLightLevel();

      return Math.round(level * 1000 / 255) / 10;
    }
    /**
     * Get temperature (integer in celsius) of micro:bit.
     * @param {object} args - the block's arguments.
     * @return {number} - value of temperature [centigrade].
     */

  }, {
    key: "getTemperature",
    value: function getTemperature() {
      return this._peripheral.readTemperature();
    }
    /**
     * Get loudness of the sound from microphone on micro:bit.
     * @param {object} args - the block's arguments.
     * @param {object} util - utility object provided by the runtime.
     * @return {Promise} - a Promise that resolves digital input value of the pin or undefinde if yield.
     */

  }, {
    key: "getSoundLevel",
    value: function getSoundLevel(args, util) {
      var _this18 = this;

      var resultPromise = this._peripheral.configMic(true, util);

      if (!resultPromise) return; // This thread was yielded.

      return resultPromise.then(function (micState) {
        if (micState) {
          return Math.round(_this18._peripheral.readSoundLevel() * 1000 / 255) / 10;
        }

        return 0;
      });
    }
    /**
     * Return angle from the north to the micro:bit heading direction.
     * @return {number} - degree of compass heading angle from the north (0 - 359 degrees).
     */

  }, {
    key: "getCompassHeading",
    value: function getCompassHeading() {
      return this._peripheral.readCompassHeading();
    }
    /**
     * Return analog value of the pin.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves analog input value of the pin or undefined if this process was yield.
     */

  }, {
    key: "getAnalogValue",
    value: function getAnalogValue(args, util) {
      var pinIndex = parseInt(args.PIN, 10);

      var resultPromise = this._peripheral.readAnalogIn(pinIndex, util);

      if (!resultPromise) return;
      return resultPromise.then(function (level) {
        return Math.round(level * 100 * 10 / 1024) / 10;
      });
    }
    /**
     * Return digital value of the pin.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @return {number} - digital input value of the pin.
     */

  }, {
    key: "readDigitalLevel",
    value: function readDigitalLevel(args) {
      return this._peripheral.readDigitalLevel(parseInt(args.PIN, 10));
    }
    /**
     * Send data with label.
     * @param {object} args - the block's arguments.
     * @property {string} args.LABEL - label of the data.
     * @property {string} args.DATA - content of the data.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} - a Promise that resolves when the process was done or undefined if this process was yield.
     */

  }, {
    key: "sendData",
    value: function sendData(args, util) {
      if (args.LABEL.length <= 0) {
        return;
      }

      return this._peripheral.sendData(args.LABEL, args.DATA, util);
    }
    /**
     * Set pull mode of the pin.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @param {MbitMorePullModeName} args.MODE - mode to set.
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {promise | undefined} - a Promise that resolves when the command was sent
     *                                 or undefined if this process was yield.
     */

  }, {
    key: "setPullMode",
    value: function setPullMode(args, util) {
      return this._peripheral.setPullMode(parseInt(args.PIN, 10), MbitMorePullModeID[args.MODE], util);
    }
    /**
     * Set the pin to Output mode and level.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @param {boolean | string | number} args.LEVEL - value to be set.
     * @param {object} util - utility object provided by the runtime.
     * @return {promise | undefined} - a Promise that resolves when the command was sent
     *                                 or undefined if this process was yield.
     */

  }, {
    key: "setDigitalOut",
    value: function setDigitalOut(args, util) {
      var level = args.LEVEL === true;
      level = level || args.LEVEL === 'true';

      if (!level) {
        var num = Number(args.LEVEL);

        if (!isNaN(num)) {
          level = num > 0;
        }
      }

      return this._peripheral.setPinOutput(parseInt(args.PIN, 10), level, util);
    }
    /**
     * Set the pin to PWM mode and level.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @param {number} args.LEVEL - value[%] for PWM.
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {promise | undefined} - a Promise that resolves when the command was sent
     *                                 or undefined if this process was yield.
     */

  }, {
    key: "setAnalogOut",
    value: function setAnalogOut(args, util) {
      var percent = parseInt(args.LEVEL, 10);

      if (isNaN(percent)) {
        return;
      }

      percent = Math.max(0, Math.min(percent, 100));
      var level = Math.round(percent * 1024 / 100);
      return this._peripheral.setPinPWM(parseInt(args.PIN, 10), level, util);
    }
    /**
     * Set the pin to Servo mode and angle.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {promise | undefined} - a Promise that resolves when the command was sent
     *                                 or undefined if this process was yield.
     */

  }, {
    key: "setServo",
    value: function setServo(args, util) {
      var angle = parseInt(args.ANGLE, 10);
      if (isNaN(angle)) return;
      angle = Math.max(0, angle);
      angle = Math.min(angle, 180); // let range = parseInt(args.RANGE, 10);
      // if (isNaN(range)) range = 0;
      // range = Math.max(0, range);
      // let center = parseInt(args.CENTER, 10);
      // if (isNaN(center)) range = 0;
      // center = Math.max(0, center);

      return this._peripheral.setPinServo(parseInt(args.PIN, 10), angle, null, null, util);
    }
    /**
     * Return the value of magnetic force [micro tesla] on axis.
     * @param {object} args - the block's arguments.
     * @property {AxisSymbol} AXIS - the axis (X, Y, Z, Absolute).
     * @return {number} - value of magnetic force.
     */

  }, {
    key: "getMagneticForce",
    value: function getMagneticForce(args) {
      return this._peripheral.readMagneticForce(args.AXIS);
    }
    /**
     * Return the value of acceleration on the specified axis.
     * @param {object} args - the block's arguments.
     * @param {AxisSymbol} args.AXIS - direction to get.
     * @return {number} - value of acceleration.
     */

  }, {
    key: "getAcceleration",
    value: function getAcceleration(args) {
      return this._peripheral.readAcceleration(args.AXIS);
    }
    /**
     * Return pitch [degrees] of the micro:bit heading direction.
     * @return {number} - degree of pitch.
     */

  }, {
    key: "getPitch",
    value: function getPitch() {
      return this._peripheral.readPitch();
    }
    /**
     * Read roll [degrees] of the micro:bit heading direction.
     * @return {number} - degree of roll.
     */

  }, {
    key: "getRoll",
    value: function getRoll() {
      return this._peripheral.readRoll();
    }
    /**
     * Play tone on the speaker.
     * @param {object} args - the block's arguments.
     * @param {string} args.FREQ - wave frequency to play
     * @param {string} args.VOL laudness of tone
     * @param {object} util - utility object provided by the runtime.
     * @return {promise | undefined} - a Promise that resolves when the command was sent
     *                                 or undefined if this process was yield.
     */

  }, {
    key: "playTone",
    value: function playTone(args, util) {
      var frequency = parseFloat(args.FREQ);
      var volume = parseInt(args.VOL, 10);
      volume = Math.min(100, Math.max(0, volume));
      return this._peripheral.playTone(frequency, volume, util);
    }
    /**
     * Stop playing tone on the speaker.
     * @param {object} args - the block's arguments.
     * @param {object} util - utility object provided by the runtime.
     * @return {promise | undefined} - a Promise that resolves when the command was sent
     *                                 or undefined if this process was yield.
     */

  }, {
    key: "stopTone",
    value: function stopTone(args, util) {
      return this._peripheral.stopTone(util);
    }
    /**
     * Set listening event type at the pin.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @param {string} args.EVENT_TYPE - event to listen.
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {promise | undefined} - a Promise that resolves when the command was sent
     *                                 or undefined if this process was yield.
    */

  }, {
    key: "listenPinEventType",
    value: function listenPinEventType(args, util) {
      return this._peripheral.listenPinEventType(parseInt(args.PIN, 10), MbitMorePinEventType[args.EVENT_TYPE], util);
    }
    /**
     * Rerutn value (timestamp of the edge or duration of the pulse) of the event or 0 when the event is not received.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @param {string} args.EVENT - event value to get.
     * @param {object} util - utility object provided by the runtime.
     * @return {number} - timestamp of the event or 0.
     */

  }, {
    key: "getPinEventValue",
    value: function getPinEventValue(args) {
      var value = this._peripheral.getPinEventValue(parseInt(args.PIN, 10), MbitMorePinEvent[args.EVENT]);

      return value ? value : 0;
    }
    /**
     * Update the previous occured time of all pin events.
     */

  }, {
    key: "updatePrevPinEvents",
    value: function updatePrevPinEvents() {
      var _this19 = this;

      this.prevPinEvents = {};
      Object.entries(this._peripheral._pinEvents).forEach(function (_ref7) {
        var _ref8 = _slicedToArray(_ref7, 2),
            pinIndex = _ref8[0],
            events = _ref8[1];

        _this19.prevPinEvents[pinIndex] = {};
        Object.entries(events).forEach(function (_ref9) {
          var _ref10 = _slicedToArray(_ref9, 2),
              eventID = _ref10[0],
              eventData = _ref10[1];

          _this19.prevPinEvents[pinIndex][eventID] = {};
          Object.entries(eventData).forEach(function (_ref11) {
            var _ref12 = _slicedToArray(_ref11, 2),
                key = _ref12[0],
                value = _ref12[1];

            _this19.prevPinEvents[pinIndex][eventID][key] = value;
          });
        });
      });
    }
    /**
     * Return the previous timestamp of the pin event or undefined if the event was not received.
     * @param {number} pinIndex - index of the pin to get the event.
     * @param {MbitMorePinEvent} eventID - ID of the event to get.
     * @return {?number} Timestamp of the previous event or null.
     */

  }, {
    key: "getPrevPinEventTimestamp",
    value: function getPrevPinEventTimestamp(pinIndex, eventID) {
      if (this.prevPinEvents[pinIndex] && this.prevPinEvents[pinIndex][eventID]) {
        return this.prevPinEvents[pinIndex][eventID].timestamp;
      }

      return null;
    }
    /**
     * Test whether the event raised at the pin.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @param {string} args.EVENT - event to catch.
     * @return {boolean} - true if the event raised.
     */

  }, {
    key: "whenPinEvent",
    value: function whenPinEvent(args) {
      var _this20 = this;

      if (!this.updateLastPinEventTimer) {
        this.updateLastPinEventTimer = setTimeout(function () {
          _this20.updatePrevPinEvents();

          _this20.updateLastPinEventTimer = null;
        }, this.runtime.currentStepTime);
      }

      var pinIndex = parseInt(args.PIN, 10);
      var eventID = MbitMorePinEvent[args.EVENT];

      var lastTimestamp = this._peripheral.getPinEventTimestamp(pinIndex, eventID);

      if (lastTimestamp === null) return false;
      var prevTimestamp = this.getPrevPinEventTimestamp(pinIndex, eventID);
      if (prevTimestamp === null) return true;
      return lastTimestamp !== prevTimestamp;
    }
    /**
     * Rerutn the last content of the messge or undefined if the data which has the label is not received.
     * @param {object} args - the block's arguments.
     * @param {number} args.LABEL - label of the data.
     * @return {?(string | number)} - content of the data or empty string when the data was null
     */

  }, {
    key: "getDataLabeled",
    value: function getDataLabeled(args) {
      var data = this._peripheral.getDataLabeled(args.LABEL);

      if (data === null) {
        return '';
      }

      return data;
    }
    /**
     * Update the previous occured time of all received data.
     */

  }, {
    key: "updatePrevReceivedData",
    value: function updatePrevReceivedData() {
      var _this21 = this;

      this.prevReceivedData = {};
      Object.entries(this._peripheral.receivedData).forEach(function (_ref13) {
        var _ref14 = _slicedToArray(_ref13, 2),
            label = _ref14[0],
            contentObject = _ref14[1];

        _this21.prevReceivedData[label] = {};
        Object.entries(contentObject).forEach(function (_ref15) {
          var _ref16 = _slicedToArray(_ref15, 2),
              key = _ref16[0],
              value = _ref16[1];

          _this21.prevReceivedData[label][key] = value;
        });
      });
    }
    /**
     * Return the previous timestamp of the data or undefined if the data was not received.
     * @param {string} label - label of the data.
     * @return {?number} Timestamp of the previous data or null.
     */

  }, {
    key: "getPrevReceivedDataTimestamp",
    value: function getPrevReceivedDataTimestamp(label) {
      if (this.prevReceivedData[label]) {
        return this.prevReceivedData[label].timestamp;
      }

      return null;
    }
    /**
     * Test whether the data received which had the label.
     * @param {object} args - the block's arguments.
     * @param {number} args.LABEL - label of the data.
     * @return {boolean} - true if the data received.
     */

  }, {
    key: "whenDataReceived",
    value: function whenDataReceived(args) {
      var _this22 = this;

      if (!this.updateLastDataTimer) {
        this.updateLastDataTimer = setTimeout(function () {
          _this22.updatePrevReceivedData();

          _this22.updateLastDataTimer = null;
        }, this.runtime.currentStepTime);
      }

      var label = args.LABEL;

      var lastTimestamp = this._peripheral.getDataTimestamp(label);

      if (lastTimestamp === null) return false;
      var prevTimestamp = this.getPrevReceivedDataTimestamp(label);
      if (prevTimestamp === null) return true;
      return lastTimestamp !== prevTimestamp;
    }

    /**
     * Redirect to implementations.
     * @param {object} args - the block's arguments.
     * @return {string} string.
     */
  }, {
    key: "redirectImplementation ",
    value: function redirectImplementation(args) {
        window.open("https://makecode.microbit.org/79067-48667-65547-62218", "_blank");
        return "NeoPixel with MicroBit";
    }

    /**
     * Test whether a micro:bit connected.
     * @param {object} args - the block's arguments.
     * @property {string} args.STATE - the state of connection to check.
     * @return {boolean} - true if the state is matched.
     */
  }, {
    key: "whenConnectionChanged",
    value: function whenConnectionChanged(args) {
      var state = args.STATE === 'connected';
      return state === this._peripheral.isConnected();
    }
  }], [{
    key: "formatMessage",
    set:
    /**
     * A translation object which is used in this class.
     * @param {FormatObject} formatter - translation object
     */
    function set(formatter) {
      formatMessage = formatter;
      if (formatMessage) setupTranslations();
    }
    /**
     * @return {string} - the name of this extension.
     */

  }, {
    key: "EXTENSION_NAME",
    get: function get() {
      return formatMessage({
        id: 'mbitMore.name',
        default: 'Boson',
        description: 'name of the extension'
      });
    }
    /**
     * @return {string} - the ID of this extension.
     */

  }, {
    key: "EXTENSION_ID",
    get: function get() {
      return EXTENSION_ID;
    }
    /**
     * URL to get this extension.
     * @type {string}
     */

  }, {
    key: "extensionURL",
    get: function get() {
      return extensionURL;
    }
    /**
     * Set URL to get this extension.
     * @param {string} url - URL
     */
    ,
    set: function set(url) {
      extensionURL = url;
    }
  }]);

  return MbitMoreBlocks;
}();

export { MbitMoreBlocks as blockClass, entry };
