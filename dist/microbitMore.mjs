var img$4 = "data:image/png;base64,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";

var img$3 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8' standalone='no'%3f%3e%3c!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg version='1.1' id='Layer_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='150px' height='150px' viewBox='0 0 150 150' enable-background='new 0 0 150 150' xml:space='preserve'%3e %3cimage id='image0' width='150' height='150' x='0' y='0' href='data:image/png%3bbase64%2ciVBORw0KGgoAAAANSUhEUgAAAJYAAACWCAYAAAA8AXHiAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP%2bgvaeTAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAq2ElEQVR42u2dd5xVxfn/3zNzzrlt%2b8JSlCaggDTF2EAsCLZgRU1sMYkl%2bDWxJCZqMLHFEo0laiwxMRo1zWisP1FRNBYQRUARO03a7sLWu/fec87M/P64y7JLV/e6cfe%2beZ0Xe%2b49Zc4znzvlmWfmCGutJU%2bedkZ2dALydE7ywsqTE/LCypMT8sLKkxPywsqTE/LCypMT8sLKkxPywsqTE/LCypMT8sLKkxPywsqTE/LCypMT8sLKkxPywsqTE/LCypMT8sLKkxPywsqTE/LCypMT8sLKkxPywsqTE/LCypMT8sLKkxPywsqTE/LCypMT8sLKkxPywsqTE/LCypMT8sLaDhYtWsR3Tjyxo5PxjSIvrG1gjOHIyZM5aMIE5s2b1y7XbGxs7OjHyjldQlg777wz27OozupVqzb5bNKkSXz8ySecddZZ7Lfffpt8v2DBgu1ORxiGeJ5HQ0NDR5sk53QJYS1ZsgTHcbj997dt8ZhkMslBEyZw771/bPls1qxZHH30US37r732GudMndqyX1hYyIUXXLBdQjn7rLPwPA%2bt9XaJ/BuP7QLE43ELWMdxbJ8%2bfTZ7TL9%2b/ay11l5zzbX2v6%2b8bGtqauyAAQM2Oe7www%2b3H3/8kT3pO9%2b11dXVNgxDW1ZWttX7T5t2mRVCWNd1rRDCrlixoqNNknO6hLBKSkosYHv16rXZ7/2Mbw8/4oiW/f4DdrKFhYVbvF4kErEXXXRRy/7MmTPteT/5yVbTMHbsWBuJRKwQwn7%2beV5YnYKFC9%2b31mYF8czTz2zy/V577mmNMW0%2bq6qq2uL1UqnUJp%2bdcOJ3bENDwxbPkVLaNWvWWGut1Vp3tElyjrC2K1T4WZ5%2b/EmOOu4YwjBs8/nUH57FnX%2b6J2f3PfbY47Ch4bEnHutoE3xtdClhAfTs2ZMbr7yaU84642u7p6ckq1ZXUt69W0c//tdGl%2bgVtuaZ06Yw9UdnMndIN9bcfGtO77Xyqh/zy5jLcCdCPJ3q6Ef/WulSJVbtzBnUHTOZ39RnqLKWu8ssOtyd4gWPEu/br13v9eruu7LLss84I0xzoRUU9%2bvLqLmfIByno83wtdClSqzll/yKHheez123XEN/aylfUg9Xn8zzZ5/ervd592c/Z8Tpp/KDEXuwY73LPq/OY8e99mTtK693tAm%2bNjpViRUazbJ11RgJrnIQCKy1eFKhCXEDQVBTxcoXn2f5nDk8%2bfZrXPPYDNySUoQUCCFACgxgrMFYQ5jtOSMQSAFCCKSQSCGQQmAtGEBaiChFSoeEyRSZ6rX8/vgJTDp8Ej0HDaVs0pF4iXJkzCPqeFknafP1oo5L1HE72nztSqcRlgVOfe5%2b0kpgpEVaidEBVoGNSorShdQ4DRBqSk2Swnhvfr3bsTjuWkpEHGENjVLw9MI5/GfVewhZQmNUkEgbfAWuhrQDrgFhQQuIhprQU5Ax9PES9OtRTkVZd1atreSjZUto8mIkEVjHkrYZClOG%2bogl4rjIULRJ/78POq2jTdiudJoK3xiDLywpT1CShoyEwBEseuhJqJHsMnUiEePRV8f5%2bcE/JO43cN/bVzKs/4sM6%2bHT1Jhh%2bodjOHrIpRw8/AAe/fA1Xl2xknVemliQFVRaQCjAKHAMZGIJvjdwdw7t0Y/V9et4Z8XnVC5YzKhddmHy%2bD2piMd45NN5PPv5B5TXhTx45gWQMUz%2b%2by3ISLSjTZZTOk0bS0nJmERPhAVfQcaFUl%2bw9OHnEHVrKbSGo3Y8gCsnHMEzb5xDKtKd/QbNZNnqk5i5/GpeWX4l/csqCRMH8XHtruxWshOXjf82PdIKIyGU4OjsvWIB7BPrxUNjpzD3%2bSeJlccZXdaf43Ybx7mHHcshA3Zl18IKBg4ZRFFNkj/s/x3CoignPXAbMmWxxnS0uXJOp6kKAZJ%2bhtNe%2bwdaWISVxI3l4ZP/jyP/cR9Dox6XDDuEJ2t/wL4Vb7JuzaPs0bs/Vhl8UUyVteyIYLFt4IP5Z7PzyDeZ/ebtDBu9J1e9PR0bhCgDRhiGJrpz/rcOZfAuw9CffYZxh5Leb39cdmK/0VXMmF2IYxoQcx7DDT/iwKkn88jNf%2bH02Q8TX1ZDw%2beVBN8ahKPBd6C7G%2bePY6d0tPnalU5TYgEkvAh9nQgIQTS0BI7isIt/StSuY9qoSdz/6VUcWPEORc7/Y48dR2AVfPBRNbfdeCP1ixaBgD5BAWN3u4WPPzmAEaOvwA0a2MPrRaBSRAOXZBQu%2bdZhjB23B7WVHxEOmsJf/tOLS/Y%2bGCcZJxqswTQM5uozEvzinu/DoDN44Q%2bPccUDt/PnsSexZocEqwqy6XWsJGN87t73uI42XbvTqUosgBWNtfxkzhMIQLgOOjQcteNg6oNCvjd4Tz5c/STf6n0AyDT1tYZuOxZg0gprLVOmTOHvf3qAVNzBD1IsbRrLE5%2bdwNQRZ3HOzBlYr5JLdzuZlx/9Nxee/SMiO52IKJ6M71YjhU8QDkR4VahkL0zRUsrqA%2boTq7GrliKWPcrzn73Pm9XLeb1%2bBU7G0OhJ%2biXhzkNP6WiztTudqsQC2KGghArj4StwUiEGw%2bTeQ1hV/w/ebtybPbodADIDxCgoirBq2UqMMVhreeSRR3jp04%2bIakuBFNTUnM/Bg/4fxiuhh0wQNVGGF5bz80vOR9KHHx68N78%2b7D20ExLICMJZSbRJod1GrFY02N789vRVHLDncKz2%2bPEvf873h%2b6LYy3SZjsAp48a19EmywmdTlgA0/Y8BF9orNZoR5OIFXHYLm%2bjw7EYB5qaDEEQABIdKqTMmsEYw5QJE5BS4LgRhvY8hn6F7/PKvLfYbcgQdigo56O6BlSVT6TnHtwxt5grnvoWSA%2bhi7A6RsoVWJECP0GmvIrLbxvLC8sTmIK9WPTwY0SVwQ8MWgqKA82evdrX4/%2b/QqcU1g6FpQy3hfhRhwQuwgT0iMynJPgWKUcQjUaZPHky1157Lb1790Zr3XJufd06EBKrHQoihRSJCB/KKoZG4wwo3JHZb84CJLFBo7jgmJcJYp/jNpSh9EYtCpnGrSknGSngvEnLKO87AK0FqVSaQtfDt5o%2bkSIE4os93DeETiksgJ%2bMPggtJUILEJqwMY4jFBqNlJLp06czbdq0FlGtb2oaq9EWUOCiEVpjVQxrA1AO69JJsIaGqjU4tcswmXIQFu21DU%2b2KkSrEK0TiLo1hIEEBNbQIqbvD9uno82UMzqtsPoWlVGMSxpBCpfPVh3FWudFEnYbPiQrsFIAIUZX0hA2MannOF5YOpfPG9ey3/BR2aGcxjQ3zTgDJZoI4pWodNuQGDddjImkKFJLuHXO3tRVL0UIQzTu0Rj4xIxkUHnPjjZTzui0wgK4atQEApFhSdVS3qgbyYjCBwlDSRgGeFGJoABU23OiXinCWDJW4Kcf47nVhzO6SDO3spLlVbXsslN/0tEQsWo2k/d%2bj3Mnf4AMS9FeLehCkAHYCMZNEE17XHzKu4zaoRbq/8vgCeMJZQxcweDiok5TCf7n8cc3%2baxTC6tfcTndfMVtH83jgn0mUp/ux5LkNIwwHH3MqViZROp4m3O69S7HyrWoTBKduARdcxQLUqtYMX0hqyvfJx0EHH/cqQT2U157Mcad0yso9GtxTAzhNCDDIpAuUfMRJWnLFQ/txaJ3a3Gs5uLfXMGTy99DGMN5wyd0tHnajaOPOmqTzzq1sACmDhuPSTWytlby8tLfUBL/J0HwBA8%2b8Beko5DNJpBSopTi448XIE0MI/rwn/fO4KhRJ3HtS88z9/Z7eOlnNzPt9X9x2113EfckVZ9cS0Gt4ZJzXmFE6WJKVDFH7fUwKkhy4sHVDBvzCUovJfPhvex70tF8Z7fxTP94LtFQUB4r6GjT5JROL6y9evenviDDpfOmc%2bjwPXjrw8tIuufRZC/mmcefwIgMSBBEeeSRR3DNOwSZUTy85hgmDv0N977zNCJSits7QVHfwTTYFK%2bvWMQDL75ANBNQ/9E1/Oq3CT5dW0QYVrHniDJEuhd/nVHOrDdqycy7mV47lPOXe%2b7jljnTqXctp%2by0ezZEpxPT6Tzvm%2bO9ypX8%2bOPnGJhyOX/vSbipNIurLmf3Xf5JUdiP5YuL2WHHEBNfwgfpEpLr7mZcxe5cPfcV5qdrKMhAdaGkMGVxAkN9zDJ1xzGMLunNQYcewIcLFhHzCyGWwMoIwqSQQYom28QRpx/N/Xc%2bwL1zX%2bKNTBVKGx4c/12iqnPFX21MlxAWwA%2bee5A612Bcy9DSMs4cOIyeDGBhcjbxsJYAS0HRnvSMlvLC4uXctXwmXuDy7nV3s%2buVZ6F8TYgh6cDqy%2b9n%2bC9/wEjhcdreR2LXrOWmP9/KWzPnULeujvKe3TjwkIO44NzzWJ1p4Ma3X6JGZPBdh75NkjsmndTR5sg5XUZYzy3%2bgN8vm0NROsTVxTRFQgowDKsooChaTkYHLFlTzyIqiQtNtKmM0Kvm82feYt5dj2DLYrhGYGuSDDvvu5QdOhbPaAyW0bFeHN59CL17FOEoSVMmzeLqSp5d9iGf0oSwAkGIZxTn7Lw34/vu3NHmyDldRlgAa5uSNAYZjDAIFBKLwMFajRISK8g6UXWItgZjDIENSYcBESTaEWgBobV0E1GMlEgBVlgCQJoNjdYQixQb/OpWgCckvQtLOtoMXwtdSljbSxiG/PSii7IREs2NbGstQmTj4i0WLCiluPGGGzo6uf%2bTdJrQ5PYknc4gTfb3tr7zJgCsheaSCMAEQUcn9X%2bWfIm1BRYvXsKc2W%2bSSqfQWmO0JtQhvh%2bgjcZ1PQ47/DAG7rRTRyf1f5J8ibUF7rjjdnSokao5pEZn21xexENrQyKewJHqK96l89LpHaRfhsrKSowxILIxWgA79t6Bs846k8umXcbEgw7GYrjzrjs7Oqn/s%2bRLrM1QUVHB7rvtzhFHHEGiIMHfHnyYhR%2b8z5/vu68lvKYlzMaYlkDBPBvolBZpaGigpLikZX3QDz/8kKampi90jc9Wr%2bLXV13Jxb%2bcxryF75EJQozIzpK2QoKURAoLvpKoDjvscKqrqzvaXDmhUzbezz/vfG67/Tbi8Tj33nUPJ/3wVBwteGHeHN5uqEQrgW2eMq%2bkwpESR6qWafPSShwhCLVu9kVJBBZtTXbKNWCsxWKQjoPBYgVYY7PT87Vp2RdCYIUg7acpX1nH2cefSL/%2b/fno409wHIddd92V%2bfPnd7TJ2p1OVxX%2b4he/QEiB67rccsstTP3x/4FvCaTl5sp3MEIQiraP3brMiX4JD8L632bG2/LAslWa139/G9EQPl61jNqaGioqKpgwYQIXXXQRN3Qyf1inqgovu%2bwygiBg2bJlhGHIIYccQk1NDa5wOPb%2bG4homZ3IGpo2W7TV5pkvv8V83bLFA9NmK07DoRedQ9JViJTm%2bmuuo7qqmoaGhqxD9qc/7WjztSudpiq89JJLSaVTlBSXsGzxEv7x%2bL%2b54P/O5cbrf8vgH51IrykHUxYotAJJEqu742SWU/i6T1xXbXK99UYx1sOxPliBUSHaFlCeWUdl3FDgJ7LHrj9YbIif1xKWHTgSvBL8SD1x38EIy5IZr7L4ur9Qg2Xy0ZN54rEnuea6K6lcU4vyLL%2b97vqONmW70CmEdeU1N7CucgURL8r1v72Ok08%2bmT333JNrLvsVelhvDr76YjISokbQ6EEsVQYIqosbsGF3orpuk2vKFpe7ACyh8HDDCGV%2bHX6kGmNLQW/cIZDNpwjSShM6EazxUWEhGaUAg9KamT%2b4iMySdcz876scsN84MmEtv778eurr6/GcODf9blpHm/Qrs93CGrnP/aQ8jecXolWG7a1Fg4JGHFXNh09fCsC%2b425kBf0osilSMopjNyw0mylcwT6Dd%2bDh359EZWU94499asvXjST5ZMaZ/OH2u1m65AOUG%2bPaa68B4Njjj%2bWWG25mwNDBHP%2bfu0jGHRKZ7MIeFsstC89ih6TfPEAsNhRPm6N5aAcFTZEIj/Y5hpcLDmFdzCDNRg5Su2FfCENGFbNzw1PcOP9PLbH11gGRBhIb3Uc3L7RlBX%2b0l3HmL67YJCnpm6JEpf/lc9uA/Uka4XjYB0Yi1r33pS6jccgc9wrxPntv8ZjtFtau4%2b%2bgwXNJZGKknRBht09YkhSOaOSwMdXceP1vOPCgX7JIjqG7XkudU0rEpDckRq2hm%2bsxbmQVl/ziEvY87t9bvq52GVgxnWKbot/OO3HDdde1fLfwvYX87tbfkZwwikzPclxjEdbS5EKPlSluW3wbUW8hMhT4rocbbiWzjKB5zhYIF%2bNopIa3U4fw99qhm%2bZcM7FAsiYhOUs9yZjyj7ACRNAsLC1AbWR2C0JarJH8aeF43oztxj1/uKnNIU03F4NMEgu/3Go12sKfaqay46ixHJR4hugHD3%2bp62AEz8nvsKzoAM4888zNHrLdvcJGJ0YkUAROEyIby9sKgREGiUZgwXgt3/gKomnJHTddz7W/uZJ6dqQ8XEpjJIYSVWAjLcdmbA9WrX2Dm258hksvvgTEljM8cAwvPvkQ%2b%2bx/PP9sJSqAXYfvSmbHCnRFOY4xgMDVEkdBY/cEy%2bo%2bp3%2bDS0Qq0q6PZzZkcigjOGHzBFYhsI7GCok0BqNClBEgYY%2bC54jtMITz%2b%2b9BNxGi/BJSsQ1VqhURhL%2bM3otWEAYersmAyi7ahrSbLyUNCAwn7jKb86/4hF4VhVxx%2bYaSywnSKEnWxl8CJeGuW%2b5kyLdDxn83idhKmWLl%2biajA4Rt8juUkjnPPMcDNau2KKz26RUKH0dHENZFywCtMi2btTGMClvXEtt3yW0ekRXMsUccstlv9598KIHK5mGjZwikAQyhNLitfvBiI9sK42CVpslzsDJAWIORhsABGbRN1ZCmm%2bGq28mo7Ep9wuiWzQuTlIaf0quW5qJq%2b589FjEMdFfxeXUNf3/oH60S1z7ZZTYpGDbFFx6hjIAwpNwYgXRbtlA6OPjYrcinXfxYvnQppAahQ0LrIc2GVDuiChVksND%2bEwisQGxBsdWN9S0VU68kZF5dSFkmu%2bRjdKBsjqsCtVGtogx83NSL3a9tYo9ulicucShMp0i7Bre5IZ%2b9t0XVlfHjnd7k%2bj/tw149K0H3av7K4qCY0ns6flGajGNwv8Bq3DIMuOO4Yq5Y3MBr0dlov5GTv//DDTE8X5XtuEwk5VNf2A8vU48wENoNJzXJAozQOGy5RmkXYUUzDpWfPUjNqnlYYcia34IU2SIjKMORX9Qo2zheWKQVW/wVh9airMAIwYqEpnz8ztQJQdpx4J2A0A9xHW8TYWWKLMWN69CqG8Pv/QPLl5zP0EwTUiq0Y9scv7a8jgG1itl/vJ%2bej/yGpkIXZSyhEAgT8KsFa/BqNJ4TwTqZNqWjdgqwpgmlHazyka1LUQUjRhje%2bu277LHz/sxbMA95/90cKyzCCIwEYWVzlbi1olAA2ajX7FiDRZCd6ratAjRUvej7s6XUmxhSRMGm0JCt40SaqA/9R2/5/HYpW7UTEApLQeFgrDbZIQ1tsYHBZizWrCUIDRHP3bZgWth23eEYixGbb8hq5RANFKFUFKUL8EWCQDpIo3GFIuI4SAORjX503kqDDaIEmXqWRLoT1xJTYPHSLrq5Ol2/Jfw4NqMRjXWsTZQQT0UobnIRYYTRqxcQTYWYGC0Z2sbwUqNtMUL6aFPU9sk1FIaNlFbO59qbf0dxopg33/qUBhfQLjKUCG2wYls2soBBGYPUDliJDxgcJJmtn1rYQNL3WDh/HqG/jjBowgZN2EwTNp0kZZIsmvvKlvPmi4pocwhceg8%2bHqMjDJp4HTGryRiXift2546rv/%2blrrnNvmpLFbj5A1PSJ1Q%2bGcfiylqMjYLxcKze%2bnWL0jhJl7OGKb635FL6NlWBB7gBXija3M%2bKBp54vxtKhBwVe4mY4%2bEZQ00kZK8PXsS1PugI1gk2acv5DZZVVtE/Ai7pNr837RmcwGP6TxM89PenmHb11Vzxq2ngBwjHgjBY4RAg8exWerRC4FsHTwQgQ5AQsxbQhGLrjV6nvpHVNw0i9eLhVE0PkEKhhUPFeR9tV/61i7AMhozthVUhxtA8CaGQZSuqeOSRR5gy5Yuvr7n95drmC93iIEpJup5YYHBT/WmM1RNGmsBsfbXieq%2bARKyB68%2bGgqp3sK6G0AGRjW6QrQXil3P5qzUoz%2bXbaiH18XISgSWI%2b%2bxc/ymNnqIg6ZOJ2E3GIA%2b7xadsgObh74KXDqDVNEM3FcGPBPTv0ciki3/Oyd/5NpddfiUzr3uWZFLSsHwl9U4Ru5WvZq8eWxaWNYq//LeIRi%2bBaxppdBMsN1UMFQHWemyNlFdIqfmMmM2Wb17KAxvwr7/9nSEjRzJi12FbPb99BqGFRqsMUsdwgjjW%2bxyLYf68dzjlrxczJdwgrKgTUKWKcLUglo6QcTcUyYWhIBnsQIQ6zDaKLIkFUYBrDH978HV%2b%2baeFWzw26tcy8NImHK8QKVds9bqeFkQzAq1ckD7ZmjbrxJWhRMsiFDWsUeX0v3QdCMWPLhhLxhTw/PPdGDWggSGF64hIk61m3eaBbR3FeGmsjiDDkFlNgmBRA04owS8Ed4OrwncK8YK1oEJ6NHyG1galJOMveoMzTzuGB//xNtpZwdSD4uzVY2vZEnLek2txCh08AkLbhPVcSos8hNn6aLsVGmMVKojg2DS%2b5%2bDYDKef%2bmNOuOoa7tuGsNqljRUJEriZMsDBdxsQJoanHVxRu2lHRidRW6i%2bQpUhVhgnI3syc/bWi1wlfDJk0AKM3ka9KdI8e8pPmfnTmxHh1kusmO8TuAJlfVKqfKObaqxTD1ZQGHRDhDF26FvEqd%2bXLJzXm%2bVLPF6YUYz3/ly0brs2Q%2bilkX4MKTMsr%2buN8EN6//BKqlWE1o5VAM82YhyB9S3Xn1DBpdOuBsBxXf700BNc%2bPOfce55UznikLHbeG4IheLZF19gbX09dQ3V1NfXc%2budt%2bGqrdcJMZPGMSFe6JPt46aR1iJtkganeJuaaBdhpaNppNeIIIWwoMICCAR%2bWITdqFCMRwN0kGn2wLU1aFrEEJQzeL9z%2bfnvZm/9pqYBI0Ii8SjBRu8f3JjGqCGSsrghpCPbmNpufQgVGodYUNP2KxTCKFCWmPchr19Ywr%2beOpiiZAU77LaKAgQDdkjTqylAqrZvqreCrNtdQvW6gL%2bdOZR/7vIkddEE1tso/TaDFhLhwX59V3P3rTdvyDApufzXlyMMzHxlzrYzxwqM2VRE24rXt8bSJGMINMoEWAOaOBHjo8LSbd62XapCT0uqPriDxjVvg3Ww0qIdjdCSiI21OfaiC49n6vUvgWWTHl3aSxE3mrSMooxEsOWhC0f5SBcqKrqRrNv670NYhwBBOmIpCLYuQhOXrFrTg6E3rOHW75dxxuANEZ5CGJQ1WDwIBSNLVnL6917jgvv2oJvR/OB7HxOs%2bAixMED4cXA3DFK7gcJEGsB4jBqwmpHuamRjhEzEB7dtJlsU0lgMAqPg9CFt7RCLxTjisGP4500PbEfu2M37D%2b3Ws77J9qHHxctJE8ciUBRhhIZIhJiz7fHKdhFWSIBwfJDdefWVJxFSZZ2XQqA3egvDYZN2JXHdyzQIgVF1wIYqozADgVA4BjauHoRVIAKsdBFGkF77KTrUjNx1EPNmLUMaQSS0ZCISZQRGgJbZPlzcaIRUeGEan5KtPotMO7jakiYkdeDBVK1%2bnoRYSyzlgecjLAj87EQL1%2bX6Q2r5/dONfPeQKEI57LB0NUY4KGejyAepwSikDQi97IrJiAwxP2tBLVyUCUFahAxbhhKlDPjFpEIOPeFcnv3n7S2Xm3TwRFa9vBPw7rYzaHO13jZcFQWplTihy2OPPkqfPutLKAtS0rNX723esn16hbaI0t5HUljucMcjS8EWtXjaXa2579//4e4bj245XifXogqL8SlDsb2j9RorQFuJq%2bqp/Pw1kB6DBvVh8OC%2bTDllHHEnSlqCMBJhwVk/JCdiSGoxDGyZiLolrBNgvVpEkGDM3hnCD3sQWbQOIR0wbdMqRUCvWIwHr3mVEw6fSHGYoaDJR2lF6G54RQoAYTFSJLHSQQWC0G37w1FG46ts7NfG7suePeqY9cf/ALe3%2bXzytyfDf7curPWO0U3zbOvWDorgyXMEI2pvwfOdrLNZaxCC8FOHzIRbiZRtecXn9ukVqipsogcioXhpQRWRYEMPJ3AhIqt58mmPt999l9pVqxg/uhf/XaSoRRDbzjFEKyxGCIQNUcn5hDWfsfPQvVqKeSHghltvbFmsdtayj/lY1%2bNpcIyPsC5%2bj1LUNkYARBBHhFGMqKGmugCnZCS9gvdJexmivptdCrKZlIoTkSnOHwbPvulzWrfleNZmnXAbZ1ykDhPAqkh/CnQNjm7b1otSi2cy%2bDKKZ9Nt0xQKTu25jrq6eoqLNzhTHbH1ah1AYnj4kSfoVuSxy86DN9hzG71u1w8ZN0CSrplNbG0TgTLNnS6LZx2WvD2dZPcxjBo9ZrPnb7%2bwRIhLCmMNgXDbjIxL7YF1kGgcLbCtHliGESImYMrkozjhvEs5/YjJjN1vLI8/8zGX3/Ii9Ubheh6RjIPv%2bIBqadgbG8sutG81Whg0tcR9WDz3XxhRwMN//XObJJ577rktf%2b%2by9APuXDybglCSzr5oEEuGjAlJOnGKTSPGsbh%2bAdCqoe0kwQuxyvL4P7rjmjTD%2bkZAZTDatAkXioYKYV1%2bdFiC0vNn839XZCNHpYigjI9tVZ2bwGN1bR92uXYpaWuxzZEOFoOw8MY1PRgaW0silcE6bduMgSO49IgoPzrvGv72l1aRHKq4%2bccmgGwpbVu3Wy1oN07V8g%2b4%2b447EEKxY99%2bHHvMYZRaL9uhoPl8K9p48jNuARHdSEzXAQI3sM3DZxIjQv560zT%2bsXo3Pnhn%2blcTlhGWjHQQkF3meuPVh1vEZGnd2QxNIRqJtpo/XvdLopGsY%2b7E40bQUFvNzfd/SmMoCJw00qpso9IqEBpHVqGlhy8kGCjVkg/m/xpjLAOHDGXMblteDuiQvrvw149mkXQMymaD%2bQTZ8GBfRIkYTSpisMbitipeZFqhQgcZJkAplBb4FFPclEKYEOtuKE20asAJEiScdciGNAWBB1JgZdgSptxiv0iGc%2b5bgi8l%2b985jURguHD0RHqWl6MEyKr/Ep91JsJmQ8BaI42gZ7c6nrr1b9BKWK7xMUI0t5ey92vtwBWAtSEXXngRFaWF/PneP/L5qtXc%2boff8u3YG4wvac4n0bwmRatzPdvAht/Q%2bi%2by9xACEpkgG6e2BbZbWF4ocXEJrcKzejOjX1s4z2aQsgnr2k18Wmf88ECaGhdx0z2fIiuGYGSANUGzG8IQ2goiNkXEX8mqxTNZUfkWnmlk5J4TmTVr%2blbvK4Tg0jGH8ssFzyJs21aGVYATJRJoQuEj9AYzmIRHXZAgKtZw9GnV9PCTJN9JkUg14qSKkKZVaSwt2AxguXx8GVLWYcMikA1g2ppW1BcwY50hLI/Ra6f%2blDoRDth33w0HDN6ZzFs/xnd8CvyNeolSIpCcNbKGma/M4YDx3wLAd0uJhhJtLMoR2WDCVqq0eMRtkowR7LRTP66%2bJusPWzj/HT55agGOWYWxunmK2ibeny2SkQojE1sdHvlCMe97De3DnM%2bqs5EL24kISrDCw2U5DakMEW/ToYQZM2Zw6GFHEqpiiorLsTYbH%2b7rFJm6KhzRAEZhnJBfXXwtv778F9t9/9vfeZGZNZ%2b3SXEfP8Cp/4Q7T/4tMjv030IPY2hCUiUizPjoEEp9n4KmIpqWL2XilNm0fk2ABSJIJCH1IsHUs/vz4D1LCGjEmrZuYOVpTEYw5oc/pceU0Tw48bs4G092tZbhrsvSjcyrRTZSI6ME%2b008kxlP/6H5eE2QbqIiUYRBNsdZbTg5iiVpDdPnLGK/MUM2sU3t8vcZMGA42shsdNt2jqNZaYlrSfnocSya%2b9Lm8/2LCGv2669R15jc7kzN2mqDH%2bXggw/e6szhNatWM//dBTz4x3v55%2bOPY63lgP0m8OMLz2Xo0GEMHDjgC917PefNfpLP66qxrkJgSIjsuwxrF7zHxMRi0oGDFQESB0%2bDtTFEoWHM3hmkrcUJigmDFLPeTKBRFPqaBgWSCMg0wrpIayip0Kxb7WCcgBUZjwUNvVrSoKwgGREU7z6S28cdSY944WbTuurzZSxYuGjzmdW8PtfEiRPbfP7cc89tsTEuhGCvvfahuHjz99vauVukuV1XUFTAvvts/u0anWKWzraw1jLlvw%2biQk0gJa41uEFA91iS75W/iefXkQqKSEQbybg%2bVoYUpT3in6QxPeNUlWu8II2hlO4Nmhrfx5ZJtKK5XrVYGRJaB2VSCGmZ3ziSR1K7t6RBWQsIJnffmdN33fvLPso3hk41YXVLCCH4w5ijaIgIPN9irUErgVEZkPW8t2gwf/tnEU88XkzEL8INEiT/%2bgnOyXNYfs7zFGZiGFFE2oHK056m4OjpuDMrQaRQ1iBFhtUrC3jswXIqlw/CEQrHSLyQls1RLsaGfG/YXh1tjq%2bFLiEsgB6JIk4rH0pTROJYjbAKoV0cLaivzU5MbaorJO0lMUJhM5KMTFFSL6mNZuO7o1ZTutwQmATJdSlCW4hFYnB5%2baVSalMVvPzKOjQOwtEYwYYNuH/f73b69d3X0yWqwtZcNudx3k024sp1DLJNnFf4Eg1ugspKRXmpQMeqqIsaooFH%2bUpBptRjXUKghaXQ18QbAhork0QGlOCYoNmtoGla15cX5mbYYw%2bX0m4rea9pJx6t3R%2bNwLOCK0ZPYEh5r6%2bc/m8KXabEWs%2bV3zqSeH2cRl2IVk34StPoGOI7alLxRkRYRlljGbFUnGRpAqMUFUlJRaNEWJdkLEG8Tx%2b0iNLoujTSk6Qqhe4NHDoxRc/S7Pt0tOmBqwXahZ2ihV1KVNAFSywAX2t%2b9MYDZFKGno1JFhf3QNqQUBgKtMEIh4y0%2bE6IMFEcI7JzCIRB2RAtBY62aCcNYSmoJFiLMFEkFp8mrCzEKp%2bStObeiaei2mnq1jeFLiksgM9qq7joradZGyul1E%2bijERLgzIhRrjZxrc2GKUJJQhrUVoSSIWWFoHAEjZPbQ7BxAncVHb0QGqEdcGkuWXMEfQvKv/qCf6G0WWFBfBp1WqueuNZaksUZlvD/a0QItvTXG%2b69Q1yrU3Lvqstx3YbzMmj9t3u63YmOt3Ca1%2bEgd17crgs54NXF%2bI3pWgdkmDMtsc3Nv5Ntt63UnDilSd39CN2GF1aWOl0mpdfmI6jPKy12%2b2BzgYFiE2Ob%2b1KsFazcOF7jBo1uqMfs0Po0lUhwOqVq5g/b35WJOstYTeIZP0677IljksgpUAqhVIK1TxEZYzBWkMY6paZxuMP3L/L%2bK02pssK69xzz0VKSSQSIWj16pKNhdASSIhoFk/zy5fEpnGZQjRPtG2%2bxPqluq%2b//npct3O/n3BjulYfuBXRaBTXdQnDECFEtvRRCilly2t8lVIEQYAQgoyfQSqJkALTvIKybf6nTfZ1KNoYTPNbw9a30YwxLFm8mHAbM4lWrlxJY2Pj9iT9m4HNs03efuttW1ZWZh3HsUopK6W0QoiWbf1%2b6/9bHyOltEopO2jgIPvJJ59scv1LL51mhRDW87yOftR2o8tWhdvDvHfmsfc%2be5PJZL76xVqRSCSYNWsWw4cPB6CiogdVVZXAtmPRvyl02apwa6RSKfrs2Jfdx%2bxOJpNBqfZ7GZNSimQyyciRIznllFOw1jJi%2bIiW7ztLdZgX1ka88MIMEokEn69Y3lJ6rJ/50x6sv5a1loceeohYLMaY3TfEbXUWYeWrwlZMmjiJ5194HqVUu4qpDS1dx/X7tLg5hBC8u%2bBddh2%2ba0eb4ivTJUssvZke2iknn8ILM17Ifp8LUQlACoQUSEchlaSkrIzddx/DgQceiJTZ5StXrFjxlW/1P0FH9x6%2bbo456mgrhLCjRo5q%2bezuu%2b9p6cEBX2hbf87GvcDW%2b%2bXl5fa0006zd955l1382eJN0lRdXW2llBawt916a0ebqF3ocsKKxWItojDG2IbGRuu67pcS1XpBrRdFeVm5Pfnkk%2b1jjz1ugyDY7jSlUumW%2b595xpkdbaJ2ocuNFf7sZxdx1VVXAnDC8Sfw1NNPtfW8y6xHff14IDTPNGreLy0pYeDAQew2ajRj9tiDE088geLiba8XtTWi0QhKKYQQTJo08Std63%2bFLtl4X%2b9hXz9E09oEQmXbOhXdK9hv3DjGjRvH2H3HMXq3Ue3qdtiYuW/PZe26dUyceHBHm6dd6JLC6tmzJ5WVldlxPykZOmQoZ//obKZOnYrjdLlCPCd0SWE1NTVRUFCAtRbX9fD99vWs5%2bmi7oZ4PJ4NhxEQhD6ffba4o5PU6eiSwgJ4Z%2b68lr8POOiAjk5Op6PLCmvEiOHE4tn1UY88YnJHJ6fT0SXbWK1Zu3Yt5eVdbxZNrunywsqTG7psVZgnt%2bSFlScn5IWVJyfkhZUnJ%2bSFlScn5IWVJyfkhZUnJ%2bSFlScn5IWVJyfkhZUnJ%2bSFlScn5IWVJyfkhZUnJ%2bSFlScn5IWVJyfkhZUnJ%2bSFlScn5IWVJyfkhZUnJ%2bSFlScn5IWVJyfkhZUnJ%2bSFlScn5IWVJyfkhZUnJ%2bSFlScn5IWVJyf8f03l6s50K6nRAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIyLTA3LTI4VDExOjAwOjMzKzAyOjAwmirGtwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMi0wNy0yOFQxMTowMDozMyswMjowMOt3fgsAAAAASUVORK5CYII=' /%3e%3c/svg%3e";

var img$2 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8' standalone='no'%3f%3e%3c!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg version='1.1' id='Layer_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='97px' height='97px' viewBox='0 0 97 97' enable-background='new 0 0 97 97' xml:space='preserve'%3e %3cimage id='image0' width='97' height='97' x='0' y='0' href='data:image/png%3bbase64%2ciVBORw0KGgoAAAANSUhEUgAAAGEAAABhCAIAAABJZFj0AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP%2bgvaeTAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAW5ElEQVR42u2ca3Ac13Xnz7n9mp43MBg8ifeTBAmClCiJpEiRkkyREilZiq1YdDmp3SzLWxUn3k2ptrZ2q9beinf3i3er7CROWUpUcbSOZK8iik4sWqQoSqRB8WmKbwLEiwQIDDCYJ2Z6err73rMfBiQhmuIocTBwqvCvqcJUP0//5txzz73nNpCIYEn3FVtsA/4VaIlRcS0xKq4lRsW1xKi4lhgV1xKj4lpiVFxLjIpriVFxLTEqriVGxbXEqLiWGBXXEqPiWmJUXEuMiksu5c045wAgSdL8jUSEiACQmZ3tO3bM5XJt2rSJMVaYIC3smi/TNBVFuesiC6qS%2btH09PTBAweTyaQQorDFcZxoNJrJZIQQQ8PD8XgsnU4PDg4CwMjISDwenz%2bVLISYmJjYu3fv%2bPh4Kc2Wvv3tb5fsZpFIZPdLu2eiMy0tLaFQCACmpqZOnjwZjUYDAf/Fi5fWr98QCAROnDiRzWT6jh2LxWLhcNjtdhdOHx4efuWVV773ve/t2LGjrq6uZGaX1I9UVdNc2sC1AcdxAICIRkeve7xewzB%2b9KO/bWpqqqysbGxsrKqqOvrLX27fvt3n8/X39%2bdyucLpmqZNTk7qun6bWmlU0nhUU1P9lz/4y3373kkkEgBgmubw4ODTO5/RdX358uUtLS2F6LNly5aenp5wOOz3%2b0dGRgpRDAAymUx3d/eePXtaW1tLaTaWuHYkhDiyf//xY317vvrVwLKGtG2Vh0LFz8rnrVRi7zv7HFn58u7dLperlDaXvO%2b3rF5V8vR99P5//Mbsa3/juRW87yMSwrjWf%2bm734n88M/qIjcVxy6xyaVg5Ahu2FbOsXOObVp5Ox7vbWtLOs74xFj0/HmLO4WP6diFT547%2bVsbbc7zpjlz9cql8xeq6mpa3YqRStmc25w7QpSmCSx4WzO5s2/kfNrJIyAhSYROPM5nJqSp2YdWrmlqaXW83gvxm%2bM5wwKAWzkRAspEiCyoaEG3%2b2b/1YsXzsqKVNnaKpVXKD4fI0TAx2paGrxl%2bJvaWEQLHrPzjv3R1EjMziHR4P4jlS3NXb1dDy9vqO1N3cgfllw/N1LBoHvllF3RNzmdsrIAwBn6Ja1a0tttJZI2zidnAoHyFb0bbrrEh1fOn/gf/6fnD3e7QyEAaA2EGjxBwIWltOCMdFlZV1H/j5NXJYLMeGR1b%2b/maneNfqLCBRXW2miiJuiLMzzS4ff5lcfem5iZyKa8TF0O3v59h/Z/fHo8KmkelslIVWX2E48/smXnFvZCLh3P2GVBj6wqrBTZ9oLHI5lJq8prQoqLGLY9ubG3t6lWH6j2NFa5/mDoFB1%2b/b3kFW8l%2b7obyzTpQLvf65HlJsU7%2bP6Rt975OKd2Vi7foTU86WnZFVi2dt%2b7F64cOLZhw3ql3I8AXf6KOrcfF9iJSsGIITZ5y5YHqmTA6vbmBi9nUr5M3uSSKnSX569efeVP//Q7g1cmw9o2XbKbvEaN5lOn4kd/8XFN7bpZqWMk4Z6IlkWSnimj1lfdfPjwGWdsurwqXKbqnYHKoFKKJKAU/VpQcz8Urg%2bpuqap3eU5WfZbpn71an88lrQt%2b%2biRj44ePaJCRa2nQZMmGryhTCSRzLqUYEXG8hmWknMkh8R4wm9LVVNT%2bVT/da%2biVah6ZyCsy2oJ7C9Fni0z1h2sWRWa7k9HdUgL1Kei8T/5k5cvXrwQjUYFiUQiQQRBzWtTzK9q6VRGoFxdNnZpog4ZFwCAHEiWiZV70TZtF5ObvaE6d4AtfEODkuWQAU3fEG5UJSWSqTasJJKRSCQmJ6eEEAwlRBCQzeRT5PiHE1PhcMiZTV4db3XrOQAGgJJQPZqVc3LxPJN9Lpmxek8w6NIXzuC8ZZmmWVJGCNAVqKxSXNezCmMZyTXctaLDpXkAoKy8vKamCuDKtBEdj3jOHjvprQi2NOpS5mq1Lxlw5f2unNeVD6k5lSdam3yBriZVkntCNQgL6EQkhGVZJWUEAIokrQvXn09l4mYr04e%2b/JWOjs5mXXdveWz9pke1Gf5uzGo/NxA5/8GRcSPx1O8%2bGxs5ZUwPuSDdvWxSQ5vnrhuxsd4HusyQu07z1rgDC2qty%2bXy%2b/2F7yUd0xqO/b8vfShL8obyXDnryyfOX%2b9PldXqwYanBev6WX9m0MpFJyY1ZBs7uvHMtdf/%2bo14nFwa5Z1A9TJ9685Nvt7mCdX55spN3WU1JTO71OP%2bk1M33hg5K0tsVVl1pcoUZuaFK8ml09MT1y9fToyMgSaLvF3R0tjT3bXKV5O8Nhobn1S8rqY1q0YhfzEZqXP5/sPKzUFX6aaQSs0o59jXUjOZfJ4QXTLTZcXiwuDW8OBwMhZNXp/glo2y5KuvqW1qbF3WENa8uqLY3JnJZWaFDQBhzdMeDJemRyuopHNsAKDLyqryagKiWxEXATjnQwf74iPDQggiIoBUMlNjsbVrNtz%2bAau9fgAsHF9KQIvACG4N6z%2b1RZLCFaHpSMS2LC4450LTtM7Ozk%2bzKCmX%2bSpRv3b/Fu04zujoaCweS82mA4FAR2eHJEkTExP/vKv9i6sUfiSEmJycTKVS4XCYiLx%2bP8pz4/Xb7a2mvr6je8XQ4NDY2I1YOpXPW6M3x81fn3IkyudM7jizs7Nut7uioqIEY9oFj9lEFI/Hf/zjHx8/fnzt2rXXRocf/Z1d7oZaAYCIEqKEyABHRkaj0SgIACACQkCPz9u9YoVAEHf8hux0pv/AER2Zz%2befnZ3ds2dPILCwiRKUwI9s2/7oo48%2b/vhjVVX/Yd/PRq3Z2LpmnSUJAAEZAgOUBTAACus4hxUAAFAMjV7kAIIBwRwkZzbzyUcHxOjk9iefmpyKtLS07Ny5U1UXdmS7sIxs23n/4PvXBq4xxhKJ%2bHQmWfPCVlFZZvI8clQnMloiiQBQ6OQIkQCBJCJCC4UCAAQECI7M0g2V%2baCH6VrVjs0X/vsPjn18sqa2%2bsTx0yjJO5/eoSjKwj3F3W3NccS5S9HL1xL37EeIOTXV6sY1DT9/bzDnyIgABMTsxlp9ZUf1J5fjExFj7kgUy1s9qZnB8%2bfPrV7dE4lE3nrn7claT93OLcjkjtmRptyYJTHZdnBuDhsAkAAsyT3tqppQQwapAASEAEgMhMzbc8P15gwAje07FFbdzc1Nbo/byORbNv9e%2b/pnXLobAPjVNyUz%2bllPK2Qfr94omxM4cxHg3iUZroV5wzbFXXY70t3tR1xQ35nxP//ROQJpHrw57we068OJ//ZHW77/w%2bNjho8hIgEwu8of2/10x8Xr/vf7xm%2bfsKI%2bsrbd2b7t8dWrV5/%2b5GzdxgdYSwglGQWtTZ59dmY/EpdJzF2ZCk5DXJKjrooBefl%2b3DoteRCAkBAwyGO7zJ8/bF0CAOgFkADgKhBxj3T4YHQkJnZ88QVFUfivfgBTfewzKiZpy3Va/XJLS2Xj%2bKvMSt/yk1vPBwAAKag6EX55w3N7AoG58do9%2bn6OyJEEs%2bZ98kLKCWYKdIb6By9fvmQJQjYrpBwxiwObiEwe/vAYMD7vFOfSpYset7%2bnp8ftdtc1N4V6V0geN9gcbWEz4TDGJQRGwFCgFLdkkxgpyJBX56c3GCeeyhzNOIZREchV%2bMwK3R1IVcMMISASMkIiJEIACUWNc%2bHDfa8f/eWxXC7HBCG/tffXPvlcru9I37nz/WLeMUAgQCaSOEgCpFQi9f67%2b2diidtA7hmPCiGC5r44s87sCBc2ECKSnR527DUEDMERWDidhCDbdj71cwBJDMuCZZrmAgDF7VL8XkjNSoapJHJy3gQChnN3yznK/zzqeaTHvav2pgKcEchk1hsnK0bYtLXe43MrYK%2b0%2boM8ffs3J2AAhEAIVB%2b06iLjv/jFQQmcB/Km%2by7HuNMWEJA455bjfGq3kPrGtLgBAhGApjPKZCIv5hVHi8ds25jywfDul7a53ZpLU4Ee3Lj%2boTf3HwNw7n8i0h1TBQAJEMDI5yVdoymVZUAmQAYkAGzqT3ga2h/l2bcUIkIBhBJZLDacUNfJ9QHVijaOT/m4xRABSIAkmIrEGTkIwqeJRlfMUJVzZz6px0STYISE%2bCkOc70CMZojOG8vYz8%2bq6x57pserwcUtxvYM5q/qrLin8BI8zVYPPTuadnnkX7/udYv71qvqiricYT5ZiD8Wp6FgFyIjGFJkpQ1bG46PC8k2eGahBJjAEwAIACSrDq7W2OrzRM62QiEBAJoKs1TyfzDen%2b7LxacGWk1r%2bMt6imDIgYu86NPpcKd1tXM6nVS%2baqNs8ffuGlMIvJqty3jbV/AqVkpa7O4AbbAuw0l5zs7ZfC9raGUbdzte%2bTfe73e%2bfuLMyJ0keyOJJzJWO6tt/e3L9MfevghZESoSEKmQvQEnfOM7dzVU2AybvztWxeSWWfWyg8l0rGco4UttdWkeQk0AUoqfekRQ7aHGXACJJAMR339LIt75W1KtjLOV1vXypwMAAlEJHY1Kv2vPvm/bmUPVdnICIQcUI3EwIctG5%2bTN/yXV1/9C2Nm6N%2bujHYFc6wAhOjgFTicXOEvC2SDIX9QmZ%2bdC2RlckIYcclh7%2b37US7e%2btXfeXb%2bOrmijObGn0SIjnN9dGQmGgMAmeUFuBQhccYJQFErZwzZmkzd8V9wCLmRs458NHT1Rub2dp4/F1yT4autO0cSEYf5tVYCsDgoHu8XttcLERq67DzkiktECCSIEaLNfY0tQdlvEpgIhEgeVdSJoYlr5x/YsmPtLuo78HoOjxLkbl8zkuF1Dz//3LNPS7JUk9wvXTwwzwDOQZYdIqTR0dHosqgjYP5SwuJ%2bZGWHregxl8qIkRxESZYAYP265uuHbhISAHBGoHpnHFf85h0WCJaicLdP/3SWhUYqrU7EYdW8bQxyedd3%2b%2biFNbAqyBEAgIKa/bUV5pAXGtvT3DXpHcsiISAhCkJpdfVsfY0d8nAQBEBAXGKwTIn0j1/weL609fEn7dQQDB77VGsAaO/sfHDdgwDAL5yZ70ecXP/552JGhJGpU4b6gMt7V2ZYnBGiFCiv/73du1wujyJLzFWXnjW2Pdb59qHrNiICkwQBAJHMOQEAEhITVibixtnenjZPGev/izdsEjYJAmRWlDENgH/KfEGnp9SNXR1tyYu6aSJwBN4eMIaHx9PVbI11g5FDKBAQiAGB1829mC10vIIYQ4EALRXWB6ffGn3q37R3dG7dvME2KiEzM/9BHMcurE%2b9Kx5JZLZX%2bH/3hX/ncauI6KkEJkwAz/0Z0e2UDoAkvZJD%2bd4jaYmZiKLramTk%2biUN5a5l%2buUJ4oLmUS%2bMKITgRj51NVAHLa0NmzfVpKf7JmMzlxNTsXwWwe1rb2TqICHMracFBBREYPgqM1m/ljclQgKQGNNjycRll6wZKBAYAIEQ0lhWi2SJEQBAfRkP6zYQMBASoyZ5IjlxHTo6AwE/hELMKPSaVLDs8pWrQ0NDoVBIdzibP4xg%2bJU1OS3%2bNywpAMiYabhs%2b1ofeMLjcd%2bHkQDkty%2bBKAMoybQNYAPg0RvnyrWq3//K8y3t%2bit/d%2b7ElRmHAwCDwkMAcSfH01c1Htmx7cWqykrdrf/xH/9RNm%2b%2bO37lvZsDec5RkXjsBpfIQSZTIYkl22FnzpU3eb1lMMOACECTYZlqn7t4027Lg4xAjADGUuy7h6G/tre1onqZP7hGm94q3nUVhnqIG5r4a%2b%2b%2bvXbTkwgSoSQQCyknIBFKEtKJ4yc5t1eqV7o5VxCBCqMp9GkCzIkCzdmpxE9/%2bVd/0NDb/FmMJIZVZZJPikfjCUF391NIaKWuN9WuWrlyOSLz6OzPX/vw8IkBW8gIkiAb%2bKyZHK7xG7te/MJXd38pEPABgM/n8/l8T2jSgJO%2blo4DQFyrOJ8Lz45PI2eMIG%2bjI6BjRU5zPNf6PZM3swQC0ImlKeMoZ0clSTgECAj90%2bLoTGDF17/04obHH6xulMyp7C/yx48eFMAAAUgM3jx5bfBG%2b7Jgvmzt%2beNns5lZAEBiN2Kwdnn3tqe%2bMDFxU9xMzqS6r1w%2bcStLhjvpEsL0LL8xk3CcO9HgbkayzLY9Wj8xFBgYivFfX4hHMoiO5cvbGGOMsd6epv/0h491t4iLVwaP9R2dmYmuWb187ba1q3uWb9ywcVndp8o7Db6yHXVdNzIn88I%2bW7buarmeGzzhsgwZSBZy1yNaa7slrNozN11nsjkiIiYhE94q7YYp4oYdtXRTKA5CYFv7cw9sXNfY7lNd4PNNr/72qQuNGTNfuIuvMxCdmenqWOOs/ubpYxi1ooSAAHovtLW1hcPhcDjsdHUMne8%2bevn/3nNQSyp2tDUG/HdSpHvPsdm2bdv2Z02/KYpy15SNmTPjiXg2m/X5fGVl5Zr2mRM6/2/03NvXL3DueDG/Wbu4LDMFKPzlpnoj60875nLd4ox9khUVqt2oc8GyhiTLPCn738usmeQBGXFted3XezaX36odEZFlWYXFzLd%2bZlnTNAAwTfP2mlwAUFV1/hRKNpv9LCMZY5qmMcbu7Ue3KfyTZmRcuqtWr/08R26v65zJZz%2bODAthqDKfngpms2a3j%2bujSXpvytnThss82qlx8MlKW1Oea/03vAisqgdUR9a4q9lf/oWm7vJ5xTVE1DStAOVuq%2b67/Nbj8cDnU6nrIh5Z21rVOplJj6bTLnIqG9KWIzS3QyvLRIUHG72gMfFMPckSyLIErKKCA1oouQjBI6uPhpt6gqWr0BZU6hokADiC/2pm4u9HjyuZYUUjAiHPddGFyVtAEggkGAdSuCAJWAblGA%2btDbV/pXVNuctT4irSItTXZCatqagFWvfqgBTPGygIgBgxBiRQICEBEgMCASAJAAJSZandG9pa21Z6QIvDCAAUJj0QbpgeHjt44aRtWTDX/87z6HlTQETk0rTN61vafKFFqUMuDiMhRM4wylFutCTHum3DrQIuIiIiY4XpciJSheLLE7cdkBdwbv%2b3i1Emk/nggw8mJydt0%2bRc3B5h3v7DgCFjgFSAZHL%2bqzO/QsQHH3xQlu/Y7DhOIVNbUGsXIWYDgGmap06dSqXm5lIKjDjn1wauHfrgUGZ2luZSYJj/NmR1dfW6B9et37B%2b48aNjLHp6eg77%2bwNh8PPP//8wppLiyQhhOM4juPYtp3JZC5cuPCtb31rxYoVHo9HlmXpM6SqaigUeumll65cufLWW3/f2dn14osvLrSpi8aoIMdxxsdv/uQnP%2blZ1fM5m0whWLW0tHzta19ra2175plnTNNcUCMXJx7RrfeMY7HYK6/88Kc//enAwID4HO9pQaEsiTg%2bPn7o0CHDMJqtZjNn3jPP/pfSIjAaGhp64%2b/eaO9o/%2bIXv/jGG2%2b%2b%2buqrkUiE7hUWCxxdLt3t1gujsI6OjtWrV7e3t6uqqmran33/%2b6lUKplMBoILuDJiERiNjY29%2bZM36%2bvrJUl67bW/npqaornSDgIQImqqFgwGw%2bFwKBRSFKWzs3P79u3Nzc0AoOt6IBDweDyISEQ/27dvYGAga2R/U5vuq0Xo1zKZzDe%2b8Y0333xTVVVELA%2bFZEX2uD2rVq3q7u6ura1x6%2b5wONzc3FxXV3f/9/gPHDgwPT39wgsvLOhbyIvgR16vd926dXv37jUM4%2bWXX96xY0dlZaUkST6fz%2b/367r%2b%2bZddbd26VQixoMEIYJH6/uGR4cefeKKsrOzw4cOc80Wx4fNrcf7fSF1t3bPP7gKEEydOLnSW/JtrcfLsgk6dPlUWLG9rK%2bnL%2bv8MLSajfy36bffz3wYtMSquJUbFtcSouJYYFdcSo%2bJaYlRcS4yKa4lRcS0xKq4lRsW1xKi4lhgV1xKj4lpiVFxLjIpriVFx/X%2bwKtHxkRbZIQAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMi0wNy0yOFQxMToxNDoyMSswMjowMAl6qLoAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjItMDctMjhUMTE6MTQ6MjErMDI6MDB4JxAGAAAAAElFTkSuQmCC' /%3e%3c/svg%3e";

var img$1 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8' standalone='no'%3f%3e%3c!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg version='1.1' id='Layer_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='48px' height='48px' viewBox='0 0 48 48' enable-background='new 0 0 48 48' xml:space='preserve'%3e %3cimage id='image0' width='48' height='48' x='0' y='0' href='data:image/png%3bbase64%2ciVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP%2bgvaeTAAAACXBIWXMAABJ0AAASdAHeZh94AAAJDElEQVRo3u2Ze4yU1RXAf/d7zGOXndl1l30IZVlBQKSwsLAJKoLIQ4lWEdKsJLSkqVXZ0taa0hIeblFaI9DUUttI1UixMQHb8Fgaqk3Vsrp0scFadiu1FYOAwLqzr9l5fPN99/SPWR7yqAszdG3iTc4kc%2bfec8/vO%2beee%2b43SkSE/%2bNm9LcBnwP0twGfA/S3AZ8JgEgkcl5fIpFg4cKFFxy/f//%2b7BFIFtqmTZtk6NChIiLS0tIidXV1snnzZhERWbdunSxevPj02B07dkiWlhURkaxoamtrk6/dd5%2bIiGzdulW01nLo0CERETlw4ICIiDQ2NoqIyFNPPy379u3rHwCt9UV/e/fPr8sz93/9UxR48sDMW7NmvIjIpe0BpZCLHNwjj31I0a%2beoXvrdvRFpr8zdw4PH34ve/EPKJHLLyX2HD/Ed/66i%2bhbLZRMm05tVTnX2S/y7rEJPPdPm2iqjbi41IyrpvONv3B19UT2BUxeWfdzymbdwA/HTGfOF0ZlBGBlMnlKaQVhf5COSIK14wIMNhvwpX5CRUU9w0NH%2bd6%2bAXzji2N5aNTtRKK3AC9St342E0aPptO0uLFkaMYeyDiNTiss586vfoUcaWRQ8CGK8xR7dxURHhBh1rXjeG31j4lEv4XyTUHZ91P38B%2bYO2MqhXaQsC/Q/wALhlViuR5lBRVseXE7AI%2bvf4xh/krK8/N57Y//BgpRJEFFgakcePU1bisfnbHxWQEYHioiZAcwSPHcsy8AYJsBIEKnk2JImQ8wSe80EzhKoLSY6aXXfDYAAEaEr%2bL9riArV1QCsOIHc4jg8d27ali0dhnwGJLKR5w4g0ubGDB2LMNzCrICkFEWOrvdvOs3PH4TTAx/yHtOESt%2b56c7HMeMdDM3v4RnV6xlaEUpkx9fTqQnwWPjZ322AFraT/BBtAdRNn7b5I3XX6a96e%2bExwyn6pabqSy/lo8T3bRGIlQXDqbAH8wKQEZp9Ow2uqCE0WdFRdM/DjOoqJjOdw9z0%2b0DuQofQwKFcHVhtpYErmA5HYvF8Ns2Ab%2bf7q7uK7VM5iG0fPlyuto7GDJhDBPnzkG7LgF/gJbmZuLxOJ7WjBwxgpzcXDzPwxcM8PpPn%2bXw0SNs3LixfwGam5tZcO8CrJRHeG0tvoAf/7F2xFDYlo1S6XFuykW0RiwTPWIQu%2b5ezPSK0dxT82Vqa2szArjsEIpGo2zdupWNT26g/ebrKC4ayFXtSfK1Qb42yHU0Ocm0hMQgrCzCYhI62sGdm9bxt31vMWvmTLZs2dI/AMuWLaOuro7iYeUMX3AHTjKJmAbJggE44VyccE6vBHFCaUnl%2bhERjJwAX3r6R1w7YgStra20tLT8bwEeffRRHnnkEQBUURjXSZHffAR/azd8FDtH4qfFPhEleLyD4KGTOCMGAVBbW8vzzz9PPB6/LIBLTqP19fVMnjyZoqIiALTroVxN%2b/WDAcXC4gaijh93gA/VlULCPlSnQ17QobF9GO85QzB1CiMWO63ziSeeYMmSJWzYsOHKemDPnj0cPHiQGTNmnOlUoADlCjlGkp5XIgyXI8yZ9yQ3XvMBt81cz61DDvKvzQlGB4%2biU6C04PHJ3LFmzRpWrFhxZTzQ1tZGfX09ixYtOv9GJpw2JZUyqZ7aTsrvp%2bMXU3BPenT/8ibcj03uqTnCy7GiM9PO0RMKhfD7/YwfP57du3dTUlKSuQf27t3LqlWr2LlzJzU1NRe8TioFurdfLEXex52YjssxtwBbuxz1D8TQGqPYBgQhPd5vnP/sVq5cyf79%2b2loaGD58uU0NTVdHoDjOCxduhTP81i9ejWLFi3C7/dfUEFFXiEBy0KLoHwKc%2bcRfEe7eeedAixL09hQiFlsEyqth8K0ju5UkvtGVl/UqHnz5rFmzRqSySTLli1j586dFx2blWLuQPtxHnhzG1cHg/xs1Au09wQwwiZuq4tdbJE66ZFXoql//3q2d1RS4jf49dSaPut/%2b%2b23KSkpoaysrG8euNQ2pqCUKSUViJnk1fpCjnbmMWDsDqQ8l8D43%2bMvNvjtM6UE/R5tyR7WV99xSforKysvaHzWPHCqzdr9FE8N3k7CCCKmAk/AFQwbeiKKBuMaenLms2rcjdlaMrsAb578kG8faCTX8qVzqwCGAi1gCIab4E/T7s2a8ZDF%2bwDADcVfYM6uDVi2jeqt5FTvh%2bt6DCkfAtM%2bOefs53dqTr8BbNq0CS/ow7BtcoJBwvn5GEohgGihrbuLpqYmqqvTGairq4u8UB7a02eALxUiW%2b8oHceRZDIpSccREZFt27YJ6SA6T0aOGiW9oSuu64rjOOI4jriuK57nib6EdTMG0FpLV1eXtEUi0tnVJVpE5s%2bff1Hjz5XjJ05IdzQq0Z4eSSQSkkqlxPO8Pq%2bfUQiJCNGeHhLJJM3NzTQ0NGBZFi%2b99NIFxyulmDRpEhOqqph922zm3nU3ra2tBINBFOAplT7alUKJ9CmcMgJwXZdYLIbreYTCIVaeVYyFQiEmTpzIhIlVVFVVMWlSNQUFBSQScZJJh7y8AcyaPZvc3Bw8z8UwTAzRiChEK0SpPgFklEZjsRjtHe0knRTFAwdSWlLC0u8v5ZtLlqC1JplM4qRSpBwHx0mhtYdI2nOWZVJWWobjOFiWiW3bWJaFaViYpoFpmpim%2bak2ZHQSaxG0FkRrOjo7eeDBB9nbuJdoTw/HPvqItrY2uru6iMcTeJ6bHiuaU/VrR2cHbm9/%2brferSHpoq8vzzYzD8RjRCLtJB0H100RCARxPZd4LIbW6XBAaUQrQJ8uuxUKy7II%2bgPYfh8%2b28K2fdi2hWXZmKaJYSosZaGM/x5GGe0Bn%2b3rdbWB9gzi8RhaS3oTKgOUpI1X6UuDIr2RT4moU8kIFAKSPjMQQYmJMq/wJrYsi9zcXFzXRSwBFxQaJWnjtNaIoRHhrL%2bdzgAYysBQRi%2bskU5Ap4D6eJ5lfBKH8vIAIRrtQRkK13Ux0gGMpzVaa7RozF6rDJUOH9uyMQwD0zQwjLQoIw1z6ntfWtaKOa01rufBOepc18X1PJQC27Lx%2b9OvVhKJBCk3/cLLMA1M08I00tnHsqw%2blxT/Aczs6CWSXX3HAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIyLTA3LTI4VDExOjA5OjM2KzAyOjAwNAfC2gAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMi0wNy0yOFQxMTowOTozNiswMjowMEVaemYAAAAASUVORK5CYII=' /%3e%3c/svg%3e";

var formatMessage$1 = function formatMessage(messageData) {
  return messageData.defaultMessage;
};
var version = 'v2-0.2.4';
var translationMap = {
  'en': {
    'gui.extension.microbitMore.description': "Play with all functions of micro:bit. (".concat(version, ")")
  },
  'ja': {
    'gui.extension.microbitMore.description': "micro:bit\u306E\u3059\u3079\u3066\u306E\u6A5F\u80FD\u3067\u904A\u3076\u3002 (".concat(version, ")")
  },
  'ja-Hira': {
    'gui.extension.microbitMore.description': "\u30DE\u30A4\u30AF\u30ED\u30D3\u30C3\u30C8\u306E\u3059\u3079\u3066\u306E\u304D\u306E\u3046\u3067\u3042\u305D\u3076\u3002 (".concat(version, ")")
  }
};
var entry = {
  name: 'Boson',
  extensionId: 'microbitMore',
  extensionURL: 'https://eu-rate-boson.github.io/dist/microbitMore.mjs',
  collaborator: 'Scuola di Robotica',
  iconURL: img$4,
  insetIconURL: img$3,

  get description() {
    return formatMessage$1({
      defaultMessage: 'Play with all functions of micro:bit.',
      description: "Description for the 'Boson' extension",
      id: 'gui.extension.microbitMore.description'
    });
  },

  featured: true,
  disabled: false,
  bluetoothRequired: true,
  internetConnectionRequired: false,
  launchPeripheralConnectionFlow: true,
  useAutoScan: false,
  connectionIconURL: img$2,
  connectionSmallIconURL: img$1,

  get connectingMessage() {
    return formatMessage$1({
      defaultMessage: 'Connecting',
      description: 'Message to help people connect to their micro:bit.',
      id: 'gui.extension.microbit.connectingMessage'
    });
  },

  helpLink: 'https://eu-rate-boson.github.io/',
  setFormatMessage: function setFormatMessage(formatter) {
    formatMessage$1 = formatter;
  },
  translationMap: translationMap
};

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

/**
 * Block argument types
 * @enum {string}
 */
var ArgumentType = {
  /**
   * Numeric value with angle picker
   */
  ANGLE: 'angle',

  /**
   * Boolean value with hexagonal placeholder
   */
  BOOLEAN: 'Boolean',

  /**
   * Numeric value with color picker
   */
  COLOR: 'color',

  /**
   * Numeric value with text field
   */
  NUMBER: 'number',

  /**
   * String value with text field
   */
  STRING: 'string',

  /**
   * String value with matrix field
   */
  MATRIX: 'matrix',

  /**
   * MIDI note number with note picker (piano) field
   */
  NOTE: 'note',

  /**
   * Inline image on block (as part of the label)
   */
  IMAGE: 'image'
};
var argumentType = ArgumentType;

/**
 * Types of block
 * @enum {string}
 */
var BlockType = {
  /**
   * Boolean reporter with hexagonal shape
   */
  BOOLEAN: 'Boolean',

  /**
   * A button (not an actual block) for some special action, like making a variable
   */
  BUTTON: 'button',

  /**
   * Command block
   */
  COMMAND: 'command',

  /**
   * Specialized command block which may or may not run a child branch
   * The thread continues with the next block whether or not a child branch ran.
   */
  CONDITIONAL: 'conditional',

  /**
   * Specialized hat block with no implementation function
   * This stack only runs if the corresponding event is emitted by other code.
   */
  EVENT: 'event',

  /**
   * Hat block which conditionally starts a block stack
   */
  HAT: 'hat',

  /**
   * Specialized command block which may or may not run a child branch
   * If a child branch runs, the thread evaluates the loop block again.
   */
  LOOP: 'loop',

  /**
   * General reporter with numeric or string value
   */
  REPORTER: 'reporter'
};
var blockType = BlockType;

var Color$1 = /*#__PURE__*/function () {
  function Color() {
    _classCallCheck(this, Color);
  }

  _createClass(Color, null, [{
    key: "RGB_BLACK",
    get:
    /**
     * @typedef {object} RGBObject - An object representing a color in RGB format.
     * @property {number} r - the red component, in the range [0, 255].
     * @property {number} g - the green component, in the range [0, 255].
     * @property {number} b - the blue component, in the range [0, 255].
     */

    /**
     * @typedef {object} HSVObject - An object representing a color in HSV format.
     * @property {number} h - hue, in the range [0-359).
     * @property {number} s - saturation, in the range [0,1].
     * @property {number} v - value, in the range [0,1].
     */

    /** @type {RGBObject} */
    function get() {
      return {
        r: 0,
        g: 0,
        b: 0
      };
    }
    /** @type {RGBObject} */

  }, {
    key: "RGB_WHITE",
    get: function get() {
      return {
        r: 255,
        g: 255,
        b: 255
      };
    }
    /**
     * Convert a Scratch decimal color to a hex string, #RRGGBB.
     * @param {number} decimal RGB color as a decimal.
     * @return {string} RGB color as #RRGGBB hex string.
     */

  }, {
    key: "decimalToHex",
    value: function decimalToHex(decimal) {
      if (decimal < 0) {
        decimal += 0xFFFFFF + 1;
      }

      var hex = Number(decimal).toString(16);
      hex = "#".concat('000000'.substr(0, 6 - hex.length)).concat(hex);
      return hex;
    }
    /**
     * Convert a Scratch decimal color to an RGB color object.
     * @param {number} decimal RGB color as decimal.
     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */

  }, {
    key: "decimalToRgb",
    value: function decimalToRgb(decimal) {
      var a = decimal >> 24 & 0xFF;
      var r = decimal >> 16 & 0xFF;
      var g = decimal >> 8 & 0xFF;
      var b = decimal & 0xFF;
      return {
        r: r,
        g: g,
        b: b,
        a: a > 0 ? a : 255
      };
    }
    /**
     * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.
     * CC-BY-SA Tim Down:
     * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
     * @param {!string} hex Hex representation of the color.
     * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */

  }, {
    key: "hexToRgb",
    value: function hexToRgb(hex) {
      var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      hex = hex.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
      });
      var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }
    /**
     * Convert an RGB color object to a hex color.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {!string} Hex representation of the color.
     */

  }, {
    key: "rgbToHex",
    value: function rgbToHex(rgb) {
      return Color.decimalToHex(Color.rgbToDecimal(rgb));
    }
    /**
     * Convert an RGB color object to a Scratch decimal color.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {!number} Number representing the color.
     */

  }, {
    key: "rgbToDecimal",
    value: function rgbToDecimal(rgb) {
      return (rgb.r << 16) + (rgb.g << 8) + rgb.b;
    }
    /**
    * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.
    * @param {!string} hex Hex representation of the color.
    * @return {!number} Number representing the color.
    */

  }, {
    key: "hexToDecimal",
    value: function hexToDecimal(hex) {
      return Color.rgbToDecimal(Color.hexToRgb(hex));
    }
    /**
     * Convert an HSV color to RGB format.
     * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */

  }, {
    key: "hsvToRgb",
    value: function hsvToRgb(hsv) {
      var h = hsv.h % 360;
      if (h < 0) h += 360;
      var s = Math.max(0, Math.min(hsv.s, 1));
      var v = Math.max(0, Math.min(hsv.v, 1));
      var i = Math.floor(h / 60);
      var f = h / 60 - i;
      var p = v * (1 - s);
      var q = v * (1 - s * f);
      var t = v * (1 - s * (1 - f));
      var r;
      var g;
      var b;

      switch (i) {
        default:
        case 0:
          r = v;
          g = t;
          b = p;
          break;

        case 1:
          r = q;
          g = v;
          b = p;
          break;

        case 2:
          r = p;
          g = v;
          b = t;
          break;

        case 3:
          r = p;
          g = q;
          b = v;
          break;

        case 4:
          r = t;
          g = p;
          b = v;
          break;

        case 5:
          r = v;
          g = p;
          b = q;
          break;
      }

      return {
        r: Math.floor(r * 255),
        g: Math.floor(g * 255),
        b: Math.floor(b * 255)
      };
    }
    /**
     * Convert an RGB color to HSV format.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
     */

  }, {
    key: "rgbToHsv",
    value: function rgbToHsv(rgb) {
      var r = rgb.r / 255;
      var g = rgb.g / 255;
      var b = rgb.b / 255;
      var x = Math.min(Math.min(r, g), b);
      var v = Math.max(Math.max(r, g), b); // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate

      var h = 0;
      var s = 0;

      if (x !== v) {
        var f = r === x ? g - b : g === x ? b - r : r - g;
        var i = r === x ? 3 : g === x ? 5 : 1;
        h = (i - f / (v - x)) * 60 % 360;
        s = (v - x) / v;
      }

      return {
        h: h,
        s: s,
        v: v
      };
    }
    /**
     * Linear interpolation between rgb0 and rgb1.
     * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.
     * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.
     * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.
     * @return {RGBObject} the interpolated color.
     */

  }, {
    key: "mixRgb",
    value: function mixRgb(rgb0, rgb1, fraction1) {
      if (fraction1 <= 0) return rgb0;
      if (fraction1 >= 1) return rgb1;
      var fraction0 = 1 - fraction1;
      return {
        r: fraction0 * rgb0.r + fraction1 * rgb1.r,
        g: fraction0 * rgb0.g + fraction1 * rgb1.g,
        b: fraction0 * rgb0.b + fraction1 * rgb1.b
      };
    }
  }]);

  return Color;
}();

var color$3 = Color$1;

var Color = color$3;
/**
 * @fileoverview
 * Utilities for casting and comparing Scratch data-types.
 * Scratch behaves slightly differently from JavaScript in many respects,
 * and these differences should be encapsulated below.
 * For example, in Scratch, add(1, join("hello", world")) -> 1.
 * This is because "hello world" is cast to 0.
 * In JavaScript, 1 + Number("hello" + "world") would give you NaN.
 * Use when coercing a value before computation.
 */

var Cast = /*#__PURE__*/function () {
  function Cast() {
    _classCallCheck(this, Cast);
  }

  _createClass(Cast, null, [{
    key: "toNumber",
    value:
    /**
     * Scratch cast to number.
     * Treats NaN as 0.
     * In Scratch 2.0, this is captured by `interp.numArg.`
     * @param {*} value Value to cast to number.
     * @return {number} The Scratch-casted number value.
     */
    function toNumber(value) {
      // If value is already a number we don't need to coerce it with
      // Number().
      if (typeof value === 'number') {
        // Scratch treats NaN as 0, when needed as a number.
        // E.g., 0 + NaN -> 0.
        if (Number.isNaN(value)) {
          return 0;
        }

        return value;
      }

      var n = Number(value);

      if (Number.isNaN(n)) {
        // Scratch treats NaN as 0, when needed as a number.
        // E.g., 0 + NaN -> 0.
        return 0;
      }

      return n;
    }
    /**
     * Scratch cast to boolean.
     * In Scratch 2.0, this is captured by `interp.boolArg.`
     * Treats some string values differently from JavaScript.
     * @param {*} value Value to cast to boolean.
     * @return {boolean} The Scratch-casted boolean value.
     */

  }, {
    key: "toBoolean",
    value: function toBoolean(value) {
      // Already a boolean?
      if (typeof value === 'boolean') {
        return value;
      }

      if (typeof value === 'string') {
        // These specific strings are treated as false in Scratch.
        if (value === '' || value === '0' || value.toLowerCase() === 'false') {
          return false;
        } // All other strings treated as true.


        return true;
      } // Coerce other values and numbers.


      return Boolean(value);
    }
    /**
     * Scratch cast to string.
     * @param {*} value Value to cast to string.
     * @return {string} The Scratch-casted string value.
     */

  }, {
    key: "toString",
    value: function toString(value) {
      return String(value);
    }
    /**
     * Cast any Scratch argument to an RGB color array to be used for the renderer.
     * @param {*} value Value to convert to RGB color array.
     * @return {Array.<number>} [r,g,b], values between 0-255.
     */

  }, {
    key: "toRgbColorList",
    value: function toRgbColorList(value) {
      var color = Cast.toRgbColorObject(value);
      return [color.r, color.g, color.b];
    }
    /**
     * Cast any Scratch argument to an RGB color object to be used for the renderer.
     * @param {*} value Value to convert to RGB color object.
     * @return {RGBOject} [r,g,b], values between 0-255.
     */

  }, {
    key: "toRgbColorObject",
    value: function toRgbColorObject(value) {
      var color;

      if (typeof value === 'string' && value.substring(0, 1) === '#') {
        color = Color.hexToRgb(value); // If the color wasn't *actually* a hex color, cast to black

        if (!color) color = {
          r: 0,
          g: 0,
          b: 0,
          a: 255
        };
      } else {
        color = Color.decimalToRgb(Cast.toNumber(value));
      }

      return color;
    }
    /**
     * Determine if a Scratch argument is a white space string (or null / empty).
     * @param {*} val value to check.
     * @return {boolean} True if the argument is all white spaces or null / empty.
     */

  }, {
    key: "isWhiteSpace",
    value: function isWhiteSpace(val) {
      return val === null || typeof val === 'string' && val.trim().length === 0;
    }
    /**
     * Compare two values, using Scratch cast, case-insensitive string compare, etc.
     * In Scratch 2.0, this is captured by `interp.compare.`
     * @param {*} v1 First value to compare.
     * @param {*} v2 Second value to compare.
     * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.
     */

  }, {
    key: "compare",
    value: function compare(v1, v2) {
      var n1 = Number(v1);
      var n2 = Number(v2);

      if (n1 === 0 && Cast.isWhiteSpace(v1)) {
        n1 = NaN;
      } else if (n2 === 0 && Cast.isWhiteSpace(v2)) {
        n2 = NaN;
      }

      if (isNaN(n1) || isNaN(n2)) {
        // At least one argument can't be converted to a number.
        // Scratch compares strings as case insensitive.
        var s1 = String(v1).toLowerCase();
        var s2 = String(v2).toLowerCase();

        if (s1 < s2) {
          return -1;
        } else if (s1 > s2) {
          return 1;
        }

        return 0;
      } // Handle the special case of Infinity


      if (n1 === Infinity && n2 === Infinity || n1 === -Infinity && n2 === -Infinity) {
        return 0;
      } // Compare as numbers.


      return n1 - n2;
    }
    /**
     * Determine if a Scratch argument number represents a round integer.
     * @param {*} val Value to check.
     * @return {boolean} True if number looks like an integer.
     */

  }, {
    key: "isInt",
    value: function isInt(val) {
      // Values that are already numbers.
      if (typeof val === 'number') {
        if (isNaN(val)) {
          // NaN is considered an integer.
          return true;
        } // True if it's "round" (e.g., 2.0 and 2).


        return val === parseInt(val, 10);
      } else if (typeof val === 'boolean') {
        // `True` and `false` always represent integer after Scratch cast.
        return true;
      } else if (typeof val === 'string') {
        // If it contains a decimal point, don't consider it an int.
        return val.indexOf('.') < 0;
      }

      return false;
    }
  }, {
    key: "LIST_INVALID",
    get: function get() {
      return 'INVALID';
    }
  }, {
    key: "LIST_ALL",
    get: function get() {
      return 'ALL';
    }
    /**
     * Compute a 1-based index into a list, based on a Scratch argument.
     * Two special cases may be returned:
     * LIST_ALL: if the block is referring to all of the items in the list.
     * LIST_INVALID: if the index was invalid in any way.
     * @param {*} index Scratch arg, including 1-based numbers or special cases.
     * @param {number} length Length of the list.
     * @param {boolean} acceptAll Whether it should accept "all" or not.
     * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.
     */

  }, {
    key: "toListIndex",
    value: function toListIndex(index, length, acceptAll) {
      if (typeof index !== 'number') {
        if (index === 'all') {
          return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;
        }

        if (index === 'last') {
          if (length > 0) {
            return length;
          }

          return Cast.LIST_INVALID;
        } else if (index === 'random' || index === 'any') {
          if (length > 0) {
            return 1 + Math.floor(Math.random() * length);
          }

          return Cast.LIST_INVALID;
        }
      }

      index = Math.floor(Cast.toNumber(index));

      if (index < 1 || index > length) {
        return Cast.LIST_INVALID;
      }

      return index;
    }
  }]);

  return Cast;
}();

var cast = Cast;

var web = {exports: {}};

var minilog$2 = {exports: {}};

function M() {
  this._events = {};
}

M.prototype = {
  on: function on(ev, cb) {
    this._events || (this._events = {});
    var e = this._events;
    (e[ev] || (e[ev] = [])).push(cb);
    return this;
  },
  removeListener: function removeListener(ev, cb) {
    var e = this._events[ev] || [],
        i;

    for (i = e.length - 1; i >= 0 && e[i]; i--) {
      if (e[i] === cb || e[i].cb === cb) {
        e.splice(i, 1);
      }
    }
  },
  removeAllListeners: function removeAllListeners(ev) {
    if (!ev) {
      this._events = {};
    } else {
      this._events[ev] && (this._events[ev] = []);
    }
  },
  listeners: function listeners(ev) {
    return this._events ? this._events[ev] || [] : [];
  },
  emit: function emit(ev) {
    this._events || (this._events = {});
    var args = Array.prototype.slice.call(arguments, 1),
        i,
        e = this._events[ev] || [];

    for (i = e.length - 1; i >= 0 && e[i]; i--) {
      e[i].apply(this, args);
    }

    return this;
  },
  when: function when(ev, cb) {
    return this.once(ev, cb, true);
  },
  once: function once(ev, cb, when) {
    if (!cb) return this;

    function c() {
      if (!when) this.removeListener(ev, c);
      if (cb.apply(this, arguments) && when) this.removeListener(ev, c);
    }

    c.cb = cb;
    this.on(ev, c);
    return this;
  }
};

M.mixin = function (dest) {
  var o = M.prototype,
      k;

  for (k in o) {
    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);
  }
};

var microee$1 = M;

var microee = microee$1; // Implements a subset of Node's stream.Transform - in a cross-platform manner.

function Transform$7() {}

microee.mixin(Transform$7); // The write() signature is different from Node's
// --> makes it much easier to work with objects in logs.
// One of the lessons from v1 was that it's better to target
// a good browser rather than the lowest common denominator
// internally.
// If you want to use external streams, pipe() to ./stringify.js first.

Transform$7.prototype.write = function (name, level, args) {
  this.emit('item', name, level, args);
};

Transform$7.prototype.end = function () {
  this.emit('end');
  this.removeAllListeners();
};

Transform$7.prototype.pipe = function (dest) {
  var s = this; // prevent double piping

  s.emit('unpipe', dest); // tell the dest that it's being piped to

  dest.emit('pipe', s);

  function onItem() {
    dest.write.apply(dest, Array.prototype.slice.call(arguments));
  }

  function onEnd() {
    !dest._isStdio && dest.end();
  }

  s.on('item', onItem);
  s.on('end', onEnd);
  s.when('unpipe', function (from) {
    var match = from === dest || typeof from == 'undefined';

    if (match) {
      s.removeListener('item', onItem);
      s.removeListener('end', onEnd);
      dest.emit('unpipe');
    }

    return match;
  });
  return dest;
};

Transform$7.prototype.unpipe = function (from) {
  this.emit('unpipe', from);
  return this;
};

Transform$7.prototype.format = function (dest) {
  throw new Error(['Warning: .format() is deprecated in Minilog v2! Use .pipe() instead. For example:', 'var Minilog = require(\'minilog\');', 'Minilog', '  .pipe(Minilog.backends.console.formatClean)', '  .pipe(Minilog.backends.console);'].join('\n'));
};

Transform$7.mixin = function (dest) {
  var o = Transform$7.prototype,
      k;

  for (k in o) {
    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);
  }
};

var transform = Transform$7;

var Transform$6 = transform;
var levelMap = {
  debug: 1,
  info: 2,
  warn: 3,
  error: 4
};

function Filter() {
  this.enabled = true;
  this.defaultResult = true;
  this.clear();
}

Transform$6.mixin(Filter); // allow all matching, with level >= given level

Filter.prototype.allow = function (name, level) {
  this._white.push({
    n: name,
    l: levelMap[level]
  });

  return this;
}; // deny all matching, with level <= given level


Filter.prototype.deny = function (name, level) {
  this._black.push({
    n: name,
    l: levelMap[level]
  });

  return this;
};

Filter.prototype.clear = function () {
  this._white = [];
  this._black = [];
  return this;
};

function test(rule, name) {
  // use .test for RegExps
  return rule.n.test ? rule.n.test(name) : rule.n == name;
}

Filter.prototype.test = function (name, level) {
  var i,
      len = Math.max(this._white.length, this._black.length);

  for (i = 0; i < len; i++) {
    if (this._white[i] && test(this._white[i], name) && levelMap[level] >= this._white[i].l) {
      return true;
    }

    if (this._black[i] && test(this._black[i], name) && levelMap[level] <= this._black[i].l) {
      return false;
    }
  }

  return this.defaultResult;
};

Filter.prototype.write = function (name, level, args) {
  if (!this.enabled || this.test(name, level)) {
    return this.emit('item', name, level, args);
  }
};

var filter = Filter;

(function (module, exports) {
  var Transform = transform,
      Filter = filter;
  var log = new Transform(),
      slice = Array.prototype.slice;

  exports = module.exports = function create(name) {
    var o = function o() {
      log.write(name, undefined, slice.call(arguments));
      return o;
    };

    o.debug = function () {
      log.write(name, 'debug', slice.call(arguments));
      return o;
    };

    o.info = function () {
      log.write(name, 'info', slice.call(arguments));
      return o;
    };

    o.warn = function () {
      log.write(name, 'warn', slice.call(arguments));
      return o;
    };

    o.error = function () {
      log.write(name, 'error', slice.call(arguments));
      return o;
    };

    o.log = o.debug; // for interface compliance with Node and browser consoles

    o.suggest = exports.suggest;
    o.format = log.format;
    return o;
  }; // filled in separately


  exports.defaultBackend = exports.defaultFormatter = null;

  exports.pipe = function (dest) {
    return log.pipe(dest);
  };

  exports.end = exports.unpipe = exports.disable = function (from) {
    return log.unpipe(from);
  };

  exports.Transform = Transform;
  exports.Filter = Filter; // this is the default filter that's applied when .enable() is called normally
  // you can bypass it completely and set up your own pipes

  exports.suggest = new Filter();

  exports.enable = function () {
    if (exports.defaultFormatter) {
      return log.pipe(exports.suggest) // filter
      .pipe(exports.defaultFormatter) // formatter
      .pipe(exports.defaultBackend); // backend
    }

    return log.pipe(exports.suggest) // filter
    .pipe(exports.defaultBackend); // formatter
  };
})(minilog$2, minilog$2.exports);

var hex = {
  black: '#000',
  red: '#c23621',
  green: '#25bc26',
  yellow: '#bbbb00',
  blue: '#492ee1',
  magenta: '#d338d3',
  cyan: '#33bbc8',
  gray: '#808080',
  purple: '#708'
};

function color$2(fg, isInverse) {
  if (isInverse) {
    return 'color: #fff; background: ' + hex[fg] + ';';
  } else {
    return 'color: ' + hex[fg] + ';';
  }
}

var util = color$2;

var Transform$5 = transform,
    color$1 = util;
var colors$1 = {
  debug: ['cyan'],
  info: ['purple'],
  warn: ['yellow', true],
  error: ['red', true]
},
    logger$4 = new Transform$5();

logger$4.write = function (name, level, args) {
  var fn = console.log;

  if (console[level] && console[level].apply) {
    fn = console[level];
    fn.apply(console, ['%c' + name + ' %c' + level, color$1('gray'), color$1.apply(color$1, colors$1[level])].concat(args));
  }
}; // NOP, because piping the formatted logs can only cause trouble.


logger$4.pipe = function () {};

var color_1 = logger$4;

var Transform$4 = transform,
    color = util,
    colors = {
  debug: ['gray'],
  info: ['purple'],
  warn: ['yellow', true],
  error: ['red', true]
},
    logger$3 = new Transform$4();

logger$3.write = function (name, level, args) {
  var fn = console.log;

  if (level != 'debug' && console[level]) {
    fn = console[level];
  }

  var i = 0;

  if (level != 'info') {
    for (; i < args.length; i++) {
      if (typeof args[i] != 'string') break;
    }

    fn.apply(console, ['%c' + name + ' ' + args.slice(0, i).join(' '), color.apply(color, colors[level])].concat(args.slice(i)));
  } else {
    fn.apply(console, ['%c' + name, color.apply(color, colors[level])].concat(args));
  }
}; // NOP, because piping the formatted logs can only cause trouble.


logger$3.pipe = function () {};

var minilog$1 = logger$3;

var Transform$3 = transform;
var newlines = /\n+$/,
    logger$2 = new Transform$3();

logger$2.write = function (name, level, args) {
  var i = args.length - 1;

  if (typeof console === 'undefined' || !console.log) {
    return;
  }

  if (console.log.apply) {
    return console.log.apply(console, [name, level].concat(args));
  } else if (JSON && JSON.stringify) {
    // console.log.apply is undefined in IE8 and IE9
    // for IE8/9: make console.log at least a bit less awful
    if (args[i] && typeof args[i] == 'string') {
      args[i] = args[i].replace(newlines, '');
    }

    try {
      for (i = 0; i < args.length; i++) {
        args[i] = JSON.stringify(args[i]);
      }
    } catch (e) {}

    console.log(args.join(' '));
  }
};

logger$2.formatters = ['color', 'minilog'];
logger$2.color = color_1;
logger$2.minilog = minilog$1;
var console_1 = logger$2;

var Transform$2 = transform,
    cache$1 = [];
var logger$1 = new Transform$2();

logger$1.write = function (name, level, args) {
  cache$1.push([name, level, args]);
}; // utility functions


logger$1.get = function () {
  return cache$1;
};

logger$1.empty = function () {
  cache$1 = [];
};

var array = logger$1;

var Transform$1 = transform,
    cache = false;
var logger = new Transform$1();

logger.write = function (name, level, args) {
  if (typeof window == 'undefined' || typeof JSON == 'undefined' || !JSON.stringify || !JSON.parse) return;

  try {
    if (!cache) {
      cache = window.localStorage.minilog ? JSON.parse(window.localStorage.minilog) : [];
    }

    cache.push([new Date().toString(), name, level, args]);
    window.localStorage.minilog = JSON.stringify(cache);
  } catch (e) {}
};

var localstorage = logger;

var Transform = transform;
var cid = new Date().valueOf().toString(36);

function AjaxLogger(options) {
  this.url = options.url || '';
  this.cache = [];
  this.timer = null;
  this.interval = options.interval || 30 * 1000;
  this.enabled = true;
  this.jQuery = window.jQuery;
  this.extras = {};
}

Transform.mixin(AjaxLogger);

AjaxLogger.prototype.write = function (name, level, args) {
  if (!this.timer) {
    this.init();
  }

  this.cache.push([name, level].concat(args));
};

AjaxLogger.prototype.init = function () {
  if (!this.enabled || !this.jQuery) return;
  var self = this;
  this.timer = setTimeout(function () {
    var i,
        logs = [],
        ajaxData,
        url = self.url;
    if (self.cache.length == 0) return self.init(); // Test each log line and only log the ones that are valid (e.g. don't have circular references).
    // Slight performance hit but benefit is we log all valid lines.

    for (i = 0; i < self.cache.length; i++) {
      try {
        JSON.stringify(self.cache[i]);
        logs.push(self.cache[i]);
      } catch (e) {}
    }

    if (self.jQuery.isEmptyObject(self.extras)) {
      ajaxData = JSON.stringify({
        logs: logs
      });
      url = self.url + '?client_id=' + cid;
    } else {
      ajaxData = JSON.stringify(self.jQuery.extend({
        logs: logs
      }, self.extras));
    }

    self.jQuery.ajax(url, {
      type: 'POST',
      cache: false,
      processData: false,
      data: ajaxData,
      contentType: 'application/json',
      timeout: 10000
    }).success(function (data, status, jqxhr) {
      if (data.interval) {
        self.interval = Math.max(1000, data.interval);
      }
    }).error(function () {
      self.interval = 30000;
    }).always(function () {
      self.init();
    });
    self.cache = [];
  }, this.interval);
};

AjaxLogger.prototype.end = function () {}; // wait until jQuery is defined. Useful if you don't control the load order.


AjaxLogger.jQueryWait = function (onDone) {
  if (typeof window !== 'undefined' && (window.jQuery || window.$)) {
    return onDone(window.jQuery || window.$);
  } else if (typeof window !== 'undefined') {
    setTimeout(function () {
      AjaxLogger.jQueryWait(onDone);
    }, 200);
  }
};

var jquery_simple = AjaxLogger;

(function (module, exports) {
  var Minilog = minilog$2.exports;
  var oldEnable = Minilog.enable,
      oldDisable = Minilog.disable,
      isChrome = typeof navigator != 'undefined' && /chrome/i.test(navigator.userAgent),
      console = console_1; // Use a more capable logging backend if on Chrome

  Minilog.defaultBackend = isChrome ? console.minilog : console; // apply enable inputs from localStorage and from the URL

  if (typeof window != 'undefined') {
    try {
      Minilog.enable(JSON.parse(window.localStorage['minilogSettings']));
    } catch (e) {}

    if (window.location && window.location.search) {
      var match = RegExp('[?&]minilog=([^&]*)').exec(window.location.search);
      match && Minilog.enable(decodeURIComponent(match[1]));
    }
  } // Make enable also add to localStorage


  Minilog.enable = function () {
    oldEnable.call(Minilog, true);

    try {
      window.localStorage['minilogSettings'] = JSON.stringify(true);
    } catch (e) {}

    return this;
  };

  Minilog.disable = function () {
    oldDisable.call(Minilog);

    try {
      delete window.localStorage.minilogSettings;
    } catch (e) {}

    return this;
  };

  exports = module.exports = Minilog;
  exports.backends = {
    array: array,
    browser: Minilog.defaultBackend,
    localStorage: localstorage,
    jQuery: jquery_simple
  };
})(web, web.exports);

var minilog = web.exports;
minilog.enable();
var log$2 = minilog('vm');

var img = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8' standalone='no'%3f%3e%3c!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg version='1.1' id='Layer_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='150px' height='150px' viewBox='0 0 150 150' enable-background='new 0 0 150 150' xml:space='preserve'%3e %3cimage id='image0' width='150' height='150' x='0' y='0' href='data:image/png%3bbase64%2ciVBORw0KGgoAAAANSUhEUgAAAJYAAACWCAYAAAA8AXHiAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP%2bgvaeTAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAq2ElEQVR42u2dd5xVxfn/3zNzzrlt%2b8JSlCaggDTF2EAsCLZgRU1sMYkl%2bDWxJCZqMLHFEo0laiwxMRo1zWisP1FRNBYQRUARO03a7sLWu/fec87M/P64y7JLV/e6cfe%2beZ0Xe%2b49Zc4znzvlmWfmCGutJU%2bedkZ2dALydE7ywsqTE/LCypMT8sLKkxPywsqTE/LCypMT8sLKkxPywsqTE/LCypMT8sLKkxPywsqTE/LCypMT8sLKkxPywsqTE/LCypMT8sLKkxPywsqTE/LCypMT8sLKkxPywsqTE/LCypMT8sLKkxPywsqTE/LCypMT8sLKkxPywsqTE/LCypMT8sLaDhYtWsR3Tjyxo5PxjSIvrG1gjOHIyZM5aMIE5s2b1y7XbGxs7OjHyjldQlg777wz27OozupVqzb5bNKkSXz8ySecddZZ7Lfffpt8v2DBgu1ORxiGeJ5HQ0NDR5sk53QJYS1ZsgTHcbj997dt8ZhkMslBEyZw771/bPls1qxZHH30US37r732GudMndqyX1hYyIUXXLBdQjn7rLPwPA%2bt9XaJ/BuP7QLE43ELWMdxbJ8%2bfTZ7TL9%2b/ay11l5zzbX2v6%2b8bGtqauyAAQM2Oe7www%2b3H3/8kT3pO9%2b11dXVNgxDW1ZWttX7T5t2mRVCWNd1rRDCrlixoqNNknO6hLBKSkosYHv16rXZ7/2Mbw8/4oiW/f4DdrKFhYVbvF4kErEXXXRRy/7MmTPteT/5yVbTMHbsWBuJRKwQwn7%2beV5YnYKFC9%2b31mYF8czTz2zy/V577mmNMW0%2bq6qq2uL1UqnUJp%2bdcOJ3bENDwxbPkVLaNWvWWGut1Vp3tElyjrC2K1T4WZ5%2b/EmOOu4YwjBs8/nUH57FnX%2b6J2f3PfbY47Ch4bEnHutoE3xtdClhAfTs2ZMbr7yaU84642u7p6ckq1ZXUt69W0c//tdGl%2bgVtuaZ06Yw9UdnMndIN9bcfGtO77Xyqh/zy5jLcCdCPJ3q6Ef/WulSJVbtzBnUHTOZ39RnqLKWu8ssOtyd4gWPEu/br13v9eruu7LLss84I0xzoRUU9%2bvLqLmfIByno83wtdClSqzll/yKHheez123XEN/aylfUg9Xn8zzZ5/ervd592c/Z8Tpp/KDEXuwY73LPq/OY8e99mTtK693tAm%2bNjpViRUazbJ11RgJrnIQCKy1eFKhCXEDQVBTxcoXn2f5nDk8%2bfZrXPPYDNySUoQUCCFACgxgrMFYQ5jtOSMQSAFCCKSQSCGQQmAtGEBaiChFSoeEyRSZ6rX8/vgJTDp8Ej0HDaVs0pF4iXJkzCPqeFknafP1oo5L1HE72nztSqcRlgVOfe5%2b0kpgpEVaidEBVoGNSorShdQ4DRBqSk2Swnhvfr3bsTjuWkpEHGENjVLw9MI5/GfVewhZQmNUkEgbfAWuhrQDrgFhQQuIhprQU5Ax9PES9OtRTkVZd1atreSjZUto8mIkEVjHkrYZClOG%2bogl4rjIULRJ/78POq2jTdiudJoK3xiDLywpT1CShoyEwBEseuhJqJHsMnUiEePRV8f5%2bcE/JO43cN/bVzKs/4sM6%2bHT1Jhh%2bodjOHrIpRw8/AAe/fA1Xl2xknVemliQFVRaQCjAKHAMZGIJvjdwdw7t0Y/V9et4Z8XnVC5YzKhddmHy%2bD2piMd45NN5PPv5B5TXhTx45gWQMUz%2b%2by3ISLSjTZZTOk0bS0nJmERPhAVfQcaFUl%2bw9OHnEHVrKbSGo3Y8gCsnHMEzb5xDKtKd/QbNZNnqk5i5/GpeWX4l/csqCRMH8XHtruxWshOXjf82PdIKIyGU4OjsvWIB7BPrxUNjpzD3%2bSeJlccZXdaf43Ybx7mHHcshA3Zl18IKBg4ZRFFNkj/s/x3CoignPXAbMmWxxnS0uXJOp6kKAZJ%2bhtNe%2bwdaWISVxI3l4ZP/jyP/cR9Dox6XDDuEJ2t/wL4Vb7JuzaPs0bs/Vhl8UUyVteyIYLFt4IP5Z7PzyDeZ/ebtDBu9J1e9PR0bhCgDRhiGJrpz/rcOZfAuw9CffYZxh5Leb39cdmK/0VXMmF2IYxoQcx7DDT/iwKkn88jNf%2bH02Q8TX1ZDw%2beVBN8ahKPBd6C7G%2bePY6d0tPnalU5TYgEkvAh9nQgIQTS0BI7isIt/StSuY9qoSdz/6VUcWPEORc7/Y48dR2AVfPBRNbfdeCP1ixaBgD5BAWN3u4WPPzmAEaOvwA0a2MPrRaBSRAOXZBQu%2bdZhjB23B7WVHxEOmsJf/tOLS/Y%2bGCcZJxqswTQM5uozEvzinu/DoDN44Q%2bPccUDt/PnsSexZocEqwqy6XWsJGN87t73uI42XbvTqUosgBWNtfxkzhMIQLgOOjQcteNg6oNCvjd4Tz5c/STf6n0AyDT1tYZuOxZg0gprLVOmTOHvf3qAVNzBD1IsbRrLE5%2bdwNQRZ3HOzBlYr5JLdzuZlx/9Nxee/SMiO52IKJ6M71YjhU8QDkR4VahkL0zRUsrqA%2boTq7GrliKWPcrzn73Pm9XLeb1%2bBU7G0OhJ%2biXhzkNP6WiztTudqsQC2KGghArj4StwUiEGw%2bTeQ1hV/w/ebtybPbodADIDxCgoirBq2UqMMVhreeSRR3jp04%2bIakuBFNTUnM/Bg/4fxiuhh0wQNVGGF5bz80vOR9KHHx68N78%2b7D20ExLICMJZSbRJod1GrFY02N789vRVHLDncKz2%2bPEvf873h%2b6LYy3SZjsAp48a19EmywmdTlgA0/Y8BF9orNZoR5OIFXHYLm%2bjw7EYB5qaDEEQABIdKqTMmsEYw5QJE5BS4LgRhvY8hn6F7/PKvLfYbcgQdigo56O6BlSVT6TnHtwxt5grnvoWSA%2bhi7A6RsoVWJECP0GmvIrLbxvLC8sTmIK9WPTwY0SVwQ8MWgqKA82evdrX4/%2b/QqcU1g6FpQy3hfhRhwQuwgT0iMynJPgWKUcQjUaZPHky1157Lb1790Zr3XJufd06EBKrHQoihRSJCB/KKoZG4wwo3JHZb84CJLFBo7jgmJcJYp/jNpSh9EYtCpnGrSknGSngvEnLKO87AK0FqVSaQtfDt5o%2bkSIE4os93DeETiksgJ%2bMPggtJUILEJqwMY4jFBqNlJLp06czbdq0FlGtb2oaq9EWUOCiEVpjVQxrA1AO69JJsIaGqjU4tcswmXIQFu21DU%2b2KkSrEK0TiLo1hIEEBNbQIqbvD9uno82UMzqtsPoWlVGMSxpBCpfPVh3FWudFEnYbPiQrsFIAIUZX0hA2MannOF5YOpfPG9ey3/BR2aGcxjQ3zTgDJZoI4pWodNuQGDddjImkKFJLuHXO3tRVL0UIQzTu0Rj4xIxkUHnPjjZTzui0wgK4atQEApFhSdVS3qgbyYjCBwlDSRgGeFGJoABU23OiXinCWDJW4Kcf47nVhzO6SDO3spLlVbXsslN/0tEQsWo2k/d%2bj3Mnf4AMS9FeLehCkAHYCMZNEE17XHzKu4zaoRbq/8vgCeMJZQxcweDiok5TCf7n8cc3%2baxTC6tfcTndfMVtH83jgn0mUp/ux5LkNIwwHH3MqViZROp4m3O69S7HyrWoTBKduARdcxQLUqtYMX0hqyvfJx0EHH/cqQT2U157Mcad0yso9GtxTAzhNCDDIpAuUfMRJWnLFQ/txaJ3a3Gs5uLfXMGTy99DGMN5wyd0tHnajaOPOmqTzzq1sACmDhuPSTWytlby8tLfUBL/J0HwBA8%2b8Beko5DNJpBSopTi448XIE0MI/rwn/fO4KhRJ3HtS88z9/Z7eOlnNzPt9X9x2113EfckVZ9cS0Gt4ZJzXmFE6WJKVDFH7fUwKkhy4sHVDBvzCUovJfPhvex70tF8Z7fxTP94LtFQUB4r6GjT5JROL6y9evenviDDpfOmc%2bjwPXjrw8tIuufRZC/mmcefwIgMSBBEeeSRR3DNOwSZUTy85hgmDv0N977zNCJSits7QVHfwTTYFK%2bvWMQDL75ANBNQ/9E1/Oq3CT5dW0QYVrHniDJEuhd/nVHOrDdqycy7mV47lPOXe%2b7jljnTqXctp%2by0ezZEpxPT6Tzvm%2bO9ypX8%2bOPnGJhyOX/vSbipNIurLmf3Xf5JUdiP5YuL2WHHEBNfwgfpEpLr7mZcxe5cPfcV5qdrKMhAdaGkMGVxAkN9zDJ1xzGMLunNQYcewIcLFhHzCyGWwMoIwqSQQYom28QRpx/N/Xc%2bwL1zX%2bKNTBVKGx4c/12iqnPFX21MlxAWwA%2bee5A612Bcy9DSMs4cOIyeDGBhcjbxsJYAS0HRnvSMlvLC4uXctXwmXuDy7nV3s%2buVZ6F8TYgh6cDqy%2b9n%2bC9/wEjhcdreR2LXrOWmP9/KWzPnULeujvKe3TjwkIO44NzzWJ1p4Ma3X6JGZPBdh75NkjsmndTR5sg5XUZYzy3%2bgN8vm0NROsTVxTRFQgowDKsooChaTkYHLFlTzyIqiQtNtKmM0Kvm82feYt5dj2DLYrhGYGuSDDvvu5QdOhbPaAyW0bFeHN59CL17FOEoSVMmzeLqSp5d9iGf0oSwAkGIZxTn7Lw34/vu3NHmyDldRlgAa5uSNAYZjDAIFBKLwMFajRISK8g6UXWItgZjDIENSYcBESTaEWgBobV0E1GMlEgBVlgCQJoNjdYQixQb/OpWgCckvQtLOtoMXwtdSljbSxiG/PSii7IREs2NbGstQmTj4i0WLCiluPGGGzo6uf%2bTdJrQ5PYknc4gTfb3tr7zJgCsheaSCMAEQUcn9X%2bWfIm1BRYvXsKc2W%2bSSqfQWmO0JtQhvh%2bgjcZ1PQ47/DAG7rRTRyf1f5J8ibUF7rjjdnSokao5pEZn21xexENrQyKewJHqK96l89LpHaRfhsrKSowxILIxWgA79t6Bs846k8umXcbEgw7GYrjzrjs7Oqn/s%2bRLrM1QUVHB7rvtzhFHHEGiIMHfHnyYhR%2b8z5/vu68lvKYlzMaYlkDBPBvolBZpaGigpLikZX3QDz/8kKampi90jc9Wr%2bLXV13Jxb%2bcxryF75EJQozIzpK2QoKURAoLvpKoDjvscKqrqzvaXDmhUzbezz/vfG67/Tbi8Tj33nUPJ/3wVBwteGHeHN5uqEQrgW2eMq%2bkwpESR6qWafPSShwhCLVu9kVJBBZtTXbKNWCsxWKQjoPBYgVYY7PT87Vp2RdCYIUg7acpX1nH2cefSL/%2b/fno409wHIddd92V%2bfPnd7TJ2p1OVxX%2b4he/QEiB67rccsstTP3x/4FvCaTl5sp3MEIQiraP3brMiX4JD8L632bG2/LAslWa139/G9EQPl61jNqaGioqKpgwYQIXXXQRN3Qyf1inqgovu%2bwygiBg2bJlhGHIIYccQk1NDa5wOPb%2bG4homZ3IGpo2W7TV5pkvv8V83bLFA9NmK07DoRedQ9JViJTm%2bmuuo7qqmoaGhqxD9qc/7WjztSudpiq89JJLSaVTlBSXsGzxEv7x%2bL%2b54P/O5cbrf8vgH51IrykHUxYotAJJEqu742SWU/i6T1xXbXK99UYx1sOxPliBUSHaFlCeWUdl3FDgJ7LHrj9YbIif1xKWHTgSvBL8SD1x38EIy5IZr7L4ur9Qg2Xy0ZN54rEnuea6K6lcU4vyLL%2b97vqONmW70CmEdeU1N7CucgURL8r1v72Ok08%2bmT333JNrLvsVelhvDr76YjISokbQ6EEsVQYIqosbsGF3orpuk2vKFpe7ACyh8HDDCGV%2bHX6kGmNLQW/cIZDNpwjSShM6EazxUWEhGaUAg9KamT%2b4iMySdcz876scsN84MmEtv778eurr6/GcODf9blpHm/Qrs93CGrnP/aQ8jecXolWG7a1Fg4JGHFXNh09fCsC%2b425kBf0osilSMopjNyw0mylcwT6Dd%2bDh359EZWU94499asvXjST5ZMaZ/OH2u1m65AOUG%2bPaa68B4Njjj%2bWWG25mwNDBHP%2bfu0jGHRKZ7MIeFsstC89ih6TfPEAsNhRPm6N5aAcFTZEIj/Y5hpcLDmFdzCDNRg5Su2FfCENGFbNzw1PcOP9PLbH11gGRBhIb3Uc3L7RlBX%2b0l3HmL67YJCnpm6JEpf/lc9uA/Uka4XjYB0Yi1r33pS6jccgc9wrxPntv8ZjtFtau4%2b%2bgwXNJZGKknRBht09YkhSOaOSwMdXceP1vOPCgX7JIjqG7XkudU0rEpDckRq2hm%2bsxbmQVl/ziEvY87t9bvq52GVgxnWKbot/OO3HDdde1fLfwvYX87tbfkZwwikzPclxjEdbS5EKPlSluW3wbUW8hMhT4rocbbiWzjKB5zhYIF%2bNopIa3U4fw99qhm%2bZcM7FAsiYhOUs9yZjyj7ACRNAsLC1AbWR2C0JarJH8aeF43oztxj1/uKnNIU03F4NMEgu/3Go12sKfaqay46ixHJR4hugHD3%2bp62AEz8nvsKzoAM4888zNHrLdvcJGJ0YkUAROEyIby9sKgREGiUZgwXgt3/gKomnJHTddz7W/uZJ6dqQ8XEpjJIYSVWAjLcdmbA9WrX2Dm258hksvvgTEljM8cAwvPvkQ%2b%2bx/PP9sJSqAXYfvSmbHCnRFOY4xgMDVEkdBY/cEy%2bo%2bp3%2bDS0Qq0q6PZzZkcigjOGHzBFYhsI7GCok0BqNClBEgYY%2bC54jtMITz%2b%2b9BNxGi/BJSsQ1VqhURhL%2bM3otWEAYersmAyi7ahrSbLyUNCAwn7jKb86/4hF4VhVxx%2bYaSywnSKEnWxl8CJeGuW%2b5kyLdDxn83idhKmWLl%2biajA4Rt8juUkjnPPMcDNau2KKz26RUKH0dHENZFywCtMi2btTGMClvXEtt3yW0ekRXMsUccstlv9598KIHK5mGjZwikAQyhNLitfvBiI9sK42CVpslzsDJAWIORhsABGbRN1ZCmm%2bGq28mo7Ep9wuiWzQuTlIaf0quW5qJq%2b589FjEMdFfxeXUNf3/oH60S1z7ZZTYpGDbFFx6hjIAwpNwYgXRbtlA6OPjYrcinXfxYvnQppAahQ0LrIc2GVDuiChVksND%2bEwisQGxBsdWN9S0VU68kZF5dSFkmu%2bRjdKBsjqsCtVGtogx83NSL3a9tYo9ulicucShMp0i7Bre5IZ%2b9t0XVlfHjnd7k%2bj/tw149K0H3av7K4qCY0ns6flGajGNwv8Bq3DIMuOO4Yq5Y3MBr0dlov5GTv//DDTE8X5XtuEwk5VNf2A8vU48wENoNJzXJAozQOGy5RmkXYUUzDpWfPUjNqnlYYcia34IU2SIjKMORX9Qo2zheWKQVW/wVh9airMAIwYqEpnz8ztQJQdpx4J2A0A9xHW8TYWWKLMWN69CqG8Pv/QPLl5zP0EwTUiq0Y9scv7a8jgG1itl/vJ%2bej/yGpkIXZSyhEAgT8KsFa/BqNJ4TwTqZNqWjdgqwpgmlHazyka1LUQUjRhje%2bu277LHz/sxbMA95/90cKyzCCIwEYWVzlbi1olAA2ajX7FiDRZCd6ratAjRUvej7s6XUmxhSRMGm0JCt40SaqA/9R2/5/HYpW7UTEApLQeFgrDbZIQ1tsYHBZizWrCUIDRHP3bZgWth23eEYixGbb8hq5RANFKFUFKUL8EWCQDpIo3GFIuI4SAORjX503kqDDaIEmXqWRLoT1xJTYPHSLrq5Ol2/Jfw4NqMRjXWsTZQQT0UobnIRYYTRqxcQTYWYGC0Z2sbwUqNtMUL6aFPU9sk1FIaNlFbO59qbf0dxopg33/qUBhfQLjKUCG2wYls2soBBGYPUDliJDxgcJJmtn1rYQNL3WDh/HqG/jjBowgZN2EwTNp0kZZIsmvvKlvPmi4pocwhceg8%2bHqMjDJp4HTGryRiXift2546rv/%2blrrnNvmpLFbj5A1PSJ1Q%2bGcfiylqMjYLxcKze%2bnWL0jhJl7OGKb635FL6NlWBB7gBXija3M%2bKBp54vxtKhBwVe4mY4%2bEZQ00kZK8PXsS1PugI1gk2acv5DZZVVtE/Ai7pNr837RmcwGP6TxM89PenmHb11Vzxq2ngBwjHgjBY4RAg8exWerRC4FsHTwQgQ5AQsxbQhGLrjV6nvpHVNw0i9eLhVE0PkEKhhUPFeR9tV/61i7AMhozthVUhxtA8CaGQZSuqeOSRR5gy5Yuvr7n95drmC93iIEpJup5YYHBT/WmM1RNGmsBsfbXieq%2bARKyB68%2bGgqp3sK6G0AGRjW6QrQXil3P5qzUoz%2bXbaiH18XISgSWI%2b%2bxc/ymNnqIg6ZOJ2E3GIA%2b7xadsgObh74KXDqDVNEM3FcGPBPTv0ciki3/Oyd/5NpddfiUzr3uWZFLSsHwl9U4Ru5WvZq8eWxaWNYq//LeIRi%2bBaxppdBMsN1UMFQHWemyNlFdIqfmMmM2Wb17KAxvwr7/9nSEjRzJi12FbPb99BqGFRqsMUsdwgjjW%2bxyLYf68dzjlrxczJdwgrKgTUKWKcLUglo6QcTcUyYWhIBnsQIQ6zDaKLIkFUYBrDH978HV%2b%2baeFWzw26tcy8NImHK8QKVds9bqeFkQzAq1ckD7ZmjbrxJWhRMsiFDWsUeX0v3QdCMWPLhhLxhTw/PPdGDWggSGF64hIk61m3eaBbR3FeGmsjiDDkFlNgmBRA04owS8Ed4OrwncK8YK1oEJ6NHyG1galJOMveoMzTzuGB//xNtpZwdSD4uzVY2vZEnLek2txCh08AkLbhPVcSos8hNn6aLsVGmMVKojg2DS%2b5%2bDYDKef%2bmNOuOoa7tuGsNqljRUJEriZMsDBdxsQJoanHVxRu2lHRidRW6i%2bQpUhVhgnI3syc/bWi1wlfDJk0AKM3ka9KdI8e8pPmfnTmxHh1kusmO8TuAJlfVKqfKObaqxTD1ZQGHRDhDF26FvEqd%2bXLJzXm%2bVLPF6YUYz3/ly0brs2Q%2bilkX4MKTMsr%2buN8EN6//BKqlWE1o5VAM82YhyB9S3Xn1DBpdOuBsBxXf700BNc%2bPOfce55UznikLHbeG4IheLZF19gbX09dQ3V1NfXc%2budt%2bGqrdcJMZPGMSFe6JPt46aR1iJtkganeJuaaBdhpaNppNeIIIWwoMICCAR%2bWITdqFCMRwN0kGn2wLU1aFrEEJQzeL9z%2bfnvZm/9pqYBI0Ii8SjBRu8f3JjGqCGSsrghpCPbmNpufQgVGodYUNP2KxTCKFCWmPchr19Ywr%2beOpiiZAU77LaKAgQDdkjTqylAqrZvqreCrNtdQvW6gL%2bdOZR/7vIkddEE1tso/TaDFhLhwX59V3P3rTdvyDApufzXlyMMzHxlzrYzxwqM2VRE24rXt8bSJGMINMoEWAOaOBHjo8LSbd62XapCT0uqPriDxjVvg3Ww0qIdjdCSiI21OfaiC49n6vUvgWWTHl3aSxE3mrSMooxEsOWhC0f5SBcqKrqRrNv670NYhwBBOmIpCLYuQhOXrFrTg6E3rOHW75dxxuANEZ5CGJQ1WDwIBSNLVnL6917jgvv2oJvR/OB7HxOs%2bAixMED4cXA3DFK7gcJEGsB4jBqwmpHuamRjhEzEB7dtJlsU0lgMAqPg9CFt7RCLxTjisGP4500PbEfu2M37D%2b3Ws77J9qHHxctJE8ciUBRhhIZIhJiz7fHKdhFWSIBwfJDdefWVJxFSZZ2XQqA3egvDYZN2JXHdyzQIgVF1wIYqozADgVA4BjauHoRVIAKsdBFGkF77KTrUjNx1EPNmLUMaQSS0ZCISZQRGgJbZPlzcaIRUeGEan5KtPotMO7jakiYkdeDBVK1%2bnoRYSyzlgecjLAj87EQL1%2bX6Q2r5/dONfPeQKEI57LB0NUY4KGejyAepwSikDQi97IrJiAwxP2tBLVyUCUFahAxbhhKlDPjFpEIOPeFcnv3n7S2Xm3TwRFa9vBPw7rYzaHO13jZcFQWplTihy2OPPkqfPutLKAtS0rNX723esn16hbaI0t5HUljucMcjS8EWtXjaXa2579//4e4bj245XifXogqL8SlDsb2j9RorQFuJq%2bqp/Pw1kB6DBvVh8OC%2bTDllHHEnSlqCMBJhwVk/JCdiSGoxDGyZiLolrBNgvVpEkGDM3hnCD3sQWbQOIR0wbdMqRUCvWIwHr3mVEw6fSHGYoaDJR2lF6G54RQoAYTFSJLHSQQWC0G37w1FG46ts7NfG7suePeqY9cf/ALe3%2bXzytyfDf7curPWO0U3zbOvWDorgyXMEI2pvwfOdrLNZaxCC8FOHzIRbiZRtecXn9ukVqipsogcioXhpQRWRYEMPJ3AhIqt58mmPt999l9pVqxg/uhf/XaSoRRDbzjFEKyxGCIQNUcn5hDWfsfPQvVqKeSHghltvbFmsdtayj/lY1%2bNpcIyPsC5%2bj1LUNkYARBBHhFGMqKGmugCnZCS9gvdJexmivptdCrKZlIoTkSnOHwbPvulzWrfleNZmnXAbZ1ykDhPAqkh/CnQNjm7b1otSi2cy%2bDKKZ9Nt0xQKTu25jrq6eoqLNzhTHbH1ah1AYnj4kSfoVuSxy86DN9hzG71u1w8ZN0CSrplNbG0TgTLNnS6LZx2WvD2dZPcxjBo9ZrPnb7%2bwRIhLCmMNgXDbjIxL7YF1kGgcLbCtHliGESImYMrkozjhvEs5/YjJjN1vLI8/8zGX3/Ii9Ubheh6RjIPv%2bIBqadgbG8sutG81Whg0tcR9WDz3XxhRwMN//XObJJ577rktf%2b%2by9APuXDybglCSzr5oEEuGjAlJOnGKTSPGsbh%2bAdCqoe0kwQuxyvL4P7rjmjTD%2bkZAZTDatAkXioYKYV1%2bdFiC0vNn839XZCNHpYigjI9tVZ2bwGN1bR92uXYpaWuxzZEOFoOw8MY1PRgaW0silcE6bduMgSO49IgoPzrvGv72l1aRHKq4%2bccmgGwpbVu3Wy1oN07V8g%2b4%2b447EEKxY99%2bHHvMYZRaL9uhoPl8K9p48jNuARHdSEzXAQI3sM3DZxIjQv560zT%2bsXo3Pnhn%2blcTlhGWjHQQkF3meuPVh1vEZGnd2QxNIRqJtpo/XvdLopGsY%2b7E40bQUFvNzfd/SmMoCJw00qpso9IqEBpHVqGlhy8kGCjVkg/m/xpjLAOHDGXMblteDuiQvrvw149mkXQMymaD%2bQTZ8GBfRIkYTSpisMbitipeZFqhQgcZJkAplBb4FFPclEKYEOtuKE20asAJEiScdciGNAWBB1JgZdgSptxiv0iGc%2b5bgi8l%2b985jURguHD0RHqWl6MEyKr/Ep91JsJmQ8BaI42gZ7c6nrr1b9BKWK7xMUI0t5ey92vtwBWAtSEXXngRFaWF/PneP/L5qtXc%2boff8u3YG4wvac4n0bwmRatzPdvAht/Q%2bi%2by9xACEpkgG6e2BbZbWF4ocXEJrcKzejOjX1s4z2aQsgnr2k18Wmf88ECaGhdx0z2fIiuGYGSANUGzG8IQ2goiNkXEX8mqxTNZUfkWnmlk5J4TmTVr%2blbvK4Tg0jGH8ssFzyJs21aGVYATJRJoQuEj9AYzmIRHXZAgKtZw9GnV9PCTJN9JkUg14qSKkKZVaSwt2AxguXx8GVLWYcMikA1g2ppW1BcwY50hLI/Ra6f%2blDoRDth33w0HDN6ZzFs/xnd8CvyNeolSIpCcNbKGma/M4YDx3wLAd0uJhhJtLMoR2WDCVqq0eMRtkowR7LRTP66%2bJusPWzj/HT55agGOWYWxunmK2ibeny2SkQojE1sdHvlCMe97De3DnM%2bqs5EL24kISrDCw2U5DakMEW/ToYQZM2Zw6GFHEqpiiorLsTYbH%2b7rFJm6KhzRAEZhnJBfXXwtv778F9t9/9vfeZGZNZ%2b3SXEfP8Cp/4Q7T/4tMjv030IPY2hCUiUizPjoEEp9n4KmIpqWL2XilNm0fk2ABSJIJCH1IsHUs/vz4D1LCGjEmrZuYOVpTEYw5oc/pceU0Tw48bs4G092tZbhrsvSjcyrRTZSI6ME%2b008kxlP/6H5eE2QbqIiUYRBNsdZbTg5iiVpDdPnLGK/MUM2sU3t8vcZMGA42shsdNt2jqNZaYlrSfnocSya%2b9Lm8/2LCGv2669R15jc7kzN2mqDH%2bXggw/e6szhNatWM//dBTz4x3v55%2bOPY63lgP0m8OMLz2Xo0GEMHDjgC917PefNfpLP66qxrkJgSIjsuwxrF7zHxMRi0oGDFQESB0%2bDtTFEoWHM3hmkrcUJigmDFLPeTKBRFPqaBgWSCMg0wrpIayip0Kxb7WCcgBUZjwUNvVrSoKwgGREU7z6S28cdSY944WbTuurzZSxYuGjzmdW8PtfEiRPbfP7cc89tsTEuhGCvvfahuHjz99vauVukuV1XUFTAvvts/u0anWKWzraw1jLlvw%2biQk0gJa41uEFA91iS75W/iefXkQqKSEQbybg%2bVoYUpT3in6QxPeNUlWu8II2hlO4Nmhrfx5ZJtKK5XrVYGRJaB2VSCGmZ3ziSR1K7t6RBWQsIJnffmdN33fvLPso3hk41YXVLCCH4w5ijaIgIPN9irUErgVEZkPW8t2gwf/tnEU88XkzEL8INEiT/%2bgnOyXNYfs7zFGZiGFFE2oHK056m4OjpuDMrQaRQ1iBFhtUrC3jswXIqlw/CEQrHSLyQls1RLsaGfG/YXh1tjq%2bFLiEsgB6JIk4rH0pTROJYjbAKoV0cLaivzU5MbaorJO0lMUJhM5KMTFFSL6mNZuO7o1ZTutwQmATJdSlCW4hFYnB5%2baVSalMVvPzKOjQOwtEYwYYNuH/f73b69d3X0yWqwtZcNudx3k024sp1DLJNnFf4Eg1ugspKRXmpQMeqqIsaooFH%2bUpBptRjXUKghaXQ18QbAhork0QGlOCYoNmtoGla15cX5mbYYw%2bX0m4rea9pJx6t3R%2bNwLOCK0ZPYEh5r6%2bc/m8KXabEWs%2bV3zqSeH2cRl2IVk34StPoGOI7alLxRkRYRlljGbFUnGRpAqMUFUlJRaNEWJdkLEG8Tx%2b0iNLoujTSk6Qqhe4NHDoxRc/S7Pt0tOmBqwXahZ2ihV1KVNAFSywAX2t%2b9MYDZFKGno1JFhf3QNqQUBgKtMEIh4y0%2bE6IMFEcI7JzCIRB2RAtBY62aCcNYSmoJFiLMFEkFp8mrCzEKp%2bStObeiaei2mnq1jeFLiksgM9qq7joradZGyul1E%2bijERLgzIhRrjZxrc2GKUJJQhrUVoSSIWWFoHAEjZPbQ7BxAncVHb0QGqEdcGkuWXMEfQvKv/qCf6G0WWFBfBp1WqueuNZaksUZlvD/a0QItvTXG%2b69Q1yrU3Lvqstx3YbzMmj9t3u63YmOt3Ca1%2bEgd17crgs54NXF%2bI3pWgdkmDMtsc3Nv5Ntt63UnDilSd39CN2GF1aWOl0mpdfmI6jPKy12%2b2BzgYFiE2Ob%2b1KsFazcOF7jBo1uqMfs0Po0lUhwOqVq5g/b35WJOstYTeIZP0677IljksgpUAqhVIK1TxEZYzBWkMY6paZxuMP3L/L%2bK02pssK69xzz0VKSSQSIWj16pKNhdASSIhoFk/zy5fEpnGZQjRPtG2%2bxPqluq%2b//npct3O/n3BjulYfuBXRaBTXdQnDECFEtvRRCilly2t8lVIEQYAQgoyfQSqJkALTvIKybf6nTfZ1KNoYTPNbw9a30YwxLFm8mHAbM4lWrlxJY2Pj9iT9m4HNs03efuttW1ZWZh3HsUopK6W0QoiWbf1%2b6/9bHyOltEopO2jgIPvJJ59scv1LL51mhRDW87yOftR2o8tWhdvDvHfmsfc%2be5PJZL76xVqRSCSYNWsWw4cPB6CiogdVVZXAtmPRvyl02apwa6RSKfrs2Jfdx%2bxOJpNBqfZ7GZNSimQyyciRIznllFOw1jJi%2bIiW7ztLdZgX1ka88MIMEokEn69Y3lJ6rJ/50x6sv5a1loceeohYLMaY3TfEbXUWYeWrwlZMmjiJ5194HqVUu4qpDS1dx/X7tLg5hBC8u%2bBddh2%2ba0eb4ivTJUssvZke2iknn8ILM17Ifp8LUQlACoQUSEchlaSkrIzddx/DgQceiJTZ5StXrFjxlW/1P0FH9x6%2bbo456mgrhLCjRo5q%2bezuu%2b9p6cEBX2hbf87GvcDW%2b%2bXl5fa0006zd955l1382eJN0lRdXW2llBawt916a0ebqF3ocsKKxWItojDG2IbGRuu67pcS1XpBrRdFeVm5Pfnkk%2b1jjz1ugyDY7jSlUumW%2b595xpkdbaJ2ocuNFf7sZxdx1VVXAnDC8Sfw1NNPtfW8y6xHff14IDTPNGreLy0pYeDAQew2ajRj9tiDE088geLiba8XtTWi0QhKKYQQTJo08Std63%2bFLtl4X%2b9hXz9E09oEQmXbOhXdK9hv3DjGjRvH2H3HMXq3Ue3qdtiYuW/PZe26dUyceHBHm6dd6JLC6tmzJ5WVldlxPykZOmQoZ//obKZOnYrjdLlCPCd0SWE1NTVRUFCAtRbX9fD99vWs5%2bmi7oZ4PJ4NhxEQhD6ffba4o5PU6eiSwgJ4Z%2b68lr8POOiAjk5Op6PLCmvEiOHE4tn1UY88YnJHJ6fT0SXbWK1Zu3Yt5eVdbxZNrunywsqTG7psVZgnt%2bSFlScn5IWVJyfkhZUnJ%2bSFlScn5IWVJyfkhZUnJ%2bSFlScn5IWVJyfkhZUnJ%2bSFlScn5IWVJyfkhZUnJ%2bSFlScn5IWVJyfkhZUnJ%2bSFlScn5IWVJyfkhZUnJ%2bSFlScn5IWVJyfkhZUnJ%2bSFlScn5IWVJyfkhZUnJ%2bSFlScn5IWVJyf8f03l6s50K6nRAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIyLTA3LTI4VDExOjAwOjMzKzAyOjAwmirGtwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMi0wNy0yOFQxMTowMDozMyswMjowMOt3fgsAAAAASUVORK5CYII=' /%3e%3c/svg%3e";

var ja = {
	"mbitMore.name": "Boson",
	"mbitMore.whenButtonEvent": "ボタン [NAME] が [EVENT] とき",
	"mbitMore.buttonIDMenu.a": "A",
	"mbitMore.buttonIDMenu.b": "B",
	"mbitMore.buttonEventMenu.down": "押された",
	"mbitMore.buttonEventMenu.hold": "長押しされた",
	"mbitMore.buttonEventMenu.up": "離された",
	"mbitMore.buttonEventMenu.click": "クリックされた",
	"mbitMore.buttonEventMenu.longClick": "ロングクリックされた",
	"mbitMore.buttonEventMenu.doubleClick": "ダブルクリックされた",
	"mbitMore.isButtonPressed": "ボタン [NAME] が押されている",
	"mbitMore.whenTouchEvent": "ピン [NAME] が [EVENT] とき",
	"mbitMore.isPinTouched": "ピン [NAME] がタッチされている",
	"mbitMore.touchIDMenu.logo": "ロゴ",
	"mbitMore.touchEventMenu.touched": "タッチされた",
	"mbitMore.touchEventMenu.hold": "長押しされた",
	"mbitMore.touchEventMenu.released": "離された",
	"mbitMore.touchEventMenu.tapped": "タップされた",
	"mbitMore.touchEventMenu.longTapped": "ロングタップされた",
	"mbitMore.touchEventMenu.doubleTapped": "ダブルタップされた",
	"mbitMore.whenGesture": "[GESTURE] とき",
	"mbitMore.gesturesMenu.tiltUp": "上へ傾いた",
	"mbitMore.gesturesMenu.tiltDown": "下へ傾いた",
	"mbitMore.gesturesMenu.tiltLeft": "左へ傾いた",
	"mbitMore.gesturesMenu.tiltRight": "右へ傾いた",
	"mbitMore.gesturesMenu.faceUp": "表になった",
	"mbitMore.gesturesMenu.faceDown": "裏になった",
	"mbitMore.gesturesMenu.freefall": "落ちた",
	"mbitMore.gesturesMenu.g3": "3Gかかった",
	"mbitMore.gesturesMenu.g6": "6Gかかった",
	"mbitMore.gesturesMenu.g8": "8Gかかった",
	"mbitMore.gesturesMenu.shake": "ゆさぶられた",
	"mbitMore.displayMatrix": "パターン [MATRIX] を表示する",
	"mbitMore.displayText": "文字 [TEXT] を [DELAY] ミリ秒間隔で流す",
	"mbitMore.clearDisplay": "画面を消す",
	"mbitMore.isPinHigh": "ピン [PIN] がハイである",
	"mbitMore.lightLevel": "明るさ",
	"mbitMore.temperature": "温度",
	"mbitMore.compassHeading": "北からの角度",
	"mbitMore.magneticForce": "磁力 [AXIS]",
	"mbitMore.acceleration": "加速度 [AXIS]",
	"mbitMore.pitch": "ピッチ",
	"mbitMore.roll": "ロール",
	"mbitMore.soundLevel": "音の大きさ",
	"mbitMore.analogValue": "ピン [PIN] のアナログレベル",
	"mbitMore.setPullMode": "ピン [PIN] を [MODE] 入力にする",
	"mbitMore.setDigitalOut": "ピン [PIN] をデジタル出力 [LEVEL] にする",
	"mbitMore.setAnalogOut": "ピン [PIN] をアナログ出力 [LEVEL] %にする",
	"mbitMore.playTone": "[FREQ] Hzの音を [VOL] %の大きさで鳴らす",
	"mbitMore.stopTone": "音を止める",
	"mbitMore.setServo": "ピン [PIN] をサーボ [ANGLE] 度にする",
	"mbitMore.digitalValueMenu.Low": "ロー",
	"mbitMore.digitalValueMenu.High": "ハイ",
	"mbitMore.axisMenu.x": "x",
	"mbitMore.axisMenu.y": "y",
	"mbitMore.axisMenu.z": "z",
	"mbitMore.axisMenu.absolute": "大きさ",
	"mbitMore.pinModeMenu.pullNone": "開放",
	"mbitMore.pinModeMenu.pullUp": "プルアップ",
	"mbitMore.pinModeMenu.pullDown": "プルダウン",
	"mbitMore.listenPinEventType": "ピン [PIN] で [EVENT_TYPE] ",
	"mbitMore.pinEventTypeMenu.none": "イベントを受けない",
	"mbitMore.pinEventTypeMenu.edge": "エッジイベントを受ける",
	"mbitMore.pinEventTypeMenu.pulse": "パルスイベントを受ける",
	"mbitMore.pinEventTypeMenu.touch": "タッチイベントを受ける",
	"mbitMore.whenPinEvent": "ピン [PIN] で [EVENT] イベントが上がった",
	"mbitMore.pinEventMenu.rise": "ライズ",
	"mbitMore.pinEventMenu.fall": "フォール",
	"mbitMore.pinEventMenu.pulseHigh": "ハイパルス",
	"mbitMore.pinEventMenu.pulseLow": "ローパルス",
	"mbitMore.getPinEventValue": "ピン [PIN] の [EVENT]",
	"mbitMore.pinEventTimestampMenu.rise": "ライズの時刻",
	"mbitMore.pinEventTimestampMenu.fall": "フォールの時刻",
	"mbitMore.pinEventTimestampMenu.pulseHigh": "ハイパルスの期間",
	"mbitMore.pinEventTimestampMenu.pulseLow": "ローパルスの期間",
	"mbitMore.whenDataReceived": "micro:bit からラベル [LABEL] のデータを受け取ったとき",
	"mbitMore.getDataLabeled": "ラベル [LABEL] のデータ",
	"mbitMore.sendData": "micro:bit へデータ [DATA] にラベル [LABEL] を付けて送る",
	"mbitMore.connectionStateMenu.connected": "つながった",
	"mbitMore.connectionStateMenu.disconnected": "切れた",
	"mbitMore.whenConnectionChanged": "micro:bit と[STATE]とき",
	"mbitMore.selectCommunicationRoute.connectWith": "つなぎ方",
	"mbitMore.selectCommunicationRoute.bluetooth": "Bluetooth",
	"mbitMore.selectCommunicationRoute.usb": "USB",
	"mbitMore.selectCommunicationRoute.connect": "つなぐ",
	"mbitMore.selectCommunicationRoute.cancel": "やめる"
};
var pt = {
	"mbitMore.name": "Boson",
	"mbitMore.lightLevel": "Intensidade da Luz",
	"mbitMore.compassHeading": "Está em direção ao Norte",
	"mbitMore.magneticForce": "Força Magnética [AXIS]",
	"mbitMore.acceleration": "Aceleração no Eixo[AXIS]",
	"mbitMore.analogValue": "Ler Pino Analógico [PIN]",
	"mbitMore.setInput": "Definir Pino[PIN] como entrada",
	"mbitMore.setAnalogOut": "Definir pino PWM[PIN]com[LEVEL]",
	"mbitMore.setServo": "Definir Servo no pino [PIN]com ângulo de [ANGLE]॰",
	"mbitMore.digitalValueMenu.Low": "desligado",
	"mbitMore.digitalValueMenu.High": "ligado"
};
var translations = {
	ja: ja,
	"ja-Hira": {
	"mbitMore.name": "Boson",
	"mbitMore.whenButtonEvent": "[NAME] ボタンが [EVENT] とき",
	"mbitMore.buttonIDMenu.a": "A",
	"mbitMore.buttonIDMenu.b": "B",
	"mbitMore.buttonEventMenu.down": "おされた",
	"mbitMore.buttonEventMenu.hold": "ながおしされた",
	"mbitMore.buttonEventMenu.up": "はなされた",
	"mbitMore.buttonEventMenu.click": "クリックされた",
	"mbitMore.buttonEventMenu.longClick": "ロングクリックされた",
	"mbitMore.buttonEventMenu.doubleClick": "ダブルクリックされた",
	"mbitMore.isButtonPressed": "[NAME] ボタンがおされている",
	"mbitMore.whenTouchEvent": "ピン [NAME] が [EVENT] とき",
	"mbitMore.isPinTouched": "ピン [NAME] がタッチされている",
	"mbitMore.touchIDMenu.logo": "ロゴ",
	"mbitMore.touchEventMenu.touched": "タッチされた",
	"mbitMore.touchEventMenu.hold": "ながおしされた",
	"mbitMore.touchEventMenu.released": "はなされた",
	"mbitMore.touchEventMenu.tapped": "タップされた",
	"mbitMore.touchEventMenu.longTapped": "ロングタップされた",
	"mbitMore.touchEventMenu.doubleTapped": "ダブルタップされた",
	"mbitMore.whenGesture": "[GESTURE] とき",
	"mbitMore.gesturesMenu.tiltUp": "うえへかたむいた",
	"mbitMore.gesturesMenu.tiltDown": "したへかたむいた",
	"mbitMore.gesturesMenu.tiltLeft": "ひだりへかたむいた",
	"mbitMore.gesturesMenu.tiltRight": "みぎへかたむいた",
	"mbitMore.gesturesMenu.faceUp": "おもてになった",
	"mbitMore.gesturesMenu.faceDown": "うらになった",
	"mbitMore.gesturesMenu.freefall": "おちた",
	"mbitMore.gesturesMenu.g3": "3Gかかった",
	"mbitMore.gesturesMenu.g6": "6Gかかった",
	"mbitMore.gesturesMenu.g8": "8Gかかった",
	"mbitMore.gesturesMenu.shake": "ゆさぶられた",
	"mbitMore.displayMatrix": "パターン [MATRIX] をひょうじする",
	"mbitMore.displayText": "もじ [TEXT] を [DELAY] ミリびょうかんかくでながす",
	"mbitMore.clearDisplay": "がめんをけす",
	"mbitMore.isPinHigh": "ピン [PIN] がハイである",
	"mbitMore.lightLevel": "あかるさ",
	"mbitMore.temperature": "おんど",
	"mbitMore.compassHeading": "きたからのかくど",
	"mbitMore.magneticForce": "じりょく [AXIS]",
	"mbitMore.acceleration": "かそくど [AXIS]",
	"mbitMore.pitch": "ピッチ",
	"mbitMore.roll": "ロール",
	"mbitMore.soundLevel": "おとのおおきさ",
	"mbitMore.analogValue": "ピン [PIN] のアナログレベル",
	"mbitMore.setPullMode": "ピン [PIN] を [MODE] にゅうりょくにする",
	"mbitMore.setDigitalOut": "ピン [PIN] をデジタルしゅつりょく [LEVEL] にする",
	"mbitMore.setAnalogOut": "ピン [PIN] をアナログしゅつりょく [LEVEL] パーセントにする",
	"mbitMore.playTone": "[FREQ] ヘルツのおとを [VOL] パーセントの大きさで鳴らす",
	"mbitMore.stopTone": "おとをとめる",
	"mbitMore.setServo": "ピン [PIN] をサーボ [ANGLE] どにする",
	"mbitMore.digitalValueMenu.Low": "ロー",
	"mbitMore.digitalValueMenu.High": "ハイ",
	"mbitMore.axisMenu.x": "x",
	"mbitMore.axisMenu.y": "y",
	"mbitMore.axisMenu.z": "z",
	"mbitMore.axisMenu.absolute": "おおきさ",
	"mbitMore.pinModeMenu.pullNone": "かいほう",
	"mbitMore.pinModeMenu.pullUp": "プルアップ",
	"mbitMore.pinModeMenu.pullDown": "プルダウン",
	"mbitMore.listenPinEventType": "ピン [PIN] で [EVENT_TYPE]",
	"mbitMore.pinEventTypeMenu.none": "イベントをうけない",
	"mbitMore.pinEventTypeMenu.edge": "エッジイベントをうける",
	"mbitMore.pinEventTypeMenu.pulse": "パルスイベントをうける",
	"mbitMore.pinEventTypeMenu.touch": "タッチイベントをうける",
	"mbitMore.whenPinEvent": "ピン [PIN] で [EVENT] イベントがあがった",
	"mbitMore.pinEventMenu.rise": "ライズ",
	"mbitMore.pinEventMenu.fall": "フォール",
	"mbitMore.pinEventMenu.pulseHigh": "ハイパルス",
	"mbitMore.pinEventMenu.pulseLow": "ローパルス",
	"mbitMore.getPinEventValue": "ピン [PIN] の [EVENT]",
	"mbitMore.pinEventTimestampMenu.rise": "ライズのじかん",
	"mbitMore.pinEventTimestampMenu.fall": "フォールのじかん",
	"mbitMore.pinEventTimestampMenu.pulseHigh": "ハイパルスのきかん",
	"mbitMore.pinEventTimestampMenu.pulseLow": "ローパルスのきかん",
	"mbitMore.whenDataReceived": "micro:bit からラベル [LABEL] のデータをうけとったとき",
	"mbitMore.getDataLabeled": "ラベル [LABEL] のデータ",
	"mbitMore.sendData": "micro:bit へデータ [DATA] にラベル [LABEL] をつけておくる",
	"mbitMore.connectionStateMenu.connected": "つながった",
	"mbitMore.connectionStateMenu.disconnected": "きれた",
	"mbitMore.whenConnectionChanged": "micro:bit と[STATE]とき",
	"mbitMore.selectCommunicationRoute.connectWith": "つなぎかた",
	"mbitMore.selectCommunicationRoute.bluetooth": "むせん",
	"mbitMore.selectCommunicationRoute.usb": "ゆうせん",
	"mbitMore.selectCommunicationRoute.connect": "つなぐ",
	"mbitMore.selectCommunicationRoute.cancel": "やめる"
},
	"pt-br": {
	"mbitMore.name": "Boson",
	"mbitMore.lightLevel": "Intensidade da Luz",
	"mbitMore.compassHeading": "Está em direção ao Norte",
	"mbitMore.magneticForce": "Força Magnética [AXIS]",
	"mbitMore.acceleration": "Aceleração no Eixo[AXIS]",
	"mbitMore.analogValue": "Ler Pino Analógico [PIN]",
	"mbitMore.setInput": "Definir Pino[PIN] como entrada",
	"mbitMore.setAnalogOut": "Definir pino PWM[PIN]com[LEVEL]",
	"mbitMore.setServo": "Definir Servo no pino [PIN]com ângulo de [ANGLE]॰",
	"mbitMore.digitalValueMenu.Low": "desligado",
	"mbitMore.digitalValueMenu.High": "ligado"
},
	pt: pt
};

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

var JSONRPC$1 = /*#__PURE__*/function () {
  function JSONRPC() {
    _classCallCheck(this, JSONRPC);

    this._requestID = 0;
    this._openRequests = {};
  }
  /**
   * Make an RPC request and retrieve the result.
   * @param {string} method - the remote method to call.
   * @param {object} params - the parameters to pass to the remote method.
   * @returns {Promise} - a promise for the result of the call.
   */


  _createClass(JSONRPC, [{
    key: "sendRemoteRequest",
    value: function sendRemoteRequest(method, params) {
      var _this = this;

      var requestID = this._requestID++;
      var promise = new Promise(function (resolve, reject) {
        _this._openRequests[requestID] = {
          resolve: resolve,
          reject: reject
        };
      });

      this._sendRequest(method, params, requestID);

      return promise;
    }
    /**
     * Make an RPC notification with no expectation of a result or callback.
     * @param {string} method - the remote method to call.
     * @param {object} params - the parameters to pass to the remote method.
     */

  }, {
    key: "sendRemoteNotification",
    value: function sendRemoteNotification(method, params) {
      this._sendRequest(method, params);
    }
    /**
     * Handle an RPC request from remote, should return a result or Promise for result, if appropriate.
     * @param {string} method - the method requested by the remote caller.
     * @param {object} params - the parameters sent with the remote caller's request.
     */

  }, {
    key: "didReceiveCall",
    value: function
      /* method , params */
    didReceiveCall() {
      throw new Error('Must override didReceiveCall');
    }
  }, {
    key: "_sendMessage",
    value: function
      /* jsonMessageObject */
    _sendMessage() {
      throw new Error('Must override _sendMessage');
    }
  }, {
    key: "_sendRequest",
    value: function _sendRequest(method, params, id) {
      var request = {
        jsonrpc: '2.0',
        method: method,
        params: params
      };

      if (id !== null) {
        request.id = id;
      }

      this._sendMessage(request);
    }
  }, {
    key: "_handleMessage",
    value: function _handleMessage(json) {
      if (json.jsonrpc !== '2.0') {
        throw new Error("Bad or missing JSON-RPC version in message: ".concat(json));
      }

      if (json.hasOwnProperty('method')) {
        this._handleRequest(json);
      } else {
        this._handleResponse(json);
      }
    }
  }, {
    key: "_sendResponse",
    value: function _sendResponse(id, result, error) {
      var response = {
        jsonrpc: '2.0',
        id: id
      };

      if (error) {
        response.error = error;
      } else {
        response.result = result || null;
      }

      this._sendMessage(response);
    }
  }, {
    key: "_handleResponse",
    value: function _handleResponse(json) {
      var result = json.result,
          error = json.error,
          id = json.id;
      var openRequest = this._openRequests[id];
      delete this._openRequests[id];

      if (openRequest) {
        if (error) {
          openRequest.reject(error);
        } else {
          openRequest.resolve(result);
        }
      }
    }
  }, {
    key: "_handleRequest",
    value: function _handleRequest(json) {
      var _this2 = this;

      var method = json.method,
          params = json.params,
          id = json.id;
      var rawResult = this.didReceiveCall(method, params);

      if (id) {
        Promise.resolve(rawResult).then(function (result) {
          _this2._sendResponse(id, result);
        }, function (error) {
          _this2._sendResponse(id, null, error);
        });
      }
    }
  }]);

  return JSONRPC;
}();

var jsonrpc = JSONRPC$1;

var log$1 = log$2;

var uint8ArrayToBase64$2 = function uint8ArrayToBase64(array) {
  return window.btoa(String.fromCharCode.apply(String, _toConsumableArray(array)));
};

var base64ToUint8Array$2 = function base64ToUint8Array(base64) {
  var raw = window.atob(base64);
  return Uint8Array.from(Array.prototype.map.call(raw, function (x) {
    return x.charCodeAt(0);
  }));
};

var WebBLE$1 = /*#__PURE__*/function () {
  /**
   * A BLE peripheral object.  It handles connecting, over Web Bluetooth API, to
   * BLE peripherals, and reading and writing data to them.
   * @param {Runtime} runtime - the Runtime for sending/receiving GUI update events.
   * @param {string} extensionId - the id of the extension using this object.
   * @param {object} peripheralOptions - the list of options for peripheral discovery.
   * @param {object} connectCallback - a callback for connection.
   * @param {object} resetCallback - a callback for resetting extension state.
   */
  function WebBLE(runtime, extensionId, peripheralOptions, connectCallback) {
    var resetCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

    _classCallCheck(this, WebBLE);

    /**
     * Remote device which have been connected.
     * @type {BluetoothDevice}
     */
    this._device = null;
    /**
     * Remote GATT server
     * @type {BluetoothRemoteGATTServer}
     */

    this._server = null;
    this._connectCallback = connectCallback;
    this._disconnected = true;
    this._characteristicDidChangeCallback = null;
    this._resetCallback = resetCallback;
    this._extensionId = extensionId;
    this._peripheralOptions = peripheralOptions;
    this._runtime = runtime;
    this.requestPeripheral();
  }
  /**
   * Request connection to the peripheral.
   * Request user to choose a device, and then connect it automatically.
   */


  _createClass(WebBLE, [{
    key: "requestPeripheral",
    value: function requestPeripheral() {
      var _this = this;

      if (this._server) {
        this.disconnect();
      }

      navigator.bluetooth.requestDevice(this._peripheralOptions).then(function (device) {
        _this._device = device;
        log$1.debug("device=".concat(_this._device.name));

        _this._runtime.connectPeripheral(_this._extensionId, _this._device.id);
      }).catch(function (e) {
        _this._handleRequestError(e);
      });
    }
    /**
     * Try connecting to the GATT server of the device, and then call the connect
     * callback when connection is successful.
     */

  }, {
    key: "connectPeripheral",
    value: function
      /* id */
    connectPeripheral() {
      var _this2 = this;

      if (!this._device) {
        throw new Error('device is not chosen');
      }

      this._device.gatt.connect().then(function (gattServer) {
        log$1.debug("GATTServer is connected");
        _this2._server = gattServer;

        _this2._runtime.emit(_this2._runtime.constructor.PERIPHERAL_CONNECTED);

        _this2._disconnected = false;

        _this2._connectCallback();

        _this2._device.addEventListener('gattserverdisconnected', function (event) {
          _this2.onDisconnected(event);
        });
      });
    }
    /**
     * Disconnect from the device and clean up.
     * Then emit the connection state by the runtime.
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      if (!this._server) return;

      this._server.disconnect();

      this._disconnected = true;
      this._server = null;
      this._device = null;

      this._runtime.emit(this._runtime.constructor.PERIPHERAL_DISCONNECTED);
    }
    /**
     * @return {bool} whether the peripheral is connected.
     */

  }, {
    key: "isConnected",
    value: function isConnected() {
      if (!this._server) return false;
      return this._server.connected;
    }
    /**
     * Start receiving notifications from the specified ble service.
     * @param {number} serviceId - the ble service to read.
     * @param {number} characteristicId - the ble characteristic to get notifications from.
     * @param {object} onCharacteristicChanged - callback for characteristic change notifications
     *  like function(base64message).
     * @return {Promise} - a promise from the remote startNotifications request.
     */

  }, {
    key: "startNotifications",
    value: function startNotifications(serviceId, characteristicId) {
      var onCharacteristicChanged = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      return this._server.getPrimaryService(serviceId).then(function (service) {
        return service.getCharacteristic(characteristicId);
      }).then(function (characteristic) {
        characteristic.addEventListener('characteristicvaluechanged', function (event) {
          var dataView = event.target.value;
          onCharacteristicChanged(uint8ArrayToBase64$2(new Uint8Array(dataView.buffer)));
        });
        return characteristic.startNotifications();
      });
    }
    /**
     * Read from the specified ble service.
     * @param {number} serviceId - the ble service to read.
     * @param {number} characteristicId - the ble characteristic to read.
     * @param {boolean} optStartNotifications - whether to start receiving characteristic change notifications.
     * @param {object} onCharacteristicChanged - callback for characteristic change notifications
     *  like function(base64message).
     * @return {Promise} - a promise from the remote read request which resolve {message: base64string}.
     */

  }, {
    key: "read",
    value: function read(serviceId, characteristicId) {
      var _this3 = this;

      var optStartNotifications = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var onCharacteristicChanged = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      return this._server.getPrimaryService(serviceId).then(function (service) {
        return service.getCharacteristic(characteristicId);
      }).then(function (characteristic) {
        if (optStartNotifications) {
          return _this3.startNotifications(serviceId, characteristicId, onCharacteristicChanged).then(function () {
            return characteristic.readValue();
          });
        }

        return characteristic.readValue();
      }).then(function (dataView) {
        return {
          message: uint8ArrayToBase64$2(new Uint8Array(dataView.buffer))
        };
      });
    }
    /**
     * Write data to the specified ble service.
     * @param {number} serviceId - the ble service to write.
     * @param {number} characteristicId - the ble characteristic to write.
     * @param {string} message - the message to send.
     * @param {string} encoding - the message encoding type.
     * @param {boolean} withResponse - if true, resolve after peripheral's response.
     * @return {Promise} - a promise from the remote send request.
     */
    // eslint-disable-next-line no-unused-vars

  }, {
    key: "write",
    value: function write(serviceId, characteristicId, message) {
      var encoding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var withResponse = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var value = encoding === 'base64' ? base64ToUint8Array$2(message) : message;
      return this._server.getPrimaryService(serviceId).then(function (service) {
        return service.getCharacteristic(characteristicId);
      }).then(function (characteristic) {
        if (withResponse && characteristic.writeValueWithResponse) {
          return characteristic.writeValueWithResponse(value);
        }

        if (characteristic.writeValueWithoutResponse) {
          return characteristic.writeValueWithoutResponse(value);
        }

        return characteristic.writeValue(value);
      });
    }
    /**
     * Handle an error resulting from losing connection to a peripheral.
     *
     * This could be due to:
     * - battery depletion
     * - going out of bluetooth range
     * - being powered down
     *
     * Disconnect the device, and if the extension using this object has a
     * reset callback, call it. Finally, emit an error to the runtime.
     */

  }, {
    key: "handleDisconnectError",
    value: function
      /* e */
    handleDisconnectError() {
      // log.error(`BLE error: ${JSON.stringify(e)}`);
      if (this._disconnected) return;
      this.disconnect();

      if (this._resetCallback) {
        this._resetCallback();
      }

      this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTION_LOST_ERROR, {
        message: "Scratch lost connection to",
        extensionId: this._extensionId
      });
    }
  }, {
    key: "_handleRequestError",
    value: function
      /* e */
    _handleRequestError() {
      // log.error(`BLE error: ${JSON.stringify(e)}`);
      this._runtime.emit(this._runtime.constructor.PERIPHERAL_REQUEST_ERROR, {
        message: "Scratch lost connection to",
        extensionId: this._extensionId
      });
    }
    /**
     * Called when disconnected by the device.
     */

  }, {
    key: "onDisconnected",
    value: function
      /* event */
    onDisconnected() {
      this.handleDisconnectError(new Error('device disconnected'));
    }
  }]);

  return WebBLE;
}();

var bleWeb = WebBLE$1;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var JSONRPC = jsonrpc;
var WebBLE = bleWeb;

var BLE$1 = /*#__PURE__*/function (_JSONRPC) {
  _inherits(BLE, _JSONRPC);

  var _super = _createSuper(BLE);

  /**
   * A BLE peripheral socket object.  It handles connecting, over web sockets, to
   * BLE peripherals, and reading and writing data to them.
   * @param {Runtime} runtime - the Runtime for sending/receiving GUI update events.
   * @param {string} extensionId - the id of the extension using this socket.
   * @param {object} peripheralOptions - the list of options for peripheral discovery.
   * @param {object} connectCallback - a callback for connection.
   * @param {object} resetCallback - a callback for resetting extension state.
   */
  function BLE(runtime, extensionId, peripheralOptions, connectCallback) {
    var _this;

    var resetCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

    _classCallCheck(this, BLE);

    _this = _super.call(this);
    _this._socket = runtime.getScratchLinkSocket('BLE');

    _this._socket.setOnOpen(_this.requestPeripheral.bind(_assertThisInitialized(_this)));

    _this._socket.setOnClose(_this.handleDisconnectError.bind(_assertThisInitialized(_this)));

    _this._socket.setOnError(_this._handleRequestError.bind(_assertThisInitialized(_this)));

    _this._socket.setHandleMessage(_this._handleMessage.bind(_assertThisInitialized(_this)));

    _this._sendMessage = _this._socket.sendMessage.bind(_this._socket);
    _this._availablePeripherals = {};
    _this._connectCallback = connectCallback;
    _this._connected = false;
    _this._characteristicDidChangeCallback = null;
    _this._resetCallback = resetCallback;
    _this._discoverTimeoutID = null;
    _this._extensionId = extensionId;
    _this._peripheralOptions = peripheralOptions;
    _this._runtime = runtime;

    _this._socket.open();

    return _this;
  }
  /**
   * Request connection to the peripheral.
   * If the web socket is not yet open, request when the socket promise resolves.
   */


  _createClass(BLE, [{
    key: "requestPeripheral",
    value: function requestPeripheral() {
      var _this2 = this;

      this._availablePeripherals = {};

      if (this._discoverTimeoutID) {
        window.clearTimeout(this._discoverTimeoutID);
      }

      this._discoverTimeoutID = window.setTimeout(this._handleDiscoverTimeout.bind(this), 15000);
      this.sendRemoteRequest('discover', this._peripheralOptions).catch(function (e) {
        _this2._handleRequestError(e);
      });
    }
    /**
     * Try connecting to the input peripheral id, and then call the connect
     * callback if connection is successful.
     * @param {number} id - the id of the peripheral to connect to
     */

  }, {
    key: "connectPeripheral",
    value: function connectPeripheral(id) {
      var _this3 = this;

      this.sendRemoteRequest('connect', {
        peripheralId: id
      }).then(function () {
        _this3._connected = true;

        _this3._runtime.emit(_this3._runtime.constructor.PERIPHERAL_CONNECTED);

        _this3._connectCallback();
      }).catch(function (e) {
        _this3._handleRequestError(e);
      });
    }
    /**
     * Close the websocket.
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      if (this._connected) {
        this._connected = false;
      }

      if (this._socket.isOpen()) {
        this._socket.close();
      }

      if (this._discoverTimeoutID) {
        window.clearTimeout(this._discoverTimeoutID);
      } // Sets connection status icon to orange


      this._runtime.emit(this._runtime.constructor.PERIPHERAL_DISCONNECTED);
    }
    /**
     * @return {bool} whether the peripheral is connected.
     */

  }, {
    key: "isConnected",
    value: function isConnected() {
      return this._connected;
    }
    /**
     * Start receiving notifications from the specified ble service.
     * @param {number} serviceId - the ble service to read.
     * @param {number} characteristicId - the ble characteristic to get notifications from.
     * @param {object} onCharacteristicChanged - callback for characteristic change notifications.
     * @return {Promise} - a promise from the remote startNotifications request.
     */

  }, {
    key: "startNotifications",
    value: function startNotifications(serviceId, characteristicId) {
      var _this4 = this;

      var onCharacteristicChanged = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var params = {
        serviceId: serviceId,
        characteristicId: characteristicId
      };
      this._characteristicDidChangeCallback = onCharacteristicChanged;
      return this.sendRemoteRequest('startNotifications', params).catch(function (e) {
        _this4.handleDisconnectError(e);
      });
    }
    /**
     * Read from the specified ble service.
     * @param {number} serviceId - the ble service to read.
     * @param {number} characteristicId - the ble characteristic to read.
     * @param {boolean} optStartNotifications - whether to start receiving characteristic change notifications.
     * @param {object} onCharacteristicChanged - callback for characteristic change notifications.
     * @return {Promise} - a promise from the remote read request.
     */

  }, {
    key: "read",
    value: function read(serviceId, characteristicId) {
      var _this5 = this;

      var optStartNotifications = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var onCharacteristicChanged = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var params = {
        serviceId: serviceId,
        characteristicId: characteristicId
      };

      if (optStartNotifications) {
        params.startNotifications = true;
      }

      if (onCharacteristicChanged) {
        this._characteristicDidChangeCallback = onCharacteristicChanged;
      }

      return this.sendRemoteRequest('read', params).catch(function (e) {
        _this5.handleDisconnectError(e);
      });
    }
    /**
     * Write data to the specified ble service.
     * @param {number} serviceId - the ble service to write.
     * @param {number} characteristicId - the ble characteristic to write.
     * @param {string} message - the message to send.
     * @param {string} encoding - the message encoding type.
     * @param {boolean} withResponse - if true, resolve after peripheral's response.
     * @return {Promise} - a promise from the remote send request.
     */

  }, {
    key: "write",
    value: function write(serviceId, characteristicId, message) {
      var _this6 = this;

      var encoding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var withResponse = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var params = {
        serviceId: serviceId,
        characteristicId: characteristicId,
        message: message
      };

      if (encoding) {
        params.encoding = encoding;
      }

      if (withResponse !== null) {
        params.withResponse = withResponse;
      }

      return this.sendRemoteRequest('write', params).catch(function (e) {
        _this6.handleDisconnectError(e);
      });
    }
    /**
     * Handle a received call from the socket.
     * @param {string} method - a received method label.
     * @param {object} params - a received list of parameters.
     * @return {object} - optional return value.
     */

  }, {
    key: "didReceiveCall",
    value: function didReceiveCall(method, params) {
      switch (method) {
        case 'didDiscoverPeripheral':
          this._availablePeripherals[params.peripheralId] = params;

          this._runtime.emit(this._runtime.constructor.PERIPHERAL_LIST_UPDATE, this._availablePeripherals);

          if (this._discoverTimeoutID) {
            window.clearTimeout(this._discoverTimeoutID);
          }

          break;

        case 'userDidPickPeripheral':
          this._availablePeripherals[params.peripheralId] = params;

          this._runtime.emit(this._runtime.constructor.USER_PICKED_PERIPHERAL, this._availablePeripherals);

          if (this._discoverTimeoutID) {
            window.clearTimeout(this._discoverTimeoutID);
          }

          break;

        case 'userDidNotPickPeripheral':
          this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);

          if (this._discoverTimeoutID) {
            window.clearTimeout(this._discoverTimeoutID);
          }

          break;

        case 'characteristicDidChange':
          if (this._characteristicDidChangeCallback) {
            this._characteristicDidChangeCallback(params.message);
          }

          break;

        case 'ping':
          return 42;
      }
    }
    /**
     * Handle an error resulting from losing connection to a peripheral.
     *
     * This could be due to:
     * - battery depletion
     * - going out of bluetooth range
     * - being powered down
     *
     * Disconnect the socket, and if the extension using this socket has a
     * reset callback, call it. Finally, emit an error to the runtime.
     */

  }, {
    key: "handleDisconnectError",
    value: function
      /* e */
    handleDisconnectError() {
      // log.error(`BLE error: ${JSON.stringify(e)}`);
      if (!this._connected) return;
      this.disconnect();

      if (this._resetCallback) {
        this._resetCallback();
      }

      this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTION_LOST_ERROR, {
        message: "Scratch lost connection to",
        extensionId: this._extensionId
      });
    }
  }, {
    key: "_handleRequestError",
    value: function
      /* e */
    _handleRequestError() {
      // log.error(`BLE error: ${JSON.stringify(e)}`);
      this._runtime.emit(this._runtime.constructor.PERIPHERAL_REQUEST_ERROR, {
        message: "Scratch lost connection to",
        extensionId: this._extensionId
      });
    }
  }, {
    key: "_handleDiscoverTimeout",
    value: function _handleDiscoverTimeout() {
      if (this._discoverTimeoutID) {
        window.clearTimeout(this._discoverTimeoutID);
      }

      this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);
    }
  }]);

  return BLE;
}(JSONRPC);

var ble$1 = navigator.bluetooth ? WebBLE : BLE$1;

var BLE = ble$1;
var ble = BLE;

var log = log$2;

var uint8ArrayToBase64$1 = function uint8ArrayToBase64(array) {
  return window.btoa(String.fromCharCode.apply(String, _toConsumableArray(array)));
};

var base64ToUint8Array$1 = function base64ToUint8Array(base64) {
  var raw = window.atob(base64);
  return Uint8Array.from(Array.prototype.map.call(raw, function (x) {
    return x.charCodeAt(0);
  }));
};
/**
 * Characteristic ID on serial-port.
 */


var SERIAL_CH_ID = {
  '0b500100-607f-4151-9091-7d008d6ffc5c': 0x0100,
  '0b500101-607f-4151-9091-7d008d6ffc5c': 0x0101,
  '0b500102-607f-4151-9091-7d008d6ffc5c': 0x0102,
  '0b500110-607f-4151-9091-7d008d6ffc5c': 0x0110,
  '0b500111-607f-4151-9091-7d008d6ffc5c': 0x0111,
  '0b500120-607f-4151-9091-7d008d6ffc5c': 0x0120,
  '0b500121-607f-4151-9091-7d008d6ffc5c': 0x0121,
  '0b500122-607f-4151-9091-7d008d6ffc5c': 0x0122,
  '0b500130-607f-4151-9091-7d008d6ffc5c': 0x0130
};
/**
 * Start Frame Delimiter
 */

var SFD = 0xFF;
/**
 * Request type in data frame.
 */

var ChRequest = {
  READ: 0x01,
  WRITE: 0x10,
  WRITE_RESPONSE: 0x11,
  NOTIFY_STOP: 0x20,
  NOTIFY_START: 0x21
};
/**
 * Response type in data frame.
 */

var ChResponse = {
  READ: 0x01,
  WRITE_RESPONSE: 0x11,
  NOTIFY: 0x21
};
/**
 * Class to communicate with device via USB serial-port using Web Serial API.
 */

var WebSerial = /*#__PURE__*/function () {
  /**
   * A BLE peripheral object.  It handles connecting, over Web Bluetooth API, to
   * BLE peripherals, and reading and writing data to them.
   * @param {Runtime} runtime - the Runtime for sending/receiving GUI update events.
   * @param {string} extensionId - the id of the extension using this object.
   * @param {object} peripheralOptions - the list of options for peripheral discovery.
   * @param {function} connectCallback - a callback for connection.
   * @param {function} resetCallback - a callback for resetting extension state.
   */
  function WebSerial(runtime, extensionId, peripheralOptions, connectCallback) {
    var resetCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

    _classCallCheck(this, WebSerial);

    /**
     * Remote device which have been connected.
     * @type {SerialPort}
     */
    this.port = null;
    this._connectCallback = connectCallback;
    this.state = 'init';
    this._resetCallback = resetCallback;
    this._extensionId = extensionId;
    this._peripheralOptions = peripheralOptions;
    this._serialOptions = {
      // baudRate: 57600
      baudRate: 115200 // Default for micro:bit

    };
    this._runtime = runtime;
    this.receivingInterval = 1;
    this.sendDataInterval = 10; // Time for receiving process in micro:bit

    /**
     * Store of received type and value for each characteristics.
     * @type {Object.<number, Object.<number, Uint8Array>>} - { ch: { type: value }}.
     */

    this.chValues = {};
    /**
     * Notification callbacks.
     * @type {Object.<number, function>} - { ch: callback }
     */

    this.notifyListeners = {};
    this.requestPeripheral();
  }
  /**
   * Request connection to the peripheral.
   * Request user to choose a device, and then connect it automatically.
   * @return {Promise} - a Promise which will resolved when a serial-port was selected.
   */


  _createClass(WebSerial, [{
    key: "requestPeripheral",
    value: function requestPeripheral() {
      var _this = this;

      var promise = Promise.resolve();

      if (this.isConnected()) {
        promise = promise.then(function () {
          return _this.disconnect();
        });
      }

      return promise.then(function () {
        navigator.serial.requestPort(_this._peripheralOptions).then(function (selected) {
          _this.port = selected;

          _this._runtime.connectPeripheral(_this._extensionId, null);
        }).catch(function (e) {
          _this._handleRequestError(e);
        });
      });
    }
    /**
     * Try connecting to the serial-port of the device, and then call the connect
     * callback when connection is successful.
     */

  }, {
    key: "connectPeripheral",
    value: function
      /* id */
    connectPeripheral() {
      var _this2 = this;

      if (!this.port) {
        throw new Error('device is not chosen');
      }

      var ChValueTransformer = /*#__PURE__*/function () {
        function ChValueTransformer() {
          _classCallCheck(this, ChValueTransformer);

          // A container for holding stream data until a new frame.
          this.chunks = [];
        }

        _createClass(ChValueTransformer, [{
          key: "transform",
          value: function transform(chunk, controller) {
            // Append new chunks to existing chunks.
            this.chunks = this.chunks.concat(Array.from(chunk)); // Split chunks into {ch: {type: value}.
            // Skip until SFD occurred

            var frameStart = this.chunks.findIndex(function (element) {
              return element === SFD;
            });

            if (frameStart === -1) {
              this.chunks = [];
              return;
            }

            this.chunks = this.chunks.slice(frameStart); // Read header

            if (this.chunks.length < 5) {
              return;
            }

            var type = this.chunks[1];

            if (type > ChResponse.NOTIFY) {
              this.chunks = []; // remove all until SFD + valid type

              return;
            }

            var ch = this.chunks[2] << 8 | this.chunks[3];
            var valueLength = this.chunks[4];
            var frameEnd = 5 + valueLength;

            if (this.chunks.length < frameEnd + 1) {
              return;
            }

            var value = this.chunks.slice(5, frameEnd); // Checksum

            var checksum = this.chunks.slice(0, frameEnd).reduce(function (acc, cur) {
              return acc + cur;
            }) % 0xFF;

            if (checksum === this.chunks[frameEnd]) {
              // Received successfully
              this.chunks.splice(0, frameEnd + 1);
              controller.enqueue({
                ch: ch,
                data: {
                  type: type,
                  value: value
                }
              });
            } else {
              // Error occurred
              log.debug(this.chunks); // debug

              this.chunks.shift(); // Remove current SFD

              return;
            }
          }
        }, {
          key: "flush",
          value: function flush(controller) {
            // When the stream is closed, delete any remaining chunks.
            controller.terminate();
          }
        }]);

        return ChValueTransformer;
      }();

      this.port.open(this._serialOptions).then(function () {
        log.log("SerialPort: open");
        _this2.state = 'open';
        _this2.writer = _this2.port.writable.getWriter(); // eslint-disable-next-line no-undef

        var chValueTransformStream = new TransformStream(new ChValueTransformer());
        _this2.readableStreamClosed = _this2.port.readable.pipeTo(chValueTransformStream.writable);
        _this2.reader = chValueTransformStream.readable.getReader();

        _this2.port.addEventListener('disconnect', function (event) {
          _this2.onDisconnected(event);
        });

        _this2._runtime.emit(_this2._runtime.constructor.PERIPHERAL_CONNECTED);

        _this2._connectCallback();

        _this2.startReceiving();
      });
    }
    /**
     * Disconnect from the device and clean up.
     * Then emit the connection state by the runtime.
     * @return {Promise} - a Promise which will resolve when the serial-port was disconnected.
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      var _this3 = this;

      if (this.state !== 'open') return Promise.resolve();
      this.state = 'closing';
      this.stopReceiving();
      return this.reader.cancel().then(function () {
        return _this3.readableStreamClosed.catch(function () {
          /* Ignore the error */
        });
      }).then(function () {
        _this3.writer.close();

        _this3.writer.releaseLock();

        return _this3.write.closed;
      }).then(function () {
        _this3.port.close();

        _this3.state = 'close';
        _this3.reader = null;
        _this3.writer = null;
        _this3.port = null;

        _this3._runtime.emit(_this3._runtime.constructor.PERIPHERAL_DISCONNECTED);
      });
    }
    /**
     * @return {bool} whether the peripheral is connected.
     */

  }, {
    key: "isConnected",
    value: function isConnected() {
      return this.state === 'open';
    }
    /**
     * Receive data and process it.
     * @returns {Promise} - a Promise which will resolve when read next data
     */

  }, {
    key: "receiveData",
    value: function receiveData() {
      var _this4 = this;

      return this.reader.read().then(function (result) {
        var value = result.value,
            done = result.done;

        if (done) {
          _this4.reader.releaseLock();
        }

        if (value) {
          var data = value.data;
          var ch = value.ch;

          if (!_this4.chValues[ch]) {
            _this4.chValues[ch] = {};
          }

          _this4.chValues[ch][data.type] = data.value;

          if (data.type === ChResponse.NOTIFY) {
            if (ch in _this4.notifyListeners) {
              _this4.notifyListeners[ch](uint8ArrayToBase64$1(data.value));
            }
          } // log.debug({ch: ch, type: data.type, value: data.value});

        }
      });
    }
    /**
     * Start data receiving process.
     */

  }, {
    key: "startReceiving",
    value: function startReceiving() {
      var _this5 = this;

      this.dataReceiving = window.setTimeout(function () {
        if (_this5.state !== 'open') return;

        _this5.receiveData().then(function () {
          // start again
          _this5.startReceiving();
        }).catch(function () {
          _this5.handleDisconnectError();
        });
      }, this.receivingInterval);
    }
    /**
     * Stop data receiving process.
     */

  }, {
    key: "stopReceiving",
    value: function stopReceiving() {
      clearTimeout(this.dataReceiving);
      this.dataReceiving = null;
    }
    /**
     * Send data to the device.
     * @param {Uint8Array} data - data to send
     * @returns {Promise} - a Promise which will resolve write process was done
     */

  }, {
    key: "sendData",
    value: function sendData(data) {
      var _this6 = this;

      return this.writer.ready.then(function () {
        return _this6.writer.write(data);
      }).then(function () {
        return new Promise(function (resolve) {
          setTimeout(function () {
            return resolve();
          }, _this6.sendDataInterval); // Wait for receiving process in micro:bit
        });
      });
    }
    /**
     * Start receiving notifications from the device.
     * @param {number} _serviceId - the ble service to read. (ignore it for serial-port)
     * @param {number} characteristicId - the ble characteristic to get notifications from.
     * @param {function?} onCharacteristicChanged - callback for characteristic change notifications
     *  like function(base64message).
     * @return {Promise} - a Promise which will resolve when requested start notification.
     */

  }, {
    key: "startNotifications",
    value: function startNotifications(_serviceId, characteristicId) {
      var onCharacteristicChanged = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      // Connected device will start necessary notifications automatically on serial-port.
      this.notifyListeners[SERIAL_CH_ID[characteristicId]] = onCharacteristicChanged;
      return Promise.resolve();
    }
  }, {
    key: "readCh",
    value: function readCh(ch) {
      var _this7 = this;

      if (this.state !== 'open') {
        return Promise.reject(new Error('port is not opened'));
      }

      return new Promise(function (resolve) {
        var dataFrame = new Uint8Array(4);
        dataFrame[0] = SFD;
        dataFrame[1] = ChRequest.READ;
        dataFrame[2] = ch >> 8;
        dataFrame[3] = ch & 0xFF;

        if (_this7.chValues[ch]) {
          _this7.chValues[ch][ChResponse.READ] = null;
        }

        _this7.sendData(dataFrame).then(function () {
          var checkInterval = 10;

          var check = function check(count) {
            var received = _this7.chValues[ch];

            if (received && received[ChResponse.READ]) {
              return resolve({
                message: uint8ArrayToBase64$1(received[ChResponse.READ])
              });
            }

            count--;

            if (count === 0) {
              return resolve(null);
            }

            setTimeout(function () {
              check(count);
            }, checkInterval);
          };

          check(20);
        });
      });
    }
    /**
     * Read from the specified ble service.
     * @param {number} serviceId - the ble service to read.
     * @param {number} characteristicId - the ble characteristic to read.
     * @param {boolean} optStartNotifications - whether to start receiving characteristic change notifications.
     * @param {function} onCharacteristicChanged - callback for characteristic change notifications
     *  like function(base64message).
     * @return {Promise} - a Promise from the remote read request which resolve {message: base64string}.
     */

  }, {
    key: "read",
    value: function read(serviceId, characteristicId) {
      var _this8 = this;

      var optStartNotifications = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var onCharacteristicChanged = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var ch = SERIAL_CH_ID[characteristicId];
      var constantUpdatingCh = [0x0101,
      /* State */
      0x0102
      /* Motion */
      ];

      if (constantUpdatingCh.includes(ch)) {
        // Return already received values because rapid repeating requests will make the port freeze.
        if (!this.chValues[ch]) {
          return Promise.resolve(null);
        }

        return Promise.resolve({
          message: uint8ArrayToBase64$1(this.chValues[ch][ChResponse.READ])
        });
      }

      var readRetry = function readRetry(count) {
        return new Promise(function (resolve, reject) {
          if (count < 0) {
            reject(new Error("no response"));
            log.debug("read ch: ".concat(ch, " dose not response"));
            return;
          }

          _this8.readCh(ch).then(function (result) {
            if (result) {
              if (optStartNotifications) {
                _this8.startNotifications(serviceId, characteristicId, onCharacteristicChanged).then(function () {
                  return resolve(result);
                });

                return;
              }

              resolve(result);
              return;
            }

            count--;
            resolve(readRetry(count));
            return;
          }).catch(function (err) {
            resolve(null);
            log.debug(err);
            return;
          });
        });
      };

      return readRetry(2).catch(function (err) {
        log.debug(err);

        _this8.handleDisconnectError(err);

        return;
      });
    }
    /**
     * Write value on the characteristic.
     * @param {number} ch - characteristic to write
     * @param {Uint8Array} value - value to write
     * @param {boolean} withResponse - whether request response or not
     * @returns {Promise} - a Promise which will resolve true when success to write
     */

  }, {
    key: "writeCh",
    value: function writeCh(ch, value, withResponse) {
      var _this9 = this;

      if (this.state !== 'open') {
        return Promise.reject(new Error('port is not opened'));
      }

      return new Promise(function (resolve) {
        var header = new Uint8Array(5);
        header[0] = SFD;
        header[1] = withResponse ? ChRequest.WRITE_RESPONSE : ChRequest.WRITE;
        header[2] = ch >> 8;
        header[3] = ch & 0xFF;
        header[4] = value.length;
        var dataFrame = new Uint8Array([].concat(_toConsumableArray(header), _toConsumableArray(value), [0]));
        dataFrame[dataFrame.length - 1] = dataFrame.reduce(function (acc, cur) {
          return acc + cur;
        }) % 0xFF;

        if (withResponse) {
          _this9.sendData(dataFrame).then(function () {
            var checkInterval = 10;

            var check = function check(count) {
              var received = _this9.chValues[ch];

              if (received && received[ChResponse.WRITE_RESPONSE]) {
                return resolve(received[ChResponse.WRITE_RESPONSE][0] === 1);
              }

              count--;

              if (count === 0) {
                return resolve(false);
              }

              setTimeout(function () {
                check(count);
              }, checkInterval);
            };

            check(20);
          });
        } else {
          _this9.sendData(dataFrame).then(function () {
            return resolve(true);
          });
        }
      });
    }
    /**
     * Write data to the specified ble service.
     * @param {number} serviceId - the ble service to write.
     * @param {number} characteristicId - the ble characteristic to write.
     * @param {string} message - the message to send.
     * @param {string} encoding - the message encoding type.
     * @param {boolean} withResponse - if true, resolve after peripheral's response. Always true for serial port.
     * @return {Promise} - a Promise which will resolve true when success to write or reject with 'no response'
     */
    // eslint-disable-next-line no-unused-vars

  }, {
    key: "write",
    value: function write(serviceId, characteristicId, message) {
      var _this10 = this;

      var encoding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var withResponse = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      withResponse = true; // "response" is always required for noise tolerance on serial-port.

      var value = encoding === 'base64' ? base64ToUint8Array$1(message) : message;
      var ch = SERIAL_CH_ID[characteristicId];

      if (this.chValues[ch]) {
        this.chValues[ch][ChResponse.WRITE_RESPONSE] = null;
      }

      var writeRetry = function writeRetry(count) {
        return new Promise(function (resolve, reject) {
          if (count < 0) {
            reject(new Error("no response"));
            log.debug("write ch: ".concat(ch, " dose not response"));
            return;
          }

          _this10.writeCh(ch, value, withResponse).then(function (result) {
            if (result) {
              resolve(result);
              return;
            }

            count--;
            resolve(writeRetry(count));
            return;
          }).catch(function (err) {
            resolve(null);
            log.debug(err);
            return;
          });
        });
      };

      return writeRetry(2).catch(function (err) {
        log.debug(err);

        _this10.handleDisconnectError(err);

        return;
      });
    }
    /**
     * Handle an error resulting from losing connection to a peripheral.
     *
     * This could be due to:
     * - battery depletion
     * - going out of bluetooth range
     * - being powered down
     *
     * Disconnect the device, and if the extension using this object has a
     * reset callback, call it. Finally, emit an error to the runtime.
     */

  }, {
    key: "handleDisconnectError",
    value: function
      /* e */
    handleDisconnectError() {
      var _this11 = this;

      if (this.state !== 'open') return;
      this.disconnect().then(function () {
        if (_this11._resetCallback) {
          _this11._resetCallback();
        }

        _this11._runtime.emit(_this11._runtime.constructor.PERIPHERAL_CONNECTION_LOST_ERROR, {
          message: "Scratch lost connection to",
          extensionId: _this11._extensionId
        });
      });
    }
  }, {
    key: "_handleRequestError",
    value: function
      /* e */
    _handleRequestError() {
      // log.error(`BLE error: ${JSON.stringify(e)}`);
      this._runtime.emit(this._runtime.constructor.PERIPHERAL_REQUEST_ERROR, {
        message: "Scratch lost connection to",
        extensionId: this._extensionId
      });
    }
    /**
     * Called when disconnected by the device.
     */

  }, {
    key: "onDisconnected",
    value: function
      /* event */
    onDisconnected() {
      this.handleDisconnectError(new Error('device disconnected'));
    }
  }]);

  return WebSerial;
}();

var serialWeb = WebSerial;

var uint8ArrayToBase64 = function uint8ArrayToBase64(array) {
  return window.btoa(String.fromCharCode.apply(String, _toConsumableArray(array)));
};

var base64ToUint8Array = function base64ToUint8Array(base64) {
  var raw = window.atob(base64);
  return Uint8Array.from(Array.prototype.map.call(raw, function (x) {
    return x.charCodeAt(0);
  }));
};

var formatMessage = function formatMessage(messageData) {
  return messageData.defaultMessage;
};
/**
 * Setup format-message for this extension.
 */


var setupTranslations = function setupTranslations() {
  var localeSetup = formatMessage.setup();

  if (localeSetup && localeSetup.translations[localeSetup.locale]) {
    Object.assign(localeSetup.translations[localeSetup.locale], translations[localeSetup.locale]);
  }
};

var EXTENSION_ID = 'microbitMore';
/**
 * URL to get this extension as a module.
 * When it was loaded as a module, 'extensionURL' will be replaced a URL which is retrieved from.
 * @type {string}
 */

var extensionURL = 'https://eu-rate-boson.github.io/dist/microbitMore.mjs';
/**
 * Enum for version of the hardware.
 * @readonly
 * @enum {number}
 */

var MbitMoreHardwareVersion = {
  MICROBIT_V1: 1,
  MICROBIT_V2: 2
};
/**
 * Communication route between Scratch and micro:bit
 *
 */

var CommunicationRoute = {
  BLE: 0,
  SERIAL: 1
};
/**
 * Enum for micro:bit BLE command protocol.
 * https://github.com/LLK/scratch-microbit-firmware/blob/master/protocol.md
 * @readonly
 * @enum {number}
 */

var BLECommand = {
  CMD_CONFIG: 0x00,
  CMD_PIN: 0x01,
  CMD_DISPLAY: 0x02,
  CMD_AUDIO: 0x03,
  CMD_DATA: 0x04
};
/**
 * Enum for command about gpio pins.
 * @readonly
 * @enum {number}
 */

var MbitMorePinCommand = {
  SET_OUTPUT: 0x01,
  SET_PWM: 0x02,
  SET_SERVO: 0x03,
  SET_PULL: 0x04,
  SET_EVENT: 0x05
};
/**
 * Enum for command about gpio pins.
 * @readonly
 * @enum {number}
 */

var MbitMoreDisplayCommand = {
  CLEAR: 0x00,
  TEXT: 0x01,
  PIXELS_0: 0x02,
  PIXELS_1: 0x03
};
/**
 * Enum for name of pull mode.
 * @readonly
 * @enum {number}
 */

var MbitMorePullModeName = {
  NONE: 'NONE',
  DOWN: 'DOWN',
  UP: 'UP'
};
/**
 * Enum for ID of pull mode.
 * @readonly
 * @enum {number}
 */

var MbitMorePullModeID = {
  NONE: 0,
  DOWN: 1,
  UP: 2
};
/**
 * Enum for data format.
 * @readonly
 * @enum {number}
 */

var MbitMoreDataFormat = {
  CONFIG: 0x10,
  // not used at this version
  PIN_EVENT: 0x11,
  ACTION_EVENT: 0x12,
  DATA_NUMBER: 0x13,
  DATA_TEXT: 0x14
};
/**
 * Enum for action event type.
 * @readonly
 * @enum {number}
 */

var MbitMoreActionEvent = {
  BUTTON: 0x01,
  GESTURE: 0x02
};
/**
 * Enum for ID of pin-mode
 * @readonly
 * @enum {string}
 */

var MbitMorePinMode = {
  INPUT: 'INPUT',
  OUTPUT: 'OUTPUT',
  PWM: 'PWM',
  SERVO: 'SERVO',
  TOUCH: 'TOUCH'
};
/**
 * Enum for ID of buttons
 * @readonly
 * @enum {string}
 */

var MbitMoreButtonName = {
  P0: 'P0',
  P1: 'P1',
  P2: 'P2',
  A: 'A',
  B: 'B',
  LOGO: 'LOGO'
};
/**
 * Enum for componentID of buttons
 * @readonly
 * @enum {string}
 */

var MbitMoreButtonID = {
  1: 'A',
  2: 'B',
  100: 'P0',
  101: 'P1',
  102: 'P2',
  121: 'LOGO'
};
/**
 * Enum for index of pin for buttons
 * @readonly
 * @enum {number}
 */

var MbitMoreButtonPinIndex = {
  P0: 0,
  P1: 1,
  P2: 2
};
/**
 * Enum for index in data of button state
 * @readonly
 * @enum {number}
 */

var MbitMoreButtonStateIndex = {
  P0: 0,
  P1: 1,
  P2: 2,
  A: 3,
  B: 4,
  LOGO: 5
};
/**
 * Enum for name of event from button
 * @readonly
 * @enum {string}
 */

var MbitMoreButtonEventName = {
  DOWN: 'DOWN',
  UP: 'UP',
  CLICK: 'CLICK',
  LONG_CLICK: 'LONG_CLICK',
  HOLD: 'HOLD',
  DOUBLE_CLICK: 'DOUBLE_CLICK'
};
/**
 * Enum for ID of event from button
 * @readonly
 * @enum {string}
 */

var MbitMoreButtonEventID = {
  1: 'DOWN',
  2: 'UP',
  3: 'CLICK',
  4: 'LONG_CLICK',
  5: 'HOLD',
  6: 'DOUBLE_CLICK'
};
/**
 * Enum for name of gesture.
 * @readonly
 * @enum {string}
 */

var MbitMoreGestureName = {
  TILT_UP: 'TILT_UP',
  TILT_DOWN: 'TILT_DOWN',
  TILT_LEFT: 'TILT_LEFT',
  TILT_RIGHT: 'TILT_RIGHT',
  FACE_UP: 'FACE_UP',
  FACE_DOWN: 'FACE_DOWN',
  FREEFALL: 'FREEFALL',
  G3: 'G3',
  G6: 'G6',
  G8: 'G8',
  SHAKE: 'SHAKE'
};
/**
 * Enum for ID of gesture.
 * @readonly
 * @enum {string}
 */

var MbitMoreGestureID = {
  1: 'TILT_UP',
  2: 'TILT_DOWN',
  3: 'TILT_LEFT',
  4: 'TILT_RIGHT',
  5: 'FACE_UP',
  6: 'FACE_DOWN',
  7: 'FREEFALL',
  8: 'G3',
  9: 'G6',
  10: 'G8',
  11: 'SHAKE'
};
/**
 * Enum for event type in the micro:bit runtime.
 * @readonly
 * @enum {number}
 */

var MbitMorePinEventType = {
  NONE: 0,
  ON_EDGE: 1,
  ON_PULSE: 2,
  ON_TOUCH: 3
};
/**
 * Enum for event value in the micro:bit runtime.
 * @readonly
 * @enum {number}
 */

var MbitMorePinEvent = {
  RISE: 2,
  FALL: 3,
  PULSE_HIGH: 4,
  PULSE_LOW: 5
};
/**
 * Enum for data type of data-sending.
 * @readonly
 * @enum {number}
 */

var MbitMoreSendingDataType = {
  NUMBER: 1,
  TEXT: 2
};
/**
 * Enum for sub-command about configurations.
 * @readonly
 * @enum {number}
 */

var MbitMoreConfig = {
  MIC: 0x01,
  TOUCH: 0x02
};
/**
 * Enum for sub-command about audio.
 * @readonly
 * @enum {number}
 */

var MbitMoreAudioCommand = {
  STOP_TONE: 0x00,
  PLAY_TONE: 0x01
};
/**
 * A time interval to wait (in milliseconds) before reporting to the BLE socket
 * that data has stopped coming from the peripheral.
 */

var BLETimeout = 4500;
/**
 * A string to report to the BLE socket when the micro:bit has stopped receiving data.
 * @type {string}
 */

var BLEDataStoppedError = 'micro:bit extension stopped receiving data';
var MM_SERVICE = {
  ID: '0b50f3e4-607f-4151-9091-7d008d6ffc5c',
  COMMAND_CH: '0b500100-607f-4151-9091-7d008d6ffc5c',
  STATE_CH: '0b500101-607f-4151-9091-7d008d6ffc5c',
  MOTION_CH: '0b500102-607f-4151-9091-7d008d6ffc5c',
  PIN_EVENT_CH: '0b500110-607f-4151-9091-7d008d6ffc5c',
  ACTION_EVENT_CH: '0b500111-607f-4151-9091-7d008d6ffc5c',
  ANALOG_IN_CH: ['0b500120-607f-4151-9091-7d008d6ffc5c', '0b500121-607f-4151-9091-7d008d6ffc5c', '0b500122-607f-4151-9091-7d008d6ffc5c'],
  MESSAGE_CH: '0b500130-607f-4151-9091-7d008d6ffc5c'
};
/**
 * Enum for axis menu options.
 * @readonly
 * @enum {string}
 */

var AxisSymbol = {
  X: 'x',
  Y: 'y',
  Z: 'z',
  Absolute: 'absolute'
};
/**
 * The unit-value of the gravitational acceleration from Micro:bit.
 * @type {number}
 */

var G = 1024;
/**
 * Manage communication with a MicroBit peripheral over a Scrath Link client socket.
 */

var MbitMore = /*#__PURE__*/function () {
  /**
   * Construct a MicroBit communication object.
   * @param {Runtime} runtime - the Scratch 3.0 runtime
   * @param {string} extensionId - the id of the extension
   */
  function MbitMore(runtime, extensionId) {
    var _this = this;

    _classCallCheck(this, MbitMore);

    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this.runtime = runtime;
    /**
     * The BluetoothLowEnergy connection socket for reading/writing peripheral data.
     * @type {BLE}
     * @private
     */

    this._ble = null;
    this.runtime.registerPeripheralExtension(extensionId, this);
    /**
     * The id of the extension this peripheral belongs to.
     */

    this._extensionId = extensionId;
    this.digitalLevel = {};
    this.lightLevel = 0;
    this.temperature = 0;
    this.soundLevel = 0;
    this.pitch = 0;
    this.roll = 0;
    this.acceleration = {
      x: 0,
      y: 0,
      z: 0
    };
    this.compassHeading = 0;
    this.magneticForce = {
      x: 0,
      y: 0,
      z: 0
    };
    this.buttonState = {};
    /**
     * The most recently received button events for each buttons.
     * @type {Object} - Store of buttons which has events.
     * @private
     */

    this.buttonEvents = {};
    Object.keys(MbitMoreButtonStateIndex).forEach(function (name) {
      _this.buttonEvents[name] = {};
    });
    /**
     * The most recently received gesture events.
     * @type {Object <number, number>} - Store of gesture ID and timestamp.
     * @private
     */

    this.gestureEvents = {};
    /**
     * The most recently received events for each pin.
     * @type {Object} - Store of pins which has events.
     * @private
     */

    this._pinEvents = {};
    /**
     * The most recently received data from micro:bit.
     * @type {Object} - Store of received data
     * @private
     */

    this.receivedData = {};
    this.analogIn = [0, 1, 2];
    this.analogValue = [];
    this.analogIn.forEach(function (pinIndex) {
      _this.analogValue[pinIndex] = 0;
    });
    this.gpio = [0, 1, 2, 8, 12, 13, 14, 15, 16];
    this.gpio.forEach(function (pinIndex) {
      _this.digitalLevel[pinIndex] = 0;
    });
    /**
     * Interval ID for data reading timeout.
     * @type {number}
     * @private
     */

    this._timeoutID = null;
    /**
     * A flag that is true while we are busy sending data to the BLE socket.
     * @type {boolean}
     * @private
     */

    this.bleBusy = true;
    /**
     * ID for a timeout which is used to clear the busy flag if it has been
     * true for a long time.
     */

    this.bleBusyTimeoutID = null;
    this.onDisconnect = this.onDisconnect.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this.onNotify = this.onNotify.bind(this);
    this.stopTone = this.stopTone.bind(this);

    if (this.runtime) {
      this.runtime.on('PROJECT_STOP_ALL', this.stopTone);
    }

    this.analogInUpdateInterval = 100; // milli-seconds

    this.analogInLastUpdated = [Date.now(), Date.now(), Date.now()];
    /**
     * A time interval to wait (in milliseconds) while a block that sends a BLE message is running.
     * @type {number}
     */

    this.sendCommandInterval = 30;
    this.initConfig(); // keyboard state monitor

    this.keyState = {};
    document.body.addEventListener('keydown', function (e) {
      _this.keyState[e.code] = {
        key: e.key,
        code: e.code,
        alt: e.altKey,
        ctrl: e.ctrlKey,
        meta: e.metaKey,
        shift: e.shiftKey
      };
    });
    document.body.addEventListener('keyup', function (e) {
      delete _this.keyState[e.code];
    });
  }
  /**
   * Initialize configuration of the micro:bit.
   */


  _createClass(MbitMore, [{
    key: "initConfig",
    value: function initConfig() {
      this.config = {};
      this.config.mic = false;
      this.config.pinMode = {};
    }
    /**
     * Start updating process for micro:bit state and motion.
     */

  }, {
    key: "startUpdater",
    value: function startUpdater() {
      var _this2 = this;

      if (this.updater) {
        clearTimeout(this.updater);
      }

      if (this.bleAccessWaiting) {
        this.updater = setTimeout(function () {
          return _this2.startUpdater();
        }, 0);
        return;
      }

      this.updateState().then(function () {
        return _this2.updateMotion();
      }).finally(function () {
        _this2.updater = setTimeout(function () {
          return _this2.startUpdater();
        }, _this2.microbitUpdateInterval);
      });
    }
    /**
     * Stop updating process for micro:bit state and motion.
     */

  }, {
    key: "stopUpdater",
    value: function stopUpdater() {
      clearTimeout(this.updater);
    }
    /**
     * @param {string} text - the text to display.
     * @param {number} delay - The time to delay between characters, in milliseconds.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */

  }, {
    key: "displayText",
    value: function displayText(text, delay, util) {
      var textLength = Math.min(18, text.length);
      var textData = new Uint8Array(textLength + 1);

      for (var i = 0; i < textLength; i++) {
        textData[i] = text.charCodeAt(i);
      }

      return this.sendCommandSet([{
        id: BLECommand.CMD_DISPLAY << 5 | MbitMoreDisplayCommand.TEXT,
        message: new Uint8Array([Math.min(255, Math.max(0, delay) / 10)].concat(_toConsumableArray(textData)))
      }], util);
    }
    /**
     * Send display pixcels command to micro:bit.
     * @param {Array.<Array.<number>>} matrix - pattern to display.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */

  }, {
    key: "displayPixels",
    value: function displayPixels(matrix, util) {
      var cmdSet = [{
        id: BLECommand.CMD_DISPLAY << 5 | MbitMoreDisplayCommand.PIXELS_0,
        message: new Uint8Array([].concat(_toConsumableArray(matrix[0]), _toConsumableArray(matrix[1]), _toConsumableArray(matrix[2])))
      }, {
        id: BLECommand.CMD_DISPLAY << 5 | MbitMoreDisplayCommand.PIXELS_1,
        message: new Uint8Array([].concat(_toConsumableArray(matrix[3]), _toConsumableArray(matrix[4])))
      }];
      return this.sendCommandSet(cmdSet, util);
    }
    /**
     * Set pull mode to the pin.
     * @param {number} pinIndex - index of the pin
     * @param {MbitMorePullModeID} pullMode - pull mode to set
     * @param {BlockUtility} util - utility object provided from the runtime
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */

  }, {
    key: "setPullMode",
    value: function setPullMode(pinIndex, pullMode, util) {
      this.config.pinMode[pinIndex] = MbitMorePinMode.INPUT;
      return this.sendCommandSet([{
        id: BLECommand.CMD_PIN << 5 | MbitMorePinCommand.SET_PULL,
        message: new Uint8Array([pinIndex, pullMode])
      }], util);
    }
    /**
     * Set pin to digital output mode on the level.
     * @param {number} pinIndex - Index of pin.
     * @param {boolean} level - Value in digital (true = High)
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */

  }, {
    key: "setPinOutput",
    value: function setPinOutput(pinIndex, level, util) {
      this.config.pinMode[pinIndex] = MbitMorePinMode.OUTPUT;
      return this.sendCommandSet([{
        id: BLECommand.CMD_PIN << 5 | MbitMorePinCommand.SET_OUTPUT,
        message: new Uint8Array([pinIndex, level ? 1 : 0])
      }], util);
    }
    /**
     * Set the pin to PWM mode on the level.
     * @param {number} pinIndex - index of the pin
     * @param {number} level - value of analog output [0..1024].
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */

  }, {
    key: "setPinPWM",
    value: function setPinPWM(pinIndex, level, util) {
      this.config.pinMode[pinIndex] = MbitMorePinMode.PWM;
      var dataView = new DataView(new ArrayBuffer(2));
      dataView.setUint16(0, level, true);
      return this.sendCommandSet([{
        id: BLECommand.CMD_PIN << 5 | MbitMorePinCommand.SET_PWM,
        message: new Uint8Array([pinIndex, dataView.getUint8(0), dataView.getUint8(1)])
      }], util);
    }
    /**
     * Set the pin to Servo mode on the angle in the range and center.
     * @param {number} pinIndex - index of the pin.
     * @param {number} angle - the level to set on the output pin, in the range 0 - 180.
     * @param {number} range - the span of possible values. '0' means default(2000).
     * @param {number} center - the center point from which to calculate the lower and upper bounds.
     *                          '0' means default(1500).
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */

  }, {
    key: "setPinServo",
    value: function setPinServo(pinIndex, angle, range, center, util) {
      this.config.pinMode[pinIndex] = MbitMorePinMode.SERVO;
      if (!range || range < 0) range = 0;
      if (!center || center < 0) center = 0;
      var dataView = new DataView(new ArrayBuffer(6));
      dataView.setUint16(0, angle, true);
      dataView.setUint16(2, range, true);
      dataView.setUint16(4, center, true);
      return this.sendCommandSet([{
        id: BLECommand.CMD_PIN << 5 | MbitMorePinCommand.SET_SERVO,
        message: new Uint8Array([pinIndex, dataView.getUint8(0), dataView.getUint8(1), dataView.getUint8(2), dataView.getUint8(3), dataView.getUint8(4), dataView.getUint8(5)])
      }], util);
    }
    /**
     * Read light level from the light sensor.
     * @param {object} util - utility object provided by the runtime.
     * @return {number} - value of the light level [0..255].
     */

  }, {
    key: "readLightLevel",
    value: function readLightLevel() {
      if (!this.isConnected()) {
        return 0;
      }

      return this.lightLevel;
    }
    /**
     * Update data of the analog input.
     * @param {number} pinIndex - index of the pin to get value.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves value of analog input or undefined if this process was yield.
     */

  }, {
    key: "readAnalogIn",
    value: function readAnalogIn(pinIndex, util) {
      var _this3 = this;

      if (!this.isConnected()) {
        return Promise.resolve(0);
      }

      if (Date.now() - this.analogInLastUpdated[pinIndex] < this.analogInUpdateInterval) {
        return Promise.resolve(this.analogValue[pinIndex]);
      }

      if (this.bleBusy) {
        this.bleAccessWaiting = true;
        if (util) util.yield(); // re-try this call after a while.

        return; // Do not return Promise.resolve() to re-try.
      }

      this.bleBusy = true;
      this.bleBusyTimeoutID = window.setTimeout(function () {
        _this3.bleBusy = false;
        _this3.bleAccessWaiting = false;
      }, 1000);
      return new Promise(function (resolve) {
        return _this3._ble.read(MM_SERVICE.ID, MM_SERVICE.ANALOG_IN_CH[pinIndex], false).then(function (result) {
          window.clearTimeout(_this3.bleBusyTimeoutID);
          _this3.bleBusy = false;
          _this3.bleAccessWaiting = false;

          if (!result) {
            return resolve(_this3.analogValue[pinIndex]);
          }

          var data = base64ToUint8Array(result.message);
          var dataView = new DataView(data.buffer, 0);
          _this3.analogValue[pinIndex] = dataView.getUint16(0, true);
          _this3.analogInLastUpdated = Date.now();
          resolve(_this3.analogValue[pinIndex]);
        });
      });
    }
    /**
     * Update data of digital level, light level, temperature, sound level.
     * @return {Promise} - a Promise that resolves updated data holder.
     */

  }, {
    key: "updateState",
    value: function updateState() {
      var _this4 = this;

      if (!this.isConnected()) return Promise.resolve(this);

      if (this.bleBusy) {
        return Promise.resolve(this);
      }

      this.bleBusy = true;
      this.bleBusyTimeoutID = window.setTimeout(function () {
        _this4.bleBusy = false;
      }, 1000);
      return new Promise(function (resolve) {
        _this4._ble.read(MM_SERVICE.ID, MM_SERVICE.STATE_CH, false).then(function (result) {
          window.clearTimeout(_this4.bleBusyTimeoutID);
          _this4.bleBusy = false;
          if (!result) return resolve(_this4);
          var data = base64ToUint8Array(result.message);
          var dataView = new DataView(data.buffer, 0); // Digital Input

          var gpioData = dataView.getUint32(0, true);

          for (var i = 0; i < _this4.gpio.length; i++) {
            _this4.digitalLevel[_this4.gpio[i]] = gpioData >> _this4.gpio[i] & 1;
          }

          Object.keys(MbitMoreButtonStateIndex).forEach(function (name) {
            _this4.buttonState[name] = gpioData >> 24 + MbitMoreButtonStateIndex[name] & 1;
          });
          _this4.lightLevel = dataView.getUint8(4);
          _this4.temperature = dataView.getUint8(5) - 128;
          _this4.soundLevel = dataView.getUint8(6);

          _this4.resetConnectionTimeout();

          resolve(_this4);
        });
      });
    }
    /**
     * Read temperature (integer in celsius) from the micro:bit cpu.
     * @return {number} - degrees of temperature [centigrade].
     */

  }, {
    key: "readTemperature",
    value: function readTemperature() {
      if (!this.isConnected()) {
        return 0;
      }

      return this.temperature;
    }
    /**
     * Configurate microphone.
     * @param {boolean} use - true to use microphone.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} - a Promise that resolves state of the microphone or undefined if the process was yield.
     */

  }, {
    key: "configMic",
    value: function configMic(use, util) {
      var _this5 = this;

      use = use === true;

      if (!this.isConnected()) {
        return Promise.resolve(false);
      }

      if (this.config.mic === use) {
        return Promise.resolve(this.config.mic);
      }

      var sendPromise = this.sendCommandSet([{
        id: BLECommand.CMD_CONFIG << 5 | MbitMoreConfig.MIC,
        message: new Uint8Array([use ? 1 : 0]) // use microphone

      }], util);

      if (sendPromise) {
        return sendPromise.then(function () {
          _this5.config.mic = use;
          return _this5.config.mic;
        });
      }

      return;
    }
    /**
     * Play tone on the speaker.
     * @param {number} frequency - wave frequency to play [Hz]
     * @param {number} volume laudness of tone [%]
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} - a Promise that resolves to send command or undefined if this process was yield.
     */

  }, {
    key: "playTone",
    value: function playTone(frequency, volume, util) {
      if (!this.isConnected()) {
        return Promise.resolve();
      }

      var frequencyData = new DataView(new ArrayBuffer(4));
      frequencyData.setUint32(0, Math.round(1000000 / frequency), true);
      volume = Math.round(volume * 0xff / 100);
      return this.sendCommandSet([{
        id: BLECommand.CMD_AUDIO << 5 | MbitMoreAudioCommand.PLAY_TONE,
        message: new Uint8Array([frequencyData.getUint8(0), frequencyData.getUint8(1), frequencyData.getUint8(2), frequencyData.getUint8(3), volume])
      }], util);
    }
    /**
     * Stop playing tone on the speaker.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} - a Promise that resolves to send command or undefined if this process was yield.
     */

  }, {
    key: "stopTone",
    value: function stopTone(util) {
      if (!this.isConnected()) {
        return Promise.resolve();
      }

      return this.sendCommandSet([{
        id: BLECommand.CMD_AUDIO << 5 | MbitMoreAudioCommand.STOP_TONE,
        message: new Uint8Array([])
      }], util);
    }
    /**
     * Read sound level.
     * @return {number} - level of loudness (0 .. 255).
     */

  }, {
    key: "readSoundLevel",
    value: function readSoundLevel() {
      if (!this.isConnected()) {
        return 0;
      }

      return this.soundLevel;
    }
    /**
     * Update data of acceleration, magnetic force.
     * @return {Promise} - a Promise that resolves updated data holder.
     */

  }, {
    key: "updateMotion",
    value: function updateMotion() {
      var _this6 = this;

      if (!this.isConnected()) return Promise.resolve(this);

      if (this.bleBusy) {
        return Promise.resolve(this);
      }

      this.bleBusy = true;
      this.bleBusyTimeoutID = window.setTimeout(function () {
        _this6.bleBusy = false;
      }, 1000);
      return new Promise(function (resolve) {
        _this6._ble.read(MM_SERVICE.ID, MM_SERVICE.MOTION_CH, false).then(function (result) {
          window.clearTimeout(_this6.bleBusyTimeoutID);
          _this6.bleBusy = false;
          if (!result) return resolve(_this6);
          var data = base64ToUint8Array(result.message);
          var dataView = new DataView(data.buffer, 0); // Accelerometer

          _this6.pitch = Math.round(dataView.getInt16(0, true) * 180 / Math.PI / 1000);
          _this6.roll = Math.round(dataView.getInt16(2, true) * 180 / Math.PI / 1000);
          _this6.acceleration.x = 1000 * dataView.getInt16(4, true) / G;
          _this6.acceleration.y = 1000 * dataView.getInt16(6, true) / G;
          _this6.acceleration.z = 1000 * dataView.getInt16(8, true) / G; // Magnetometer

          _this6.compassHeading = dataView.getUint16(10, true);
          _this6.magneticForce.x = dataView.getInt16(12, true);
          _this6.magneticForce.y = dataView.getInt16(14, true);
          _this6.magneticForce.z = dataView.getInt16(16, true);

          _this6.resetConnectionTimeout();

          resolve(_this6);
        });
      });
    }
    /**
     * Read pitch [degrees] of the micro:bit heading direction.
     * @return {number} - degree of pitch.
     */

  }, {
    key: "readPitch",
    value: function readPitch() {
      if (!this.isConnected()) {
        return 0;
      }

      return this.pitch;
    }
    /**
     * Read roll [degrees] of the micro:bit heading direction.
     * @return {number} - degree of roll.
     */

  }, {
    key: "readRoll",
    value: function readRoll() {
      if (!this.isConnected()) {
        return 0;
      }

      return this.roll;
    }
    /**
     * Read the value of gravitational acceleration [milli-g] for the axis.
     * @param {AxisSymbol} axis - direction of acceleration.
     * @return {number} - value of acceleration.
     */

  }, {
    key: "readAcceleration",
    value: function readAcceleration(axis) {
      if (!this.isConnected()) {
        return 0;
      }

      if (axis === AxisSymbol.Absolute) {
        return Math.round(Math.sqrt(Math.pow(this.acceleration.x, 2) + Math.pow(this.acceleration.y, 2) + Math.pow(this.acceleration.z, 2)));
      }

      return this.acceleration[axis];
    }
    /**
     * Read the angle (degrees) of heading direction from the north.
     * @return {number} - degree of compass heading.
     */

  }, {
    key: "readCompassHeading",
    value: function readCompassHeading() {
      if (!this.isConnected()) {
        return 0;
      }

      return this.compassHeading;
    }
    /**
     * Read value of magnetic force [micro teslas] for the axis.
     * @param {AxisSymbol} axis - direction of magnetic force.
     * @return {number} - value of magnetic force.
     */

  }, {
    key: "readMagneticForce",
    value: function readMagneticForce(axis) {
      if (!this.isConnected()) {
        return 0;
      }

      if (axis === AxisSymbol.Absolute) {
        return Math.round(Math.sqrt(Math.pow(this.magneticForce.x, 2) + Math.pow(this.magneticForce.y, 2) + Math.pow(this.magneticForce.z, 2)));
      }

      return this.magneticForce[axis];
    }
    /**
     * Start to scan Bluetooth LE devices to find micro:bit with Boson service.
     */

  }, {
    key: "scanBLE",
    value: function scanBLE() {
      var connectorClass = ble;
      this._ble = new connectorClass(this.runtime, this._extensionId, {
        filters: [{
          namePrefix: 'BBC micro:bit'
        }, {
          services: [MM_SERVICE.ID]
        }]
      }, this._onConnect, this.onDisconnect);
    }
    /**
     * Start to scan USB serial devices to find micro:bit v2.
     */

  }, {
    key: "scanSerial",
    value: function scanSerial() {
      this._ble = new serialWeb(this.runtime, this._extensionId, {
        filters: [{
          usbVendorId: 0x0d28,
          usbProductId: 0x0204
        }]
      }, this._onConnect, this.onDisconnect);
    }
    /**
     * Open dialog to selector communication route [BLE | USB Serial]
     */

  }, {
    key: "selectCommunicationRoute",
    value: function selectCommunicationRoute() {
      var _this7 = this;

      var selectDialog = document.createElement('dialog');
      selectDialog.style.padding = '0px';
      var dialogFace = document.createElement('div');
      dialogFace.style.padding = '16px';
      selectDialog.appendChild(dialogFace);
      var label = document.createTextNode(formatMessage({
        id: 'mbitMore.selectCommunicationRoute.connectWith',
        default: 'Connect with',
        description: 'label of select communication route dialog for Boson extension'
      }));
      dialogFace.appendChild(label); // Dialog form

      var selectForm = document.createElement('form');
      selectForm.setAttribute('method', 'dialog');
      selectForm.style.margin = '8px';
      dialogFace.appendChild(selectForm); // API select

      var apiSelect = document.createElement('select');
      apiSelect.setAttribute('id', 'api');
      selectForm.appendChild(apiSelect); // BLE option

      var bleOption = document.createElement('option');
      bleOption.setAttribute('value', 'ble');
      bleOption.textContent = formatMessage({
        id: 'mbitMore.selectCommunicationRoute.bluetooth',
        default: 'Bluetooth',
        description: 'bluetooth button on select communication route dialog for Boson extension'
      });
      apiSelect.appendChild(bleOption); // USB option

      var usbOption = document.createElement('option');
      usbOption.setAttribute('value', 'usb');
      usbOption.textContent = formatMessage({
        id: 'mbitMore.selectCommunicationRoute.usb',
        default: 'USB',
        description: 'usb button on select communication route dialog for Boson extension'
      });
      apiSelect.appendChild(usbOption); // Cancel button

      var cancelButton = document.createElement('button');
      cancelButton.textContent = formatMessage({
        id: 'mbitMore.selectCommunicationRoute.cancel',
        default: 'cancel',
        description: 'cancel button on select communication route dialog for Boson extension'
      });
      cancelButton.style.margin = '8px';
      dialogFace.appendChild(cancelButton); // OK button

      var confirmButton = document.createElement('button');
      confirmButton.textContent = formatMessage({
        id: 'mbitMore.selectCommunicationRoute.connect',
        default: 'connect',
        description: 'connect button on select communication route dialog for Boson extension'
      });
      confirmButton.style.margin = '8px';
      dialogFace.appendChild(confirmButton); // Add onClick action

      var selectProcess = function selectProcess() {
        if (apiSelect.value === 'ble') {
          _this7.scanBLE();
        }

        if (apiSelect.value === 'usb') {
          _this7.scanSerial();
        }

        document.body.removeChild(selectDialog);
      };

      cancelButton.onclick = function () {
        document.body.removeChild(selectDialog);

        _this7.runtime.emit(_this7.runtime.constructor.PERIPHERAL_REQUEST_ERROR, {
          message: "Scan was canceled by user",
          extensionId: _this7._extensionId
        });
      };

      confirmButton.onclick = selectProcess;
      selectDialog.addEventListener('keydown', function (e) {
        if (e.code === 'Enter') {
          selectProcess();
        }
      }); // Close when click outside of the dialog
      // selectDialog.onclick = e => {
      //     if (!e.target.closest('div')) {
      //         e.target.close();
      //         selectProcess();
      //     }
      // };

      document.body.appendChild(selectDialog);
      selectDialog.showModal();
    }
    /**
     * Whether the key is pressed at this moment.
     * @param {string} key - key in keyboard event
     * @returns {boolean} - return true when the key is pressed
     */

  }, {
    key: "isKeyPressing",
    value: function isKeyPressing(key) {
      return Object.values(this.keyState).find(function (state) {
        return state.key === key;
      });
    }
    /**
     * Called by the runtime when user wants to scan for a peripheral.
     */

  }, {
    key: "scan",
    value: function scan() {
      if (this._ble) {
        this._ble.disconnect();
      }

      this.bleBusy = true;

      if ('serial' in navigator && this.isKeyPressing('Shift')) {
        this.selectCommunicationRoute();
      } else {
        this.scanBLE();
      }
    }
    /**
     * Called by the runtime when user wants to connect to a certain peripheral.
     * @param {number} id - the id of the peripheral to connect to.
     */

  }, {
    key: "connect",
    value: function connect(id) {
      if (this._ble) {
        this._ble.connectPeripheral(id);
      }
    }
    /**
     * Disconnect from the micro:bit.
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      if (this._ble) {
        this._ble.disconnect();
      }

      this.onDisconnect();
    }
    /**
     * Reset all the state and timeout/interval ids.
     */

  }, {
    key: "onDisconnect",
    value: function onDisconnect() {
      this.stopUpdater();

      if (this._timeoutID) {
        window.clearTimeout(this._timeoutID);
        this._timeoutID = null;
      }
    }
    /**
     * Return true if connected to the micro:bit.
     * @return {boolean} - whether the micro:bit is connected.
     */

  }, {
    key: "isConnected",
    value: function isConnected() {
      var connected = false;

      if (this._ble) {
        connected = this._ble.isConnected();
      }

      return connected;
    }
    /**
     * Send a command to micro:bit.
     * @param {object} command command to send.
     * @param {number} command.id ID of the command.
     * @param {Uint8Array} command.message Contents of the command.
     * @return {Promise} a Promise that resolves when the data was sent and after send command interval.
     */

  }, {
    key: "sendCommand",
    value: function sendCommand(command) {
      var _this8 = this;

      var data = uint8ArrayToBase64(new Uint8Array([command.id].concat(_toConsumableArray(command.message))));
      return new Promise(function (resolve) {
        _this8._ble.write(MM_SERVICE.ID, MM_SERVICE.COMMAND_CH, data, 'base64', false);

        setTimeout(function () {
          return resolve();
        }, _this8.sendCommandInterval);
      });
    }
    /**
     * Send multiple commands sequentially.
     * @param {Array.<{id: number, message: Uint8Array}>} commands array of command.
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when the all commands was sent.
     */

  }, {
    key: "sendCommandSet",
    value: function sendCommandSet(commands, util) {
      var _this9 = this;

      if (!this.isConnected()) return Promise.resolve();

      if (this.bleBusy) {
        this.bleAccessWaiting = true;

        if (util) {
          util.yield(); // re-try this call after a while.
        } else {
          setTimeout(function () {
            return _this9.sendCommandSet(commands, util);
          }, 1);
        }

        return; // Do not return Promise.resolve() to re-try.
      }

      this.bleBusy = true; // Clear busy and BLE access waiting flag when the scratch-link does not respond.

      this.bleBusyTimeoutID = window.setTimeout(function () {
        _this9.bleBusy = false;
        _this9.bleAccessWaiting = false;
      }, 1000);
      return new Promise(function (resolve) {
        commands.reduce(function (acc, cur) {
          return acc.then(function () {
            return _this9.sendCommand(cur);
          });
        }, Promise.resolve()).then(function () {
          window.clearTimeout(_this9.bleBusyTimeoutID);
        }).catch(function (err) {
          log$2.log(err);

          _this9._ble.handleDisconnectError(err);
        }).finally(function () {
          _this9.bleBusy = false;
          _this9.bleAccessWaiting = false;
          resolve();
        });
      });
    }
    /**
     * Starts reading data from peripheral after BLE has connected to it.
     */

  }, {
    key: "_onConnect",
    value: function _onConnect() {
      var _this10 = this;

      this._ble.read(MM_SERVICE.ID, MM_SERVICE.COMMAND_CH, false).then(function (result) {
        if (!result) {
          throw new Error('Config is not readable');
        }

        var data = base64ToUint8Array(result.message);
        var dataView = new DataView(data.buffer, 0);
        _this10.hardware = dataView.getUint8(0);
        _this10.protocol = dataView.getUint8(1);
        _this10.route = dataView.getUint8(2);

        _this10._ble.startNotifications(MM_SERVICE.ID, MM_SERVICE.ACTION_EVENT_CH, _this10.onNotify);

        _this10._ble.startNotifications(MM_SERVICE.ID, MM_SERVICE.PIN_EVENT_CH, _this10.onNotify);

        if (_this10.hardware === MbitMoreHardwareVersion.MICROBIT_V1) {
          _this10.microbitUpdateInterval = 100; // milliseconds
        } else {
          _this10._ble.startNotifications(MM_SERVICE.ID, MM_SERVICE.MESSAGE_CH, _this10.onNotify);

          _this10.microbitUpdateInterval = 50; // milliseconds
        }

        if (_this10.route === CommunicationRoute.SERIAL) {
          _this10.sendCommandInterval = 100; // milliseconds
        } else {
          _this10.sendCommandInterval = 30; // milliseconds
        }

        _this10.initConfig();

        _this10.bleBusy = false;

        _this10.startUpdater();

        _this10.resetConnectionTimeout();
      }).catch(function (err) {
        return _this10._ble.handleDisconnectError(err);
      });
    }
    /**
     * Process the data from the incoming BLE characteristic.
     * @param {string} msg - the incoming BLE data.
     * @private
     */

  }, {
    key: "onNotify",
    value: function onNotify(msg) {
      var data = base64ToUint8Array(msg);
      var dataView = new DataView(data.buffer, 0);
      var dataFormat = dataView.getUint8(19);

      if (dataFormat === MbitMoreDataFormat.ACTION_EVENT) {
        var actionEventType = dataView.getUint8(0);

        if (actionEventType === MbitMoreActionEvent.BUTTON) {
          var buttonName = MbitMoreButtonID[dataView.getUint16(1, true)];
          var eventName = MbitMoreButtonEventID[dataView.getUint8(3)];
          this.buttonEvents[buttonName][eventName] = dataView.getUint32(4, true); // Timestamp
        } else if (actionEventType === MbitMoreActionEvent.GESTURE) {
          var gestureName = MbitMoreGestureID[dataView.getUint8(1)];
          this.gestureEvents[gestureName] = dataView.getUint32(2, true); // Timestamp
        }
      } else if (dataFormat === MbitMoreDataFormat.PIN_EVENT) {
        var pinIndex = dataView.getUint8(0);

        if (!this._pinEvents[pinIndex]) {
          this._pinEvents[pinIndex] = {};
        }

        var event = dataView.getUint8(1);
        this._pinEvents[pinIndex][event] = {
          value: dataView.getUint32(2, true),
          // timesamp of the edge or duration of the pulse
          timestamp: Date.now() // received time

        };
      } else if (dataFormat === MbitMoreDataFormat.DATA_NUMBER) {
        var label = new TextDecoder().decode(data.slice(0, 8).filter(function (char) {
          return char !== 0;
        }));
        this.receivedData[label] = {
          content: dataView.getFloat32(8, true),
          timestamp: Date.now()
        };
      } else if (dataFormat === MbitMoreDataFormat.DATA_TEXT) {
        var _label = new TextDecoder().decode(data.slice(0, 8).filter(function (char) {
          return char !== 0;
        }));

        this.receivedData[_label] = {
          content: new TextDecoder().decode(data.slice(8, 20).filter(function (char) {
            return char !== 0;
          })),
          timestamp: Date.now()
        };
      }

      this.resetConnectionTimeout();
    }
    /**
     * Cancel disconnect timeout and start counting again.
     */

  }, {
    key: "resetConnectionTimeout",
    value: function resetConnectionTimeout() {
      var _this11 = this;

      if (this._timeoutID) window.clearTimeout(this._timeoutID);
      this._timeoutID = window.setTimeout(function () {
        return _this11._ble.handleDisconnectError(BLEDataStoppedError);
      }, BLETimeout);
    }
    /**
     * Return whether the pin value is high.
     * @param {number} pin - the pin to check.
     * @return {boolean} - whether the pin is high or not.
     */

  }, {
    key: "isPinHigh",
    value: function isPinHigh(pin) {
      var level = this.readDigitalLevel(pin);
      return level === 1;
    }
    /**
     * Read digital input from the pin.
     * @param {number} pin - the pin to read.
     * @return {number} - digital input value of the pin [0|1].
     */

  }, {
    key: "readDigitalLevel",
    value: function readDigitalLevel(pin) {
      if (!this.isConnected()) {
        return 0;
      }

      return this.digitalLevel[pin];
    }
    /**
     * Return whether the button is pressed.
     * @param {string} buttonName - name of the button
     * @return {boolean} - true when it is pressed
     */

  }, {
    key: "isButtonPressed",
    value: function isButtonPressed(buttonName) {
      if (!this.isConnected()) {
        return false;
      }

      return this.buttonState[buttonName] === 1;
    }
    /**
     * Return whether the pin is touch-mode.
     * @param {number} pinIndex - indesx of the pin
     * @return {boolean} - true when it is touch-mode
     */

  }, {
    key: "isPinTouchMode",
    value: function isPinTouchMode(pinIndex) {
      return this.config.pinMode[pinIndex] === MbitMorePinMode.TOUCH;
    }
    /**
     * Configurate touch mode of the pin.
     * @param {number} pinIndex - index of the pin as a button.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} - a Promise that resolves when configured or undefined if the process was yield.
     */

  }, {
    key: "configTouchPin",
    value: function configTouchPin(pinIndex, util) {
      var _this12 = this;

      if (!this.isConnected()) {
        return Promise.resolve();
      }

      if (this.isPinTouchMode(pinIndex)) {
        return Promise.resolve();
      }

      var sendPromise = this.sendCommandSet([{
        id: BLECommand.CMD_CONFIG << 5 | MbitMoreConfig.TOUCH,
        message: new Uint8Array([pinIndex, 1])
      }], util);

      if (sendPromise) {
        return sendPromise.then(function () {
          _this12.config.pinMode[pinIndex] = MbitMorePinMode.TOUCH;
        });
      }

      return;
    }
    /**
     * Return whether the touche-pin is touched.
     * @param {string} buttonName - ID to check.
     * @return {boolean} - whether the id is high or not.
     */

  }, {
    key: "isTouched",
    value: function isTouched(buttonName) {
      if (!this.isConnected()) {
        return false;
      }

      return this.buttonState[buttonName] === 1;
    }
    /**
     * Return the last timestamp of the button event or undefined if the event is not received.
     * @param {MbitMoreButtonName} buttonName - name of the button to get the event.
     * @param {MbitMoreButtonEventName} eventName - name of event to get.
     * @return {?number} Timestamp of the last event or null.
     */

  }, {
    key: "getButtonEventTimestamp",
    value: function getButtonEventTimestamp(buttonName, eventName) {
      if (this.buttonEvents[buttonName] && this.buttonEvents[buttonName][eventName]) {
        return this.buttonEvents[buttonName][eventName];
      }

      return null;
    }
    /**
     * Return the last timestamp of the gesture event or undefined if the event is not received.
     * @param {MbitMoreGestureName} gestureName - name of the event.
     * @return {?number} Timestamp of the last event or null.
     */

  }, {
    key: "getGestureEventTimestamp",
    value: function getGestureEventTimestamp(gestureName) {
      if (this.gestureEvents[gestureName]) {
        return this.gestureEvents[gestureName];
      }

      return null;
    }
    /**
     * Return the last value of the pin event or undefined if the event was not received.
     * @param {number} pinIndex - index of the pin to get the event.
     * @param {MbitMorePinEvent} event - event to get.
     * @return {?number} Timestamp of the last event or null.
     */

  }, {
    key: "getPinEventValue",
    value: function getPinEventValue(pinIndex, event) {
      if (this._pinEvents[pinIndex] && this._pinEvents[pinIndex][event]) {
        return this._pinEvents[pinIndex][event].value;
      }

      return null;
    }
    /**
     * Return the last timestamp of the pin event or undefined if the event was not received.
     * @param {number} pinIndex - index of the pin to get the event.
     * @param {MbitMorePinEvent} event - event to get.
     * @return {?number} Timestamp of the last event or null.
     */

  }, {
    key: "getPinEventTimestamp",
    value: function getPinEventTimestamp(pinIndex, event) {
      if (this._pinEvents[pinIndex] && this._pinEvents[pinIndex][event]) {
        return this._pinEvents[pinIndex][event].timestamp;
      }

      return null;
    }
    /**
     * Set event type to be get from the pin.
     * @param {number} pinIndex - Index of the pin to set.
     * @param {MbitMorePinEventType} eventType - Event type to set.
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */

  }, {
    key: "listenPinEventType",
    value: function listenPinEventType(pinIndex, eventType, util) {
      return this.sendCommandSet([{
        id: BLECommand.CMD_PIN << 5 | MbitMorePinCommand.SET_EVENT,
        message: new Uint8Array([pinIndex, eventType])
      }], util);
    }
    /**
     * Send data to micro:bit.
     * @param {string} label - label of the data [ascii]
     * @param {string} content - content of the data [ascii | number]
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when sending done or undefined if this process was yield.
     */

  }, {
    key: "sendData",
    value: function sendData(label, content, util) {
      var labelData = new Array(8).fill().map(function (_value, index) {
        return label.charCodeAt(index);
      });
      var contentNumber = Number(content);
      var contentData;
      var type;

      if (Number.isNaN(contentNumber)) {
        type = MbitMoreSendingDataType.TEXT;
        contentData = content.split('').map(function (ascii) {
          return ascii.charCodeAt(0);
        }).slice(0, 11);
      } else {
        type = MbitMoreSendingDataType.NUMBER;
        var dataView = new DataView(new ArrayBuffer(4));
        dataView.setFloat32(0, contentNumber, true);
        contentData = [dataView.getUint8(0), dataView.getUint8(1), dataView.getUint8(2), dataView.getUint8(3)];
      }

      return this.sendCommandSet([{
        id: BLECommand.CMD_DATA << 5 | type,
        message: new Uint8Array([].concat(_toConsumableArray(labelData), _toConsumableArray(contentData)))
      }], util);
    }
    /**
     * Return the last data with the label or undefined if no data received with the label.
     * @param {string} label - label to get.
     * @return {?(number | string)} data of the label or null.
     */

  }, {
    key: "getDataLabeled",
    value: function getDataLabeled(label) {
      if (this.receivedData[label]) {
        return this.receivedData[label].content;
      }

      return null;
    }
    /**
     * Return the last timestamp of the data or undefined if the data is not received.
     * @param {string} label - label of the data.
     * @return {?number} Timestamp of the last data or null.
     */

  }, {
    key: "getDataTimestamp",
    value: function getDataTimestamp(label) {
      if (this.receivedData[label]) {
        return this.receivedData[label].timestamp;
      }

      return null;
    }
  }]);

  return MbitMore;
}();
/**
 * Scratch 3.0 blocks to interact with a MicroBit peripheral.
 */


var MbitMoreBlocks = /*#__PURE__*/function () {
  /**
   * Construct a set of MicroBit blocks.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */
  function MbitMoreBlocks(runtime) {
    _classCallCheck(this, MbitMoreBlocks);

    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime;

    if (runtime.formatMessage) {
      // Replace 'formatMessage' to a formatter which is used in the runtime.
      formatMessage = runtime.formatMessage;
    } // Create a new MicroBit peripheral instance


    this._peripheral = new MbitMore(this.runtime, MbitMoreBlocks.EXTENSION_ID);
    /**
     * The previous timestamps of button events.
     * @type {Object.<number, Object.<number, number>>} button ID to object with event and timestamp.
     */

    this.prevButtonEvents = {};
    /**
     * The previous timestamps of gesture events.
     * @type {Object.<number, number>} key: event ID, value: timestamp.
     */

    this.prevGestureEvents = {};
    /**
     * The previous timestamps of pin events.
     * @type {Object.<number, Object.<number, number>>} pin index to object with event and timestamp.
     */

    this.prevPinEvents = {};
    /**
     * The previous timestamps of messages.
     * @type {Object.<number, Object>} pin index to object with event and timestamp.
     */

    this.prevReceivedData = {};
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  _createClass(MbitMoreBlocks, [{
    key: "GESTURES_MENU",
    get:
    /**
     * @return {array} - text and values for each gestures menu element
     */
    function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.tiltUp',
          default: 'titl up',
          description: 'label for tilt up gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.TILT_UP
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.tiltDown',
          default: 'titl down',
          description: 'label for tilt down gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.TILT_DOWN
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.tiltLeft',
          default: 'titl left',
          description: 'label for tilt left gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.TILT_LEFT
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.tiltRight',
          default: 'titl right',
          description: 'label for tilt right gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.TILT_RIGHT
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.faceUp',
          default: 'face up',
          description: 'label for face up gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.FACE_UP
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.faceDown',
          default: 'face down',
          description: 'label for face down gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.FACE_DOWN
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.freefall',
          default: 'freefall',
          description: 'label for freefall gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.FREEFALL
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.g3',
          default: '3G',
          description: 'label for 3G gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.G3
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.g6',
          default: '6G',
          description: 'label for 6G gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.G6
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.g8',
          default: '8G',
          description: 'label for 3G gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.G8
      }, {
        text: formatMessage({
          id: 'mbitMore.gesturesMenu.shake',
          default: 'shake',
          description: 'label for shaken gesture in gesture picker for Boson extension'
        }),
        value: MbitMoreGestureName.SHAKE
      }];
    }
    /**
     * @return {array} - text and values for each buttons menu element
     */

  }, {
    key: "BUTTON_ID_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.buttonIDMenu.a',
          default: 'A',
          description: 'label for "A" element in button picker for Boson extension'
        }),
        value: MbitMoreButtonName.A
      }, {
        text: formatMessage({
          id: 'mbitMore.buttonIDMenu.b',
          default: 'B',
          description: 'label for "B" element in button picker for Boson extension'
        }),
        value: MbitMoreButtonName.B
      }];
    }
    /**
     * @return {array} - Menu items for button event selector.
     */

  }, {
    key: "BUTTON_EVENT_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.buttonEventMenu.down',
          default: 'down',
          description: 'label for button down event'
        }),
        value: MbitMoreButtonEventName.DOWN
      }, {
        text: formatMessage({
          id: 'mbitMore.buttonEventMenu.up',
          default: 'up',
          description: 'label for button up event'
        }),
        value: MbitMoreButtonEventName.UP
      }, {
        text: formatMessage({
          id: 'mbitMore.buttonEventMenu.click',
          default: 'click',
          description: 'label for button click event'
        }),
        value: MbitMoreButtonEventName.CLICK // },
        // // These events are not in use because they are unstable in coal-microbit-v2.
        // {
        //     text: formatMessage({
        //         id: 'mbitMore.buttonEventMenu.hold',
        //         default: 'hold',
        //         description: 'label for button hold event'
        //     }),
        //     value: MbitMoreButtonEventName.HOLD
        // },
        // {
        //     text: formatMessage({
        //         id: 'mbitMore.buttonEventMenu.longClick',
        //         default: 'long click',
        //         description: 'label for button long click event'
        //     }),
        //     value: MbitMoreButtonEventName.LONG_CLICK
        // },
        // {
        //     text: formatMessage({
        //         id: 'mbitMore.buttonEventMenu.doubleClick',
        //         default: 'double click',
        //         description: 'label for button double click event'
        //     }),
        //     value: MbitMoreButtonEventName.DOUBLE_CLICK

      }];
    }
    /**
     * @return {array} - text and values for each buttons menu element
     */

  }, {
    key: "TOUCH_ID_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.touchIDMenu.logo',
          default: 'LOGO',
          description: 'label for "LOGO" element in touch button picker for Boson extension'
        }),
        value: MbitMoreButtonName.LOGO
      }, {
        text: 'P0',
        value: MbitMoreButtonName.P0
      }, {
        text: 'P1',
        value: MbitMoreButtonName.P1
      }, {
        text: 'P2',
        value: MbitMoreButtonName.P2
      }];
    }
    /**
     * @return {array} - Menu items for touch event selector.
     */

  }, {
    key: "TOUCH_EVENT_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.touchEventMenu.touched',
          default: 'touched',
          description: 'label for touched event'
        }),
        value: MbitMoreButtonEventName.DOWN
      }, {
        text: formatMessage({
          id: 'mbitMore.touchEventMenu.released',
          default: 'released',
          description: 'label for released event'
        }),
        value: MbitMoreButtonEventName.UP
      }, {
        text: formatMessage({
          id: 'mbitMore.touchEventMenu.tapped',
          default: 'tapped',
          description: 'label for tapped event'
        }),
        value: MbitMoreButtonEventName.CLICK // },
        // // These events are not in use because they are unstable in coal-microbit-v2.
        // {
        //     text: formatMessage({
        //         id: 'mbitMore.touchEventMenu.hold',
        //         default: 'hold',
        //         description: 'label for hold event in touch'
        //     }),
        //     value: MbitMoreButtonEventName.HOLD
        // },
        // {
        //     text: formatMessage({
        //         id: 'mbitMore.touchEventMenu.longTapped',
        //         default: 'long tapped',
        //         description: 'label for long click event in touch'
        //     }),
        //     value: MbitMoreButtonEventName.LONG_CLICK
        // },
        // {
        //     text: formatMessage({
        //         id: 'mbitMore.touchEventMenu.doubleTapped',
        //         default: 'double tapped',
        //         description: 'label for double click event in touch'
        //     }),
        //     value: MbitMoreButtonEventName.DOUBLE_CLICK

      }];
    }
  }, {
    key: "ANALOG_IN_PINS_MENU",
    get: function get() {
      return this._peripheral.analogIn.map(function (pinIndex) {
        return Object.create({
          text: "P".concat(pinIndex.toString()),
          value: pinIndex.toString()
        });
      });
    }
  }, {
    key: "GPIO_MENU",
    get: function get() {
      return this._peripheral.gpio.map(function (pinIndex) {
        return Object.create({
          text: "P".concat(pinIndex.toString()),
          value: pinIndex.toString()
        });
      });
    }
  }, {
    key: "DIGITAL_VALUE_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.digitalValueMenu.Low',
          default: 'Low',
          description: 'label for low value in digital output menu for Boson extension'
        }),
        value: 'false'
      }, {
        text: formatMessage({
          id: 'mbitMore.digitalValueMenu.High',
          default: 'High',
          description: 'label for high value in digital output menu for Boson extension'
        }),
        value: 'true'
      }];
    }
  }, {
    key: "AXIS_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.axisMenu.x',
          default: 'x',
          description: 'label of X axis.'
        }),
        value: AxisSymbol.X
      }, {
        text: formatMessage({
          id: 'mbitMore.axisMenu.y',
          default: 'y',
          description: 'label of Y axis.'
        }),
        value: AxisSymbol.Y
      }, {
        text: formatMessage({
          id: 'mbitMore.axisMenu.z',
          default: 'z',
          description: 'label of Z axis.'
        }),
        value: AxisSymbol.Z
      }, {
        text: formatMessage({
          id: 'mbitMore.axisMenu.absolute',
          default: 'absolute',
          description: 'label of absolute value.'
        }),
        value: AxisSymbol.Absolute
      }];
    }
    /**
     * @return {array} - text and values for each pin mode menu element
     */

  }, {
    key: "PIN_MODE_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.pinModeMenu.pullNone',
          default: 'pull none',
          description: 'label for pullNone mode'
        }),
        value: MbitMorePullModeName.NONE
      }, {
        text: formatMessage({
          id: 'mbitMore.pinModeMenu.pullUp',
          default: 'pull up',
          description: 'label for pullUp mode'
        }),
        value: MbitMorePullModeName.UP
      }, {
        text: formatMessage({
          id: 'mbitMore.pinModeMenu.pullDown',
          default: 'pull down',
          description: 'label for pullDown mode'
        }),
        value: MbitMorePullModeName.DOWN
      }];
    }
    /**
     * @return {array} - Menu items for event selector.
     */

  }, {
    key: "PIN_EVENT_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.pinEventMenu.pulseLow',
          default: 'low pulse',
          description: 'label for low pulse event'
        }),
        value: 'PULSE_LOW'
      }, {
        text: formatMessage({
          id: 'mbitMore.pinEventMenu.pulseHigh',
          default: 'high pulse',
          description: 'label for high pulse event'
        }),
        value: 'PULSE_HIGH'
      }, {
        text: formatMessage({
          id: 'mbitMore.pinEventMenu.fall',
          default: 'fall',
          description: 'label for fall event'
        }),
        value: 'FALL'
      }, {
        text: formatMessage({
          id: 'mbitMore.pinEventMenu.rise',
          default: 'rise',
          description: 'label for rise event'
        }),
        value: 'RISE'
      }];
    }
    /**
     * @return {array} - Menu items for event selector.
     */

  }, {
    key: "PIN_EVENT_TIMESTAMP_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.pinEventTimestampMenu.pulseLow',
          default: 'low pulse',
          description: 'label for low pulse event'
        }),
        value: 'PULSE_LOW'
      }, {
        text: formatMessage({
          id: 'mbitMore.pinEventTimestampMenu.pulseHigh',
          default: 'high pulse',
          description: 'label for high pulse event'
        }),
        value: 'PULSE_HIGH'
      }, {
        text: formatMessage({
          id: 'mbitMore.pinEventTimestampMenu.fall',
          default: 'fall',
          description: 'label for fall event'
        }),
        value: 'FALL'
      }, {
        text: formatMessage({
          id: 'mbitMore.pinEventTimestampMenu.rise',
          default: 'rise',
          description: 'label for rise event'
        }),
        value: 'RISE'
      }];
    }
    /**
     * @return {array} - Menu items for event listening.
     */

  }, {
    key: "PIN_EVENT_TYPE_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.pinEventTypeMenu.none',
          default: 'none',
          description: 'label for remove event listener'
        }),
        value: 'NONE'
      }, {
        text: formatMessage({
          id: 'mbitMore.pinEventTypeMenu.pulse',
          default: 'pulse',
          description: 'label for pulse event type'
        }),
        value: 'ON_PULSE'
      }, {
        text: formatMessage({
          id: 'mbitMore.pinEventTypeMenu.edge',
          default: 'edge',
          description: 'label for edge event type'
        }),
        value: 'ON_EDGE'
      }];
    }
    /**
     * @return {array} - Menu items for connection state.
     */

  }, {
    key: "CONNECTION_STATE_MENU",
    get: function get() {
      return [{
        text: formatMessage({
          id: 'mbitMore.connectionStateMenu.connected',
          default: 'connected',
          description: 'label for connected'
        }),
        value: 'connected'
      }, {
        text: formatMessage({
          id: 'mbitMore.connectionStateMenu.disconnected',
          default: 'disconnected',
          description: 'label for disconnected'
        }),
        value: 'disconnected'
      }];
    }
  }, {
    key: "getInfo",
    value: function getInfo() {
      setupTranslations();
      return {
        id: MbitMoreBlocks.EXTENSION_ID,
        name: MbitMoreBlocks.EXTENSION_NAME,
        extensionURL: MbitMoreBlocks.extensionURL,
        blockIconURI: img,
        showStatusButton: true,
        blocks: [{
          opcode: 'whenConnectionChanged',
          text: formatMessage({
            id: 'mbitMore.whenConnectionChanged',
            default: 'when micro:bit [STATE]',
            description: 'when a micro:bit connection state changed'
          }),
          blockType: blockType.HAT,
          arguments: {
            STATE: {
              type: argumentType.STRING,
              menu: 'connectionStateMenu',
              defaultValue: 'connected'
            }
          }
        }, '---', {
          opcode: 'whenButtonEvent',
          text: formatMessage({
            id: 'mbitMore.whenButtonEvent',
            default: 'when button [NAME] is [EVENT]',
            description: 'when the selected button on the micro:bit get the selected event'
          }),
          blockType: blockType.HAT,
          arguments: {
            NAME: {
              type: argumentType.STRING,
              menu: 'buttonIDMenu',
              defaultValue: MbitMoreButtonName.A
            },
            EVENT: {
              type: argumentType.STRING,
              menu: 'buttonEventMenu',
              defaultValue: MbitMoreButtonEventName.DOWN
            }
          }
        }, {
          opcode: 'isButtonPressed',
          text: formatMessage({
            id: 'mbitMore.isButtonPressed',
            default: 'button [NAME] pressed?',
            description: 'is the selected button on the micro:bit pressed?'
          }),
          blockType: blockType.BOOLEAN,
          arguments: {
            NAME: {
              type: argumentType.STRING,
              menu: 'buttonIDMenu',
              defaultValue: MbitMoreButtonName.A
            }
          }
        }, {
          opcode: 'whenTouchEvent',
          text: formatMessage({
            id: 'mbitMore.whenTouchEvent',
            default: 'when pin [NAME] is [EVENT]',
            description: 'when the selected touch pin on the micro:bit is touched'
          }),
          blockType: blockType.HAT,
          arguments: {
            NAME: {
              type: argumentType.STRING,
              menu: 'touchIDMenu',
              defaultValue: MbitMoreButtonName.LOGO
            },
            EVENT: {
              type: argumentType.STRING,
              menu: 'touchEventMenu',
              defaultValue: MbitMoreButtonEventName.DOWN
            }
          }
        }, {
          opcode: 'isPinTouched',
          text: formatMessage({
            id: 'mbitMore.isPinTouched',
            default: 'pin [NAME] is touched?',
            description: 'is the selected pin is touched?'
          }),
          blockType: blockType.BOOLEAN,
          arguments: {
            NAME: {
              type: argumentType.STRING,
              menu: 'touchIDMenu',
              defaultValue: MbitMoreButtonName.LOGO
            }
          }
        }, '---', {
          opcode: 'whenGesture',
          text: formatMessage({
            id: 'mbitMore.whenGesture',
            default: 'when [GESTURE]',
            description: 'when the selected gesture is detected by the micro:bit'
          }),
          blockType: blockType.HAT,
          arguments: {
            GESTURE: {
              type: argumentType.STRING,
              menu: 'gestures',
              defaultValue: MbitMoreGestureName.SHAKE
            }
          }
        }, '---', {
          opcode: 'displayMatrix',
          text: formatMessage({
            id: 'mbitMore.displayMatrix',
            default: 'display pattern [MATRIX] ',
            description: 'display a pattern on the micro:bit display'
          }),
          blockType: blockType.COMMAND,
          arguments: {
            MATRIX: {
              type: argumentType.MATRIX,
              defaultValue: '0101010101100010101000100'
            }
          }
        }, {
          opcode: 'displayText',
          text: formatMessage({
            id: 'mbitMore.displayText',
            default: 'display text [TEXT] delay [DELAY] ms',
            description: 'display text on the micro:bit display'
          }),
          blockType: blockType.COMMAND,
          arguments: {
            TEXT: {
              type: argumentType.STRING,
              defaultValue: 'Hello!'
            },
            DELAY: {
              type: argumentType.NUMBER,
              defaultValue: 120
            }
          }
        }, {
          opcode: 'displayClear',
          text: formatMessage({
            id: 'mbitMore.clearDisplay',
            default: 'clear display',
            description: 'display nothing on the micro:bit display'
          }),
          blockType: blockType.COMMAND
        }, '---', {
          opcode: 'getLightLevel',
          text: formatMessage({
            id: 'mbitMore.lightLevel',
            default: 'light intensity',
            description: 'how much the amount of light falling on the LEDs on micro:bit'
          }),
          blockType: blockType.REPORTER
        }, {
          opcode: 'getTemperature',
          text: formatMessage({
            id: 'mbitMore.temperature',
            default: 'temperature',
            description: 'temperature (celsius) on the surface of CPU of micro:bit'
          }),
          blockType: blockType.REPORTER
        }, {
          opcode: 'getCompassHeading',
          text: formatMessage({
            id: 'mbitMore.compassHeading',
            default: 'angle with the North',
            description: 'angle from the North to the micro:bit heading direction'
          }),
          blockType: blockType.REPORTER
        }, {
          opcode: 'getPitch',
          text: formatMessage({
            id: 'mbitMore.pitch',
            default: 'pitch',
            description: 'nose up movement of the micro:bit from level'
          }),
          blockType: blockType.REPORTER
        }, {
          opcode: 'getRoll',
          text: formatMessage({
            id: 'mbitMore.roll',
            default: 'roll',
            description: 'clockwise circular movement of the micro:bit from level'
          }),
          blockType: blockType.REPORTER
        }, {
          opcode: 'getSoundLevel',
          text: formatMessage({
            id: 'mbitMore.soundLevel',
            default: 'sound level',
            description: 'level of the sound from microphone on micro:bit'
          }),
          blockType: blockType.REPORTER
        }, {
          opcode: 'getMagneticForce',
          text: formatMessage({
            id: 'mbitMore.magneticForce',
            default: 'magnetic force',
            description: 'value of magnetic force (micro tesla)'
          }),
          blockType: blockType.REPORTER,
          arguments: {
            AXIS: {
              type: argumentType.STRING,
              menu: 'axis',
              defaultValue: AxisSymbol.Absolute
            }
          }
        }, {
          opcode: 'getAcceleration',
          text: formatMessage({
            id: 'mbitMore.acceleration',
            default: 'acceleration [AXIS]',
            description: 'value of acceleration on the axis (milli-g)'
          }),
          blockType: blockType.REPORTER,
          arguments: {
            AXIS: {
              type: argumentType.STRING,
              menu: 'axis',
              defaultValue: AxisSymbol.X
            }
          }
        }, '---', {
          opcode: 'getAnalogValue',
          text: formatMessage({
            id: 'mbitMore.analogValue',
            default: 'analog value of pin [PIN]',
            description: 'analog input value of the pin'
          }),
          blockType: blockType.REPORTER,
          arguments: {
            PIN: {
              type: argumentType.STRING,
              menu: 'analogInPins',
              defaultValue: '0'
            }
          }
        }, {
          opcode: 'setPullMode',
          text: formatMessage({
            id: 'mbitMore.setPullMode',
            default: 'set pin [PIN] to input [MODE]',
            description: 'set a pin into the mode'
          }),
          blockType: blockType.COMMAND,
          arguments: {
            PIN: {
              type: argumentType.STRING,
              menu: 'gpio',
              defaultValue: '0'
            },
            MODE: {
              type: argumentType.STRING,
              menu: 'pinMode',
              defaultValue: MbitMorePullModeName.UP
            }
          }
        }, {
          opcode: 'isPinHigh',
          text: formatMessage({
            id: 'mbitMore.isPinHigh',
            default: '[PIN] pin is high?',
            description: 'is the selected pin high as digital?'
          }),
          blockType: blockType.BOOLEAN,
          arguments: {
            PIN: {
              type: argumentType.STRING,
              menu: 'gpio',
              defaultValue: '0'
            }
          }
        }, '---', {
          opcode: 'setDigitalOut',
          text: formatMessage({
            id: 'mbitMore.setDigitalOut',
            default: 'set [PIN] Digital [LEVEL]',
            description: 'set pin to Digtal Output mode and the level(true = High)'
          }),
          blockType: blockType.COMMAND,
          arguments: {
            PIN: {
              type: argumentType.STRING,
              menu: 'gpio',
              defaultValue: '0'
            },
            LEVEL: {
              type: argumentType.STRING,
              menu: 'digitalValueMenu',
              defaultValue: 'false'
            }
          }
        }, {
          opcode: 'setAnalogOut',
          text: formatMessage({
            id: 'mbitMore.setAnalogOut',
            default: 'set [PIN] analog [LEVEL] %',
            description: 'set pin to PWM mode and the level(0 to 1023)'
          }),
          blockType: blockType.COMMAND,
          arguments: {
            PIN: {
              type: argumentType.STRING,
              menu: 'gpio',
              defaultValue: '0'
            },
            LEVEL: {
              type: argumentType.NUMBER,
              defaultValue: 0
            }
          }
        }, {
          opcode: 'setServo',
          text: formatMessage({
            id: 'mbitMore.setServo',
            default: 'set [PIN] Servo [ANGLE]',
            description: 'set pin to Servo mode and the angle(0 to 180)'
          }),
          blockType: blockType.COMMAND,
          arguments: {
            PIN: {
              type: argumentType.STRING,
              menu: 'gpio',
              defaultValue: '0'
            },
            ANGLE: {
              type: argumentType.NUMBER,
              defaultValue: 0
            },
            RANGE: {
              type: argumentType.NUMBER,
              defaultValue: 2000
            },
            CENTER: {
              type: argumentType.NUMBER,
              defaultValue: 1500
            }
          }
        }, {
          opcode: 'playTone',
          text: formatMessage({
            id: 'mbitMore.playTone',
            default: 'play tone [FREQ] Hz volume [VOL] %',
            description: 'play tone on the speaker'
          }),
          blockType: blockType.COMMAND,
          arguments: {
            FREQ: {
              type: argumentType.NUMBER,
              defaultValue: 440
            },
            VOL: {
              type: argumentType.NUMBER,
              defaultValue: 100
            }
          }
        }, {
          opcode: 'stopTone',
          text: formatMessage({
            id: 'mbitMore.stopTone',
            default: 'stop tone',
            description: 'stop tone on the speaker'
          }),
          blockType: blockType.COMMAND
        }, '---', {
          opcode: 'listenPinEventType',
          text: formatMessage({
            id: 'mbitMore.listenPinEventType',
            default: 'catch event [EVENT_TYPE] on [PIN]',
            description: 'listen the event on the pin'
          }),
          blockType: blockType.COMMAND,
          arguments: {
            EVENT_TYPE: {
              type: argumentType.STRING,
              menu: 'pinEventTypeMenu',
              defaultValue: 'NONE'
            },
            PIN: {
              type: argumentType.STRING,
              menu: 'gpio',
              defaultValue: '0'
            }
          }
        }, {
          opcode: 'whenPinEvent',
          text: formatMessage({
            id: 'mbitMore.whenPinEvent',
            default: 'when catch [EVENT] at pin [PIN]',
            description: 'when catch the event at the pin'
          }),
          blockType: blockType.HAT,
          arguments: {
            EVENT: {
              type: argumentType.STRING,
              menu: 'pinEventMenu',
              defaultValue: 'PULSE_LOW'
            },
            PIN: {
              type: argumentType.STRING,
              menu: 'gpio',
              defaultValue: '0'
            }
          }
        }, {
          opcode: 'getPinEventValue',
          text: formatMessage({
            id: 'mbitMore.getPinEventValue',
            default: 'value of [EVENT] at [PIN]',
            description: 'value of the value of the event (timestamp of the edge or duration of the pulse)'
          }),
          blockType: blockType.REPORTER,
          arguments: {
            EVENT: {
              type: argumentType.STRING,
              menu: 'pinEventTimestampMenu',
              defaultValue: 'PULSE_LOW'
            },
            PIN: {
              type: argumentType.STRING,
              menu: 'gpio',
              defaultValue: '0'
            }
          }
        }, '---', {
          opcode: 'whenDataReceived',
          text: formatMessage({
            id: 'mbitMore.whenDataReceived',
            default: 'when data with loabel [LABEL] received from micro:bit',
            description: 'when the data which has the label received'
          }),
          blockType: blockType.HAT,
          arguments: {
            LABEL: {
              type: argumentType.STRING,
              defaultValue: 'label-01'
            }
          }
        }, {
          opcode: 'getDataLabeled',
          text: formatMessage({
            id: 'mbitMore.getDataLabeled',
            default: 'data of label [LABEL]',
            description: 'the last data which has the label'
          }),
          blockType: blockType.REPORTER,
          arguments: {
            LABEL: {
              type: argumentType.STRING,
              defaultValue: 'label-01'
            }
          }
        }, {
          opcode: 'sendData',
          text: formatMessage({
            id: 'mbitMore.sendData',
            default: 'send data [DATA] with label [LABEL] to micro:bit',
            description: 'send data content with label to micro:bit'
          }),
          blockType: blockType.COMMAND,
          arguments: {
            LABEL: {
              type: argumentType.STRING,
              defaultValue: 'label-01'
            },
            DATA: {
              type: argumentType.STRING,
              defaultValue: 'data'
            }
          }
        }],
        menus: {
          buttonIDMenu: {
            acceptReporters: false,
            items: this.BUTTON_ID_MENU
          },
          buttonEventMenu: {
            acceptReporters: false,
            items: this.BUTTON_EVENT_MENU
          },
          touchIDMenu: {
            acceptReporters: false,
            items: this.TOUCH_ID_MENU
          },
          touchEventMenu: {
            acceptReporters: false,
            items: this.TOUCH_EVENT_MENU
          },
          gestures: {
            acceptReporters: false,
            items: this.GESTURES_MENU
          },
          analogInPins: {
            acceptReporters: false,
            items: this.ANALOG_IN_PINS_MENU
          },
          digitalValueMenu: {
            acceptReporters: true,
            items: this.DIGITAL_VALUE_MENU
          },
          gpio: {
            acceptReporters: false,
            items: this.GPIO_MENU
          },
          axis: {
            acceptReporters: false,
            items: this.AXIS_MENU
          },
          pinMode: {
            acceptReporters: false,
            items: this.PIN_MODE_MENU
          },
          pinEventTypeMenu: {
            acceptReporters: false,
            items: this.PIN_EVENT_TYPE_MENU
          },
          pinEventMenu: {
            acceptReporters: false,
            items: this.PIN_EVENT_MENU
          },
          pinEventTimestampMenu: {
            acceptReporters: false,
            items: this.PIN_EVENT_TIMESTAMP_MENU
          },
          connectionStateMenu: {
            acceptReporters: false,
            items: this.CONNECTION_STATE_MENU
          }
        },
        translationMap: translations
      };
    }
    /**
     * Update the previous occured time of all button events.
     */

  }, {
    key: "updatePrevButtonEvents",
    value: function updatePrevButtonEvents() {
      var _this13 = this;

      this.prevButtonEvents = {};
      Object.entries(this._peripheral.buttonEvents).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            componentID = _ref2[0],
            events = _ref2[1];

        _this13.prevButtonEvents[componentID] = {};
        Object.entries(events).forEach(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
              eventName = _ref4[0],
              timestamp = _ref4[1];

          _this13.prevButtonEvents[componentID][eventName] = timestamp;
        });
      });
    }
    /**
     * Test whether the event raised at the button.
     * @param {object} args - the block's arguments.
     * @param {string} args.NAME - name of the button.
     * @param {string} args.EVENT - name of event to catch.
     * @return {boolean} - true if the event raised.
     */

  }, {
    key: "whenButtonEvent",
    value: function whenButtonEvent(args) {
      var _this14 = this;

      if (!this.updateLastButtonEventTimer) {
        this.updateLastButtonEventTimer = setTimeout(function () {
          _this14.updatePrevButtonEvents();

          _this14.updateLastButtonEventTimer = null;
        }, this.runtime.currentStepTime);
      }

      var buttonName = args.NAME;
      var eventName = args.EVENT;

      var lastTimestamp = this._peripheral.getButtonEventTimestamp(buttonName, eventName);

      if (lastTimestamp === null) return false;
      if (!this.prevButtonEvents[buttonName]) return true;
      return lastTimestamp !== this.prevButtonEvents[buttonName][eventName];
    }
    /**
     * Test whether the A or B button is pressed
     * @param {object} args - the block's arguments.
     * @param {string} args.NAME - name of the button.
     * @param {object} util - utility object provided by the runtime.
     * @return {boolean} - whether the button is pressed or not.
     */

  }, {
    key: "isButtonPressed",
    value: function isButtonPressed(args) {
      var buttonName = args.NAME;
      return this._peripheral.isButtonPressed(buttonName);
    }
    /**
     * Test whether the touch event raised at the pin.
     * @param {object} args - the block's arguments.
     * @param {string} args.NAME - name of the pin to catch.
     * @param {string} args.EVENT - event to catch.
     * @param {object} util - utility object provided by the runtime.
     * @return {boolean|Promise<boolean>|undefined} - true if the event raised or promise that or undefinde if yield.
     */

  }, {
    key: "whenTouchEvent",
    value: function whenTouchEvent(args, util) {
      var _this15 = this;

      var buttonName = args.NAME;

      if (buttonName === MbitMoreButtonName.LOGO) {
        return this.whenButtonEvent(args);
      }

      if (this._peripheral.isPinTouchMode(MbitMoreButtonPinIndex[buttonName])) {
        return this.whenButtonEvent(args);
      }

      var configPromise = this._peripheral.configTouchPin(MbitMoreButtonPinIndex[buttonName], util);

      if (!configPromise) return; // This thread was yielded.

      return configPromise.then(function () {
        return _this15.whenButtonEvent(args);
      });
    }
    /**
     * Test whether the touch-pin is touched.
     * @param {object} args - the block's arguments.
     * @param {string} args.NAME - name of the pin.
     * @param {object} util - utility object provided by the runtime.
     * @return {boolean|Promise<boolean>|undefined} - true if touched or promise that or undefinde if yield.
     */

  }, {
    key: "isPinTouched",
    value: function isPinTouched(args, util) {
      var _this16 = this;

      var buttonName = args.NAME;

      if (buttonName === MbitMoreButtonName.LOGO) {
        return this._peripheral.isTouched(buttonName);
      }

      if (this._peripheral.isPinTouchMode(MbitMoreButtonPinIndex[buttonName])) {
        return this._peripheral.isTouched(buttonName);
      }

      var configPromise = this._peripheral.configTouchPin(MbitMoreButtonPinIndex[buttonName], util);

      if (!configPromise) return; // This thread was yielded.

      return configPromise.then(function () {
        return _this16._peripheral.isTouched(buttonName);
      });
    }
    /**
     * Update the last occured time of all gesture events.
     */

  }, {
    key: "updatePrevGestureEvents",
    value: function updatePrevGestureEvents() {
      var _this17 = this;

      this.prevGestureEvents = {};
      Object.entries(this._peripheral.gestureEvents).forEach(function (_ref5) {
        var _ref6 = _slicedToArray(_ref5, 2),
            gestureName = _ref6[0],
            timestamp = _ref6[1];

        _this17.prevGestureEvents[gestureName] = timestamp;
      });
    }
    /**
     * Test whether the gesture event raised.
     * @param {object} args - the block's arguments.
     * @param {string} args.GESTURE - name of the gesture.
     * @return {boolean} - true if the event raised.
     */

  }, {
    key: "whenGesture",
    value: function whenGesture(args) {
      var _this18 = this;

      if (!this.updateLastGestureEventTimer) {
        this.updateLastGestureEventTimer = setTimeout(function () {
          _this18.updatePrevGestureEvents();

          _this18.updateLastGestureEventTimer = null;
        }, this.runtime.currentStepTime);
      }

      var gestureName = args.GESTURE;

      var lastTimestamp = this._peripheral.getGestureEventTimestamp(gestureName);

      if (lastTimestamp === null) return false;
      if (!this.prevGestureEvents[gestureName]) return true;
      return lastTimestamp !== this.prevGestureEvents[gestureName];
    }
    /**
     * Display pixcel pattern on the 5x5 LED matrix with brightness and write mode.
     * @param {object} args - the block's arguments.
     * @param {string} args.MATRIX - the pattern of the pixels.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} - a Promise that resolves after a tick or undefinde if yield.
     */

  }, {
    key: "displayMatrix",
    value: function displayMatrix(args, util) {
      var matrixString = cast.toString(args.MATRIX).replace(/！-～/g, function (ws) {
        return String.fromCharCode(ws.charCodeAt(0) - 0xFEE0);
      }); // zenkaku to hankaku

      var matrixData;

      if (matrixString.includes(',')) {
        // comma separated values
        matrixData = matrixString.split(/[,\n]/);
      } else if (/[ \t]\d*[ \t]/g.test(matrixString)) {
        // space|tab separated values
        matrixData = matrixString.split(/\s/g);
      } else {
        // 0|1 pattern.
        matrixData = matrixString.replace(/\s/g, '').split('');
        matrixData = matrixData.map(function (level) {
          return level === '0' ? 0 : 100;
        });
      }

      matrixData = matrixData.map(function (brightness) {
        return Math.max(0, Math.min(100, Number(brightness)) * 255 / 100);
      }); // percent to 8bits value

      var matrix = [];

      for (var line = 0; line < 5; line++) {
        matrix[line] = [];

        for (var col = 0; col < 5; col++) {
          matrix[line][col] = matrixData[line * 5 + col];
        }
      }

      return this._peripheral.displayPixels(matrix, util);
    }
    /**
     * Display text on the 5x5 LED matrix.
     * Displayable character is ascii and non-ascii is replaced to '?'.
     * @param {object} args - the block's arguments.
     * @param {string} args.TEXT - The contents to display.
     * @param {number} args.DELAY - The time to delay between characters, in milliseconds.
     * @param {object} util - utility object provided by the runtime.
     * @return {Promise} - a Promise that resolves after the text is done printing or undefinde if yield.
     * Note the limit is 18 characters
     * The print time is calculated by multiplying the number of horizontal pixels
     * by the default scroll delay of 120ms.
     * The number of horizontal pixels = 6px for each character in the string,
     * 1px before the string, and 5px after the string.
     */

  }, {
    key: "displayText",
    value: function displayText(args, util) {
      var text = String(args.TEXT).replace(/！-～/g, function (zenkaku) {
        return String.fromCharCode(zenkaku.charCodeAt(0) - 0xFEE0);
      }) // zenkaku to hankaku
      .replace(/[^ -~]/g, '?');
      var delay = parseInt(args.DELAY, 10);
      delay = isNaN(delay) ? 120 : delay; // Use default delay if NaN.

      var resultPromise = this._peripheral.displayText(text, delay, util);

      if (!resultPromise) return; // This thread was yielded.

      var yieldDelay = delay * (6 * text.length + 6);
      return new Promise(function (resolve) {
        setTimeout(function () {
          resolve();
        }, yieldDelay);
      });
    }
    /**
     * Turn all 5x5 matrix LEDs off.
     * @param {object} args - the block's arguments.
     * @param {object} util - utility object provided by the runtime.
     * @return {Promise} - a Promise that resolves after a tick or undefinde if yield.
     */

  }, {
    key: "displayClear",
    value: function displayClear(args, util) {
      var matrix = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]];
      return this._peripheral.displayPixels(matrix, util);
    }
    /**
     * Test the selected pin is high as digital.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @return {boolean} - true if the pin is high.
     */

  }, {
    key: "isPinHigh",
    value: function isPinHigh(args) {
      return this._peripheral.isPinHigh(parseInt(args.PIN, 10));
    }
    /**
     * Get amount of light (0 - 255) on the LEDs.
     * @param {object} args - the block's arguments.
     * @return {number} - light level.
     */

  }, {
    key: "getLightLevel",
    value: function getLightLevel() {
      var level = this._peripheral.readLightLevel();

      return Math.round(level * 1000 / 255) / 10;
    }
    /**
     * Get temperature (integer in celsius) of micro:bit.
     * @param {object} args - the block's arguments.
     * @return {number} - value of temperature [centigrade].
     */

  }, {
    key: "getTemperature",
    value: function getTemperature() {
      return this._peripheral.readTemperature();
    }
    /**
     * Get loudness of the sound from microphone on micro:bit.
     * @param {object} args - the block's arguments.
     * @param {object} util - utility object provided by the runtime.
     * @return {Promise} - a Promise that resolves digital input value of the pin or undefinde if yield.
     */

  }, {
    key: "getSoundLevel",
    value: function getSoundLevel(args, util) {
      var _this19 = this;

      var resultPromise = this._peripheral.configMic(true, util);

      if (!resultPromise) return; // This thread was yielded.

      return resultPromise.then(function (micState) {
        if (micState) {
          return Math.round(_this19._peripheral.readSoundLevel() * 1000 / 255) / 10;
        }

        return 0;
      });
    }
    /**
     * Return angle from the north to the micro:bit heading direction.
     * @return {number} - degree of compass heading angle from the north (0 - 359 degrees).
     */

  }, {
    key: "getCompassHeading",
    value: function getCompassHeading() {
      return this._peripheral.readCompassHeading();
    }
    /**
     * Return analog value of the pin.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves analog input value of the pin or undefined if this process was yield.
     */

  }, {
    key: "getAnalogValue",
    value: function getAnalogValue(args, util) {
      var pinIndex = parseInt(args.PIN, 10);

      var resultPromise = this._peripheral.readAnalogIn(pinIndex, util);

      if (!resultPromise) return;
      return resultPromise.then(function (level) {
        return Math.round(level * 100 * 10 / 1024) / 10;
      });
    }
    /**
     * Return digital value of the pin.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @return {number} - digital input value of the pin.
     */

  }, {
    key: "getDigitalValue",
    value: function getDigitalValue(args) {
      return this._peripheral.readDigitalLevel(parseInt(args.PIN, 10));
    }
    /**
     * Send data with label.
     * @param {object} args - the block's arguments.
     * @property {string} args.LABEL - label of the data.
     * @property {string} args.DATA - content of the data.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} - a Promise that resolves when the process was done or undefined if this process was yield.
     */

  }, {
    key: "sendData",
    value: function sendData(args, util) {
      if (args.LABEL.length <= 0) {
        return;
      }

      return this._peripheral.sendData(args.LABEL, args.DATA, util);
    }
    /**
     * Set pull mode of the pin.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @param {MbitMorePullModeName} args.MODE - mode to set.
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {promise | undefined} - a Promise that resolves when the command was sent
     *                                 or undefined if this process was yield.
     */

  }, {
    key: "setPullMode",
    value: function setPullMode(args, util) {
      return this._peripheral.setPullMode(parseInt(args.PIN, 10), MbitMorePullModeID[args.MODE], util);
    }
    /**
     * Set the pin to Output mode and level.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @param {boolean | string | number} args.LEVEL - value to be set.
     * @param {object} util - utility object provided by the runtime.
     * @return {promise | undefined} - a Promise that resolves when the command was sent
     *                                 or undefined if this process was yield.
     */

  }, {
    key: "setDigitalOut",
    value: function setDigitalOut(args, util) {
      var level = args.LEVEL === true;
      level = level || args.LEVEL === 'true';

      if (!level) {
        var num = Number(args.LEVEL);

        if (!isNaN(num)) {
          level = num > 0;
        }
      }

      return this._peripheral.setPinOutput(parseInt(args.PIN, 10), level, util);
    }
    /**
     * Set the pin to PWM mode and level.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @param {number} args.LEVEL - value[%] for PWM.
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {promise | undefined} - a Promise that resolves when the command was sent
     *                                 or undefined if this process was yield.
     */

  }, {
    key: "setAnalogOut",
    value: function setAnalogOut(args, util) {
      var percent = parseInt(args.LEVEL, 10);

      if (isNaN(percent)) {
        return;
      }

      percent = Math.max(0, Math.min(percent, 100));
      var level = Math.round(percent * 1024 / 100);
      return this._peripheral.setPinPWM(parseInt(args.PIN, 10), level, util);
    }
    /**
     * Set the pin to Servo mode and angle.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {promise | undefined} - a Promise that resolves when the command was sent
     *                                 or undefined if this process was yield.
     */

  }, {
    key: "setServo",
    value: function setServo(args, util) {
      var angle = parseInt(args.ANGLE, 10);
      if (isNaN(angle)) return;
      angle = Math.max(0, angle);
      angle = Math.min(angle, 180); // let range = parseInt(args.RANGE, 10);
      // if (isNaN(range)) range = 0;
      // range = Math.max(0, range);
      // let center = parseInt(args.CENTER, 10);
      // if (isNaN(center)) range = 0;
      // center = Math.max(0, center);

      return this._peripheral.setPinServo(parseInt(args.PIN, 10), angle, null, null, util);
    }
    /**
     * Return the value of magnetic force [micro tesla] on axis.
     * @param {object} args - the block's arguments.
     * @property {AxisSymbol} AXIS - the axis (X, Y, Z, Absolute).
     * @return {number} - value of magnetic force.
     */

  }, {
    key: "getMagneticForce",
    value: function getMagneticForce(args) {
      return this._peripheral.readMagneticForce(args.AXIS);
    }
    /**
     * Return the value of acceleration on the specified axis.
     * @param {object} args - the block's arguments.
     * @param {AxisSymbol} args.AXIS - direction to get.
     * @return {number} - value of acceleration.
     */

  }, {
    key: "getAcceleration",
    value: function getAcceleration(args) {
      return this._peripheral.readAcceleration(args.AXIS);
    }
    /**
     * Return pitch [degrees] of the micro:bit heading direction.
     * @return {number} - degree of pitch.
     */

  }, {
    key: "getPitch",
    value: function getPitch() {
      return this._peripheral.readPitch();
    }
    /**
     * Read roll [degrees] of the micro:bit heading direction.
     * @return {number} - degree of roll.
     */

  }, {
    key: "getRoll",
    value: function getRoll() {
      return this._peripheral.readRoll();
    }
    /**
     * Play tone on the speaker.
     * @param {object} args - the block's arguments.
     * @param {string} args.FREQ - wave frequency to play
     * @param {string} args.VOL laudness of tone
     * @param {object} util - utility object provided by the runtime.
     * @return {promise | undefined} - a Promise that resolves when the command was sent
     *                                 or undefined if this process was yield.
     */

  }, {
    key: "playTone",
    value: function playTone(args, util) {
      var frequency = parseFloat(args.FREQ);
      var volume = parseInt(args.VOL, 10);
      volume = Math.min(100, Math.max(0, volume));
      return this._peripheral.playTone(frequency, volume, util);
    }
    /**
     * Stop playing tone on the speaker.
     * @param {object} args - the block's arguments.
     * @param {object} util - utility object provided by the runtime.
     * @return {promise | undefined} - a Promise that resolves when the command was sent
     *                                 or undefined if this process was yield.
     */

  }, {
    key: "stopTone",
    value: function stopTone(args, util) {
      return this._peripheral.stopTone(util);
    }
    /**
     * Set listening event type at the pin.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @param {string} args.EVENT_TYPE - event to listen.
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {promise | undefined} - a Promise that resolves when the command was sent
     *                                 or undefined if this process was yield.
    */

  }, {
    key: "listenPinEventType",
    value: function listenPinEventType(args, util) {
      return this._peripheral.listenPinEventType(parseInt(args.PIN, 10), MbitMorePinEventType[args.EVENT_TYPE], util);
    }
    /**
     * Rerutn value (timestamp of the edge or duration of the pulse) of the event or 0 when the event is not received.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @param {string} args.EVENT - event value to get.
     * @param {object} util - utility object provided by the runtime.
     * @return {number} - timestamp of the event or 0.
     */

  }, {
    key: "getPinEventValue",
    value: function getPinEventValue(args) {
      var value = this._peripheral.getPinEventValue(parseInt(args.PIN, 10), MbitMorePinEvent[args.EVENT]);

      return value ? value : 0;
    }
    /**
     * Update the previous occured time of all pin events.
     */

  }, {
    key: "updatePrevPinEvents",
    value: function updatePrevPinEvents() {
      var _this20 = this;

      this.prevPinEvents = {};
      Object.entries(this._peripheral._pinEvents).forEach(function (_ref7) {
        var _ref8 = _slicedToArray(_ref7, 2),
            pinIndex = _ref8[0],
            events = _ref8[1];

        _this20.prevPinEvents[pinIndex] = {};
        Object.entries(events).forEach(function (_ref9) {
          var _ref10 = _slicedToArray(_ref9, 2),
              eventID = _ref10[0],
              eventData = _ref10[1];

          _this20.prevPinEvents[pinIndex][eventID] = {};
          Object.entries(eventData).forEach(function (_ref11) {
            var _ref12 = _slicedToArray(_ref11, 2),
                key = _ref12[0],
                value = _ref12[1];

            _this20.prevPinEvents[pinIndex][eventID][key] = value;
          });
        });
      });
    }
    /**
     * Return the previous timestamp of the pin event or undefined if the event was not received.
     * @param {number} pinIndex - index of the pin to get the event.
     * @param {MbitMorePinEvent} eventID - ID of the event to get.
     * @return {?number} Timestamp of the previous event or null.
     */

  }, {
    key: "getPrevPinEventTimestamp",
    value: function getPrevPinEventTimestamp(pinIndex, eventID) {
      if (this.prevPinEvents[pinIndex] && this.prevPinEvents[pinIndex][eventID]) {
        return this.prevPinEvents[pinIndex][eventID].timestamp;
      }

      return null;
    }
    /**
     * Test whether the event raised at the pin.
     * @param {object} args - the block's arguments.
     * @param {number} args.PIN - pin ID.
     * @param {string} args.EVENT - event to catch.
     * @return {boolean} - true if the event raised.
     */

  }, {
    key: "whenPinEvent",
    value: function whenPinEvent(args) {
      var _this21 = this;

      if (!this.updateLastPinEventTimer) {
        this.updateLastPinEventTimer = setTimeout(function () {
          _this21.updatePrevPinEvents();

          _this21.updateLastPinEventTimer = null;
        }, this.runtime.currentStepTime);
      }

      var pinIndex = parseInt(args.PIN, 10);
      var eventID = MbitMorePinEvent[args.EVENT];

      var lastTimestamp = this._peripheral.getPinEventTimestamp(pinIndex, eventID);

      if (lastTimestamp === null) return false;
      var prevTimestamp = this.getPrevPinEventTimestamp(pinIndex, eventID);
      if (prevTimestamp === null) return true;
      return lastTimestamp !== prevTimestamp;
    }
    /**
     * Rerutn the last content of the messge or undefined if the data which has the label is not received.
     * @param {object} args - the block's arguments.
     * @param {number} args.LABEL - label of the data.
     * @return {?(string | number)} - content of the data or empty string when the data was null
     */

  }, {
    key: "getDataLabeled",
    value: function getDataLabeled(args) {
      var data = this._peripheral.getDataLabeled(args.LABEL);

      if (data === null) {
        return '';
      }

      return data;
    }
    /**
     * Update the previous occured time of all received data.
     */

  }, {
    key: "updatePrevReceivedData",
    value: function updatePrevReceivedData() {
      var _this22 = this;

      this.prevReceivedData = {};
      Object.entries(this._peripheral.receivedData).forEach(function (_ref13) {
        var _ref14 = _slicedToArray(_ref13, 2),
            label = _ref14[0],
            contentObject = _ref14[1];

        _this22.prevReceivedData[label] = {};
        Object.entries(contentObject).forEach(function (_ref15) {
          var _ref16 = _slicedToArray(_ref15, 2),
              key = _ref16[0],
              value = _ref16[1];

          _this22.prevReceivedData[label][key] = value;
        });
      });
    }
    /**
     * Return the previous timestamp of the data or undefined if the data was not received.
     * @param {string} label - label of the data.
     * @return {?number} Timestamp of the previous data or null.
     */

  }, {
    key: "getPrevReceivedDataTimestamp",
    value: function getPrevReceivedDataTimestamp(label) {
      if (this.prevReceivedData[label]) {
        return this.prevReceivedData[label].timestamp;
      }

      return null;
    }
    /**
     * Test whether the data received which had the label.
     * @param {object} args - the block's arguments.
     * @param {number} args.LABEL - label of the data.
     * @return {boolean} - true if the data received.
     */

  }, {
    key: "whenDataReceived",
    value: function whenDataReceived(args) {
      var _this23 = this;

      if (!this.updateLastDataTimer) {
        this.updateLastDataTimer = setTimeout(function () {
          _this23.updatePrevReceivedData();

          _this23.updateLastDataTimer = null;
        }, this.runtime.currentStepTime);
      }

      var label = args.LABEL;

      var lastTimestamp = this._peripheral.getDataTimestamp(label);

      if (lastTimestamp === null) return false;
      var prevTimestamp = this.getPrevReceivedDataTimestamp(label);
      if (prevTimestamp === null) return true;
      return lastTimestamp !== prevTimestamp;
    }
    /**
     * Test whether a micro:bit connected.
     * @param {object} args - the block's arguments.
     * @property {string} args.STATE - the state of connection to check.
     * @return {boolean} - true if the state is matched.
     */

  }, {
    key: "whenConnectionChanged",
    value: function whenConnectionChanged(args) {
      var state = args.STATE === 'connected';
      return state === this._peripheral.isConnected();
    }
  }], [{
    key: "formatMessage",
    set:
    /**
     * A translation object which is used in this class.
     * @param {FormatObject} formatter - translation object
     */
    function set(formatter) {
      formatMessage = formatter;
      if (formatMessage) setupTranslations();
    }
    /**
     * @return {string} - the name of this extension.
     */

  }, {
    key: "EXTENSION_NAME",
    get: function get() {
      return formatMessage({
        id: 'mbitMore.name',
        default: 'Boson',
        description: 'name of the extension'
      });
    }
    /**
     * @return {string} - the ID of this extension.
     */

  }, {
    key: "EXTENSION_ID",
    get: function get() {
      return EXTENSION_ID;
    }
    /**
     * URL to get this extension.
     * @type {string}
     */

  }, {
    key: "extensionURL",
    get: function get() {
      return extensionURL;
    }
    /**
     * Set URL to get this extension.
     * @param {string} url - URL
     */
    ,
    set: function set(url) {
      extensionURL = url;
    }
  }]);

  return MbitMoreBlocks;
}();

export { MbitMoreBlocks as blockClass, entry };